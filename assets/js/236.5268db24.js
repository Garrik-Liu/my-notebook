(window.webpackJsonp=window.webpackJsonp||[]).push([[236],{450:function(t,a,s){"use strict";s.r(a);var e=s(0),i=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"链表"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#链表"}},[t._v("#")]),t._v(" 链表")]),t._v(" "),s("p",[s("strong",[t._v('『 链表 Linked List 』也是一种 "线性表" 结构。')]),t._v("，但不同于数组，链表中的元素在内存中并不是连续放置的。")]),t._v(" "),s("p",[s("strong",[t._v("链表由一组连续的节点 node 构成，每个节点包含一个元素和一个指向下一个元素的指针")])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-1-13-12-59-59.png",alt:"2020-1-13-12-59-59.png"}})]),t._v(" "),s("h2",{attrs:{id:"单链表"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#单链表"}},[t._v("#")]),t._v(" 单链表")]),t._v(" "),s("p",[t._v("上图就是一个单链表。其中有两个结点是比较特殊的，它们分别是第一个结点和最后一个结点。我们习惯性地把第一个结点叫作『 "),s("strong",[t._v("头结点")]),t._v(" Head Node 』，把最后一个结点叫作『 "),s("strong",[t._v("尾结点")]),t._v(" Tail Node 』。")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("头结点指向链表中的第一个节点")]),t._v("。")]),t._v(" "),s("li",[s("strong",[t._v("尾结点上 "),s("code",[t._v("next")]),t._v(" 指针指向一个空地址 Null")]),t._v("，表示这是链表上最后一个结点。")])]),t._v(" "),s("hr"),t._v(" "),s("p",[t._v("相对于传统的数组，链表的一个好处在于，因为链表的存储空间本身就不是连续的。"),s("strong",[t._v("链表添加或移除元素的时候不需要移动其他元素")]),t._v("。")]),t._v(" "),s("p",[t._v("从下图中我们可以看出，针对链表的插入和删除操作，我们只需要考虑相邻结点的指针改变，所以对应的时间复杂度是 "),s("eq",[s("span",{staticClass:"katex"},[s("span",{staticClass:"katex-mathml"},[s("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[s("semantics",[s("mrow",[s("mi",[t._v("O")]),s("mo",{attrs:{stretchy:"false"}},[t._v("(")]),s("mn",[t._v("1")]),s("mo",{attrs:{stretchy:"false"}},[t._v(")")])],1),s("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("O(1)")])],1)],1)],1),s("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[s("span",{staticClass:"base"},[s("span",{staticClass:"strut",staticStyle:{height:"1em","vertical-align":"-0.25em"}}),s("span",{staticClass:"mord mathdefault",staticStyle:{"margin-right":"0.02778em"}},[t._v("O")]),s("span",{staticClass:"mopen"},[t._v("(")]),s("span",{staticClass:"mord"},[t._v("1")]),s("span",{staticClass:"mclose"},[t._v(")")])])])])]),t._v("。")],1),t._v(" "),s("p",[s("img",{attrs:{src:"https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-1-13-13-7-35.png",alt:"2020-1-13-13-7-35.png"}})]),t._v(" "),s("p",[t._v("但是要"),s("strong",[t._v("想访问链表中间的一个元素，需要从表头开始迭代列表直到找到所需的元素")]),t._v("。")]),t._v(" "),s("h2",{attrs:{id:"循环链表"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#循环链表"}},[t._v("#")]),t._v(" 循环链表")]),t._v(" "),s("p",[s("strong",[t._v("循环链表的尾结点指针是指向链表的头结点")]),t._v("。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-1-13-13-10-2.png",alt:"2020-1-13-13-10-2.png"}})]),t._v(" "),s("p",[t._v("循环链表的优点是从链尾到链头比较方便。")]),t._v(" "),s("h2",{attrs:{id:"双向链表"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#双向链表"}},[t._v("#")]),t._v(" 双向链表")]),t._v(" "),s("p",[s("strong",[t._v("双向链表它支持两个方向，每个结点不止有一个后继指针 "),s("code",[t._v("next")]),t._v(" 指向后面的结点，还有一个前驱指针 "),s("code",[t._v("prev")]),t._v(" 指向前面的结点")]),t._v("。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-1-13-13-11-23.png",alt:"2020-1-13-13-11-23.png"}})]),t._v(" "),s("p",[t._v("从结构上来看，双向链表可以支持 "),s("eq",[s("span",{staticClass:"katex"},[s("span",{staticClass:"katex-mathml"},[s("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[s("semantics",[s("mrow",[s("mi",[t._v("O")]),s("mo",{attrs:{stretchy:"false"}},[t._v("(")]),s("mn",[t._v("1")]),s("mo",{attrs:{stretchy:"false"}},[t._v(")")])],1),s("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("O(1)")])],1)],1)],1),s("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[s("span",{staticClass:"base"},[s("span",{staticClass:"strut",staticStyle:{height:"1em","vertical-align":"-0.25em"}}),s("span",{staticClass:"mord mathdefault",staticStyle:{"margin-right":"0.02778em"}},[t._v("O")]),s("span",{staticClass:"mopen"},[t._v("(")]),s("span",{staticClass:"mord"},[t._v("1")]),s("span",{staticClass:"mclose"},[t._v(")")])])])])]),t._v(" 时间复杂度的情况下找到前驱结点，正是这样的特点，也使双向链表在某些情况下的插入、删除等操作都要比单链表简单、高效。")],1),t._v(" "),s("hr"),t._v(" "),s("p",[t._v("🌰 举例来讲，在删除操作中，一般有如下两种情况：")]),t._v(" "),s("ul",[s("li",[t._v("删除结点中“值等于某个给定值”的结点；")]),t._v(" "),s("li",[t._v("删除给定指针指向的结点。")])]),t._v(" "),s("p",[t._v("对于第一种情况，不管是单链表还是双向链表，为了查找到值等于给定值的结点，都需要从头结点开始依次遍历对比，直到找到值等于给定值的结点。时间复杂度为 "),s("eq",[s("span",{staticClass:"katex"},[s("span",{staticClass:"katex-mathml"},[s("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[s("semantics",[s("mrow",[s("mi",[t._v("O")]),s("mo",{attrs:{stretchy:"false"}},[t._v("(")]),s("mi",[t._v("n")]),s("mo",{attrs:{stretchy:"false"}},[t._v(")")])],1),s("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("O(n)")])],1)],1)],1),s("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[s("span",{staticClass:"base"},[s("span",{staticClass:"strut",staticStyle:{height:"1em","vertical-align":"-0.25em"}}),s("span",{staticClass:"mord mathdefault",staticStyle:{"margin-right":"0.02778em"}},[t._v("O")]),s("span",{staticClass:"mopen"},[t._v("(")]),s("span",{staticClass:"mord mathdefault"},[t._v("n")]),s("span",{staticClass:"mclose"},[t._v(")")])])])])])],1),t._v(" "),s("p",[t._v("对于第二种情况，我们已经找到了要删除的结点，但是删除某个结点 "),s("code",[t._v("q")]),t._v(" 需要知道其前驱结点，而单链表并不支持直接获取前驱结点。所以，为了找到前驱结点，我们还是要从头结点开始遍历链表。时间复杂度为 "),s("eq",[s("span",{staticClass:"katex"},[s("span",{staticClass:"katex-mathml"},[s("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[s("semantics",[s("mrow",[s("mi",[t._v("O")]),s("mo",{attrs:{stretchy:"false"}},[t._v("(")]),s("mi",[t._v("n")]),s("mo",{attrs:{stretchy:"false"}},[t._v(")")])],1),s("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("O(n)")])],1)],1)],1),s("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[s("span",{staticClass:"base"},[s("span",{staticClass:"strut",staticStyle:{height:"1em","vertical-align":"-0.25em"}}),s("span",{staticClass:"mord mathdefault",staticStyle:{"margin-right":"0.02778em"}},[t._v("O")]),s("span",{staticClass:"mopen"},[t._v("(")]),s("span",{staticClass:"mord mathdefault"},[t._v("n")]),s("span",{staticClass:"mclose"},[t._v(")")])])])])]),t._v("。")],1),t._v(" "),s("p",[t._v("但对于双向链表来说，结点已经保存了前驱结点的指针，不需要像单链表那样遍历。所以，针对第二种情况，双向链表的时间复杂度为 "),s("eq",[s("span",{staticClass:"katex"},[s("span",{staticClass:"katex-mathml"},[s("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[s("semantics",[s("mrow",[s("mi",[t._v("O")]),s("mo",{attrs:{stretchy:"false"}},[t._v("(")]),s("mn",[t._v("1")]),s("mo",{attrs:{stretchy:"false"}},[t._v(")")])],1),s("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("O(1)")])],1)],1)],1),s("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[s("span",{staticClass:"base"},[s("span",{staticClass:"strut",staticStyle:{height:"1em","vertical-align":"-0.25em"}}),s("span",{staticClass:"mord mathdefault",staticStyle:{"margin-right":"0.02778em"}},[t._v("O")]),s("span",{staticClass:"mopen"},[t._v("(")]),s("span",{staticClass:"mord"},[t._v("1")]),s("span",{staticClass:"mclose"},[t._v(")")])])])])]),t._v("。")],1),t._v(" "),s("h2",{attrs:{id:"双向循环链表"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#双向循环链表"}},[t._v("#")]),t._v(" 双向循环链表")]),t._v(" "),s("p",[t._v("结合一下双向链表和循环链表就是『 双向循环链表 』")]),t._v(" "),s("p",[t._v("双向循环链表有指向 "),s("code",[t._v("head")]),t._v(" 元素的 "),s("code",[t._v("tail.next")]),t._v(" 和指向 "),s("code",[t._v("tail")]),t._v(" 元素的 "),s("code",[t._v("head.prev")]),t._v("。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-1-13-13-30-55.png",alt:"2020-1-13-13-30-55.png"}})])])}),[],!1,null,null,null);a.default=i.exports}}]);