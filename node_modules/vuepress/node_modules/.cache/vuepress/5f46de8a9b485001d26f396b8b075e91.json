{"remainingRequest":"/Users/xiangliu/Projects/Web/front-end-notebook/node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!/Users/xiangliu/Projects/Web/front-end-notebook/node_modules/cache-loader/dist/cjs.js??ref--1-0!/Users/xiangliu/Projects/Web/front-end-notebook/node_modules/vue-loader/lib/index.js??ref--1-1!/Users/xiangliu/Projects/Web/front-end-notebook/node_modules/vuepress/lib/webpack/markdownLoader.js??ref--1-2!/Users/xiangliu/Projects/Web/front-end-notebook/docs/javascript/基础知识/函数.md?vue&type=template&id=2ec56167","dependencies":[{"path":"/Users/xiangliu/Projects/Web/front-end-notebook/docs/javascript/基础知识/函数.md","mtime":1533397531642},{"path":"/Users/xiangliu/Projects/Web/front-end-notebook/node_modules/cache-loader/dist/cjs.js","mtime":1532111594974},{"path":"/Users/xiangliu/Projects/Web/front-end-notebook/node_modules/vue-loader/lib/loaders/templateLoader.js","mtime":1532111597631},{"path":"/Users/xiangliu/Projects/Web/front-end-notebook/node_modules/cache-loader/dist/cjs.js","mtime":1532111594974},{"path":"/Users/xiangliu/Projects/Web/front-end-notebook/node_modules/vue-loader/lib/index.js","mtime":1532111597630},{"path":"/Users/xiangliu/Projects/Web/front-end-notebook/node_modules/vuepress/lib/webpack/markdownLoader.js","mtime":1532111597717}],"contextDependencies":[],"result":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"content\"},[_vm._ssrNode(\"<h1 id=\\\"函数\\\"><a href=\\\"#函数\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 函数</h1><p>函数可以封装任意多条语句，而且可以在任何地方、任何时候调用执行。函数实际上是对象。每个函数都是 <code>Function</code> 类型的实例. 都与其他引用类型一样具有属性和方法。由于函数是对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。</p><p>定义函数的方式有三种：一种是函数声明，另一种就是函数表达式。还有一种是使用 <code>Function</code> 构造函数</p><p><strong>函数声明</strong>的语法是这样的:</p><p>使用 <code>function</code> 关键字来声明，函数名后跟一组参数以及函数体</p><div class=\\\"language-js extra-class\\\"><pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">function</span> <span class=\\\"token function\\\">functionName</span><span class=\\\"token punctuation\\\">(</span>arg0<span class=\\\"token punctuation\\\">,</span> arg1<span class=\\\"token punctuation\\\">,</span> arg2<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token comment\\\">//函数体</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n</code></pre></div><p>函数声明, 它的一个重要特征就是函数声明提升（function declaration hoisting），意思是在执行代码之前会先读取函数声明。这就意味着可以把函数声明放在调用它的语句后面。</p><p><strong>函数表达式</strong>的语法是这样的:</p><div class=\\\"language-js extra-class\\\"><pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">var</span> <span class=\\\"token function-variable function\\\">functionName</span> <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">function</span><span class=\\\"token punctuation\\\">(</span>arg0<span class=\\\"token punctuation\\\">,</span> arg1<span class=\\\"token punctuation\\\">,</span> arg2<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token comment\\\">//函数体 </span>\\n<span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">;</span>\\n</code></pre></div><p>这种形式看起来好像是常规的变量赋值语句，即创建一个函数并将它赋值给变量。这种情况下创建的函数叫做匿名函数（anonymous function），因为 <code>function</code> 关键字后面没有标识符。</p><p><strong>Function 构造函数</strong> 可以接收任意数量的参数，但最后一个参数始终都被看成是函数体, 前面的参数则枚举出了新函数的参数</p><div class=\\\"language-js extra-class\\\"><pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">var</span> sum <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">Function</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">&quot;num1&quot;</span><span class=\\\"token punctuation\\\">,</span> <span class=\\\"token string\\\">&quot;num2&quot;</span><span class=\\\"token punctuation\\\">,</span> <span class=\\\"token string\\\">&quot;return num1 + num2&quot;</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span> <span class=\\\"token comment\\\">// 不推荐</span>\\n</code></pre></div><h2 id=\\\"传递参数\\\"><a href=\\\"#传递参数\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 传递参数</h2><p>ECMAScript 中所有函数的参数都是 <strong>按值传递</strong> 的, 也就是说，把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样。</p><p><strong>引用传递</strong>是指在调用函数时将实际参数的地址传递到函数中,</p><p>值传递的精髓是：<strong>传递的是存储单元中的内容，而非地址或者引用！</strong></p><p>在向参数传递基本类型的值时，被传递的值会被复制给一个局部变量（即命名参数，或者用 ECMAScript 的概念来说，就是 <code>arguments</code> 对象中的一个元素）</p><p>在向参数传递引用类型的值时，会把这个值所指向在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部。</p><div class=\\\"language-js extra-class\\\"><pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">function</span> <span class=\\\"token function\\\">setName</span><span class=\\\"token punctuation\\\">(</span>obj<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    obj<span class=\\\"token punctuation\\\">.</span>name <span class=\\\"token operator\\\">=</span> <span class=\\\"token string\\\">&quot;Nicholas&quot;</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n\\n<span class=\\\"token keyword\\\">var</span> person <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">Object</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token function\\\">setName</span><span class=\\\"token punctuation\\\">(</span>person<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token function\\\">alert</span><span class=\\\"token punctuation\\\">(</span>person<span class=\\\"token punctuation\\\">.</span>name<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>    <span class=\\\"token comment\\\">//&quot;Nicholas&quot;</span>\\n</code></pre></div><p>那不对呀, 传递引用类型的时候复制不还是引用吗? 内部修改为什么会反映到外部?</p><p>JavaScript 编程语言只有值传递参数。当一个对象实例作为一个参数被传递到方法中时，参数的值就是该标识符对象实例的引用的副本。指向同一个实体对象, 对象的内容可以在被调用的方法中改变，但对象的引用(不是引用的副本)是永远不会改变的。</p><h2 id=\\\"内部属性\\\"><a href=\\\"#内部属性\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 内部属性</h2><h3 id=\\\"arguments-对象\\\"><a href=\\\"#arguments-对象\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> arguments 对象</h3><p>函数不介意传递进来多少个参数，也不在乎传进来参数是什么数据类型。ECMAScript 中的参数在内部是用一个数组来表示的。函数接收到的始终都是这个数组，而不关心数组中包含哪些参数, 函数体内可以通过 <code>arguments</code> 对象来访问函数调用时传进来的实参组成的数组.</p><p><code>arguments</code> 是对象, 不是 <code>Array</code> 的实例, 但是可以像数组一样用方括号语法访问它的每一个属性, 使用 <code>length</code> 属性来确定传递进来多少个参数( &quot;arguments&quot; ), 函数对象自身也有一个 <code>length</code> 属性, 返回希望接收的命名/形式参数( &quot;parameters&quot; )个数.</p><blockquote><p>实参(&quot;argument&quot;)：全称为 &quot;实际参数&quot; 是在调用时传递给函数的参数\\n形参(&quot;parameter&quot;)：全称为 &quot;形式参数&quot; 由于它不是实际存在变量，所以又称虚拟变量。是在定义函数名和函数体的时候使用的参数, 目的是用来接收调用该函数时传入的参数. 在调用函数时，实参将赋值给形参。</p></blockquote><p>有点像下面这样:</p><div class=\\\"language-js extra-class\\\"><pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">var</span> arguments <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token string\\\">&quot;0&quot;</span><span class=\\\"token punctuation\\\">:</span> arg0<span class=\\\"token punctuation\\\">,</span>\\n    <span class=\\\"token string\\\">&quot;1&quot;</span><span class=\\\"token punctuation\\\">:</span> arg1<span class=\\\"token punctuation\\\">,</span>\\n    <span class=\\\"token string\\\">&quot;2&quot;</span><span class=\\\"token punctuation\\\">:</span> arg2<span class=\\\"token punctuation\\\">,</span>\\n    <span class=\\\"token operator\\\">...</span>\\n    <span class=\\\"token string\\\">&quot;N-1&quot;</span><span class=\\\"token punctuation\\\">:</span> argN<span class=\\\"token punctuation\\\">,</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n\\nconsole<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span>arguments<span class=\\\"token punctuation\\\">[</span><span class=\\\"token number\\\">2</span><span class=\\\"token punctuation\\\">]</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span> <span class=\\\"token comment\\\">// arg2</span>\\n</code></pre></div><p><code>arguments</code> 的值永远与对应命名参数的值保持同步, <code>arguments</code> 对象中的值会自动反映到对应的命名参数, 修改 <code>arguments\\b</code> 对象属性的值, 也会修改对应的命名参数</p><h3 id=\\\"arguments-callee\\\"><a href=\\\"#arguments-callee\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> arguments.callee</h3><p><code>arguments</code> 对象还有一个名叫 <code>callee</code> 的属性，该属性是一个指针，指向拥有这个 <code>arguments</code> 对象的函数</p><p>一个经典用法是:</p><div class=\\\"language-js extra-class\\\"><pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">function</span> <span class=\\\"token function\\\">factorial</span><span class=\\\"token punctuation\\\">(</span>num<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>num <span class=\\\"token operator\\\">&lt;=</span><span class=\\\"token number\\\">1</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n        <span class=\\\"token keyword\\\">return</span> <span class=\\\"token number\\\">1</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token punctuation\\\">}</span> <span class=\\\"token keyword\\\">else</span> <span class=\\\"token punctuation\\\">{</span>\\n        <span class=\\\"token keyword\\\">return</span> num <span class=\\\"token operator\\\">*</span> <span class=\\\"token function\\\">factorial</span><span class=\\\"token punctuation\\\">(</span>num<span class=\\\"token operator\\\">-</span><span class=\\\"token number\\\">1</span><span class=\\\"token punctuation\\\">)</span>\\n    <span class=\\\"token punctuation\\\">}</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n</code></pre></div><p>定义阶乘函数一般都要用到递归算法；如上面的代码所示，在函数有名字，而且名字以后也不会变的情况下，这样定义没有问题。但问题是这个函数的执行与函数名 <code>factorial</code> 紧紧耦合在了一起。为了消除这种紧密耦合的现象，可以像下面这样使用 <code>arguments.callee</code>。</p><div class=\\\"language-js extra-class\\\"><pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">function</span> <span class=\\\"token function\\\">factorial</span><span class=\\\"token punctuation\\\">(</span>num<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>num <span class=\\\"token operator\\\">&lt;=</span><span class=\\\"token number\\\">1</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n        <span class=\\\"token keyword\\\">return</span> <span class=\\\"token number\\\">1</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token punctuation\\\">}</span> <span class=\\\"token keyword\\\">else</span> <span class=\\\"token punctuation\\\">{</span>\\n        <span class=\\\"token keyword\\\">return</span> num <span class=\\\"token operator\\\">*</span> arguments<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">callee</span><span class=\\\"token punctuation\\\">(</span>num<span class=\\\"token operator\\\">-</span><span class=\\\"token number\\\">1</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token punctuation\\\">}</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n</code></pre></div><h3 id=\\\"caller\\\"><a href=\\\"#caller\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> caller</h3><p>函数内的 <code>caller</code> 属性返回调用指定函数的函数.</p><p>如果一个函数 <code>f</code> 是在全局作用域内被调用的,则 <code>f.caller</code> 为 <code>null</code> ,相反,如果一个函数是在另外一个函数作用域内被调用的,则 <code>f.caller</code> 指向调用它的那个函数.</p><p>该属性的常用形式 <code>arguments.callee.caller</code> 替代了被废弃的 <code>arguments.caller</code>.</p><div class=\\\"language-js extra-class\\\"><pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">function</span> <span class=\\\"token function\\\">myFunc</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n   <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>myFunc<span class=\\\"token punctuation\\\">.</span>caller <span class=\\\"token operator\\\">==</span> <span class=\\\"token keyword\\\">null</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n      <span class=\\\"token keyword\\\">return</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">&quot;该函数在全局作用域内被调用!&quot;</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n   <span class=\\\"token punctuation\\\">}</span> <span class=\\\"token keyword\\\">else</span>\\n      <span class=\\\"token keyword\\\">return</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">&quot;调用我的是函数是&quot;</span> <span class=\\\"token operator\\\">+</span> myFunc<span class=\\\"token punctuation\\\">.</span>caller<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n</code></pre></div><p>为了让函数名和函数体解耦, 可以改成下面这样:</p><div class=\\\"language-js extra-class\\\"><pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">function</span> <span class=\\\"token function\\\">myFunc</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n   <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>arguments<span class=\\\"token punctuation\\\">.</span>callee<span class=\\\"token punctuation\\\">.</span>caller <span class=\\\"token operator\\\">==</span> <span class=\\\"token keyword\\\">null</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n      <span class=\\\"token keyword\\\">return</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">&quot;该函数在全局作用域内被调用!&quot;</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n   <span class=\\\"token punctuation\\\">}</span> <span class=\\\"token keyword\\\">else</span>\\n      <span class=\\\"token keyword\\\">return</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">&quot;调用我的是函数是&quot;</span> <span class=\\\"token operator\\\">+</span> arguments<span class=\\\"token punctuation\\\">.</span>callee<span class=\\\"token punctuation\\\">.</span>caller<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n</code></pre></div><h3 id=\\\"this\\\"><a href=\\\"#this\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> this</h3><p><code>this</code> 引用的是函数执行的环境对象. 比如, 当在网页的全局作用域中调用函数时，<code>this</code> 对象引用的就是 <code>window</code></p><div class=\\\"language-js extra-class\\\"><pre class=\\\"language-js\\\"><code>window<span class=\\\"token punctuation\\\">.</span>color <span class=\\\"token operator\\\">=</span> <span class=\\\"token string\\\">&quot;red&quot;</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token keyword\\\">var</span> o <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">{</span> color<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token string\\\">&quot;blue&quot;</span> <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">;</span>\\n\\n<span class=\\\"token keyword\\\">function</span> <span class=\\\"token function\\\">sayColor</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token function\\\">alert</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span>color<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n\\n<span class=\\\"token function\\\">sayColor</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>     <span class=\\\"token comment\\\">//&quot;red&quot;</span>\\n\\no<span class=\\\"token punctuation\\\">.</span>sayColor <span class=\\\"token operator\\\">=</span> sayColor<span class=\\\"token punctuation\\\">;</span>\\no<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">sayColor</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>   <span class=\\\"token comment\\\">//&quot;blue&quot;</span>\\n</code></pre></div><h2 id=\\\"没有重载\\\"><a href=\\\"#没有重载\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 没有重载</h2><p>ECMAScript 函数不能像传统意义上那样实现重载, 即为一个函数编写两个定义.</p><p>两个同名函数出现, 后面的覆盖前面的.</p><div class=\\\"language-js extra-class\\\"><pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">function</span> <span class=\\\"token function\\\">addSomeNumber</span><span class=\\\"token punctuation\\\">(</span>num<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">return</span> num <span class=\\\"token operator\\\">+</span> <span class=\\\"token number\\\">100</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n\\n<span class=\\\"token keyword\\\">function</span> <span class=\\\"token function\\\">addSomeNumber</span><span class=\\\"token punctuation\\\">(</span>num<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">return</span> num <span class=\\\"token operator\\\">+</span> <span class=\\\"token number\\\">200</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n\\n<span class=\\\"token keyword\\\">var</span> result <span class=\\\"token operator\\\">=</span> <span class=\\\"token function\\\">addSomeNumber</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token number\\\">100</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span> <span class=\\\"token comment\\\">//300</span>\\n</code></pre></div><p>因为函数名保存的是指向函数对象的\\b指针, 以上代码实际上等价于下面的代码:</p><div class=\\\"language-js extra-class\\\"><pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">var</span> <span class=\\\"token function-variable function\\\">addSomeNumber</span> <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">function</span> <span class=\\\"token punctuation\\\">(</span>num<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">return</span> num <span class=\\\"token operator\\\">+</span> <span class=\\\"token number\\\">100</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">;</span>\\n\\n<span class=\\\"token function-variable function\\\">addSomeNumber</span> <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">function</span> <span class=\\\"token punctuation\\\">(</span>num<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">return</span> num <span class=\\\"token operator\\\">+</span> <span class=\\\"token number\\\">200</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">;</span>\\n\\n<span class=\\\"token keyword\\\">var</span> result <span class=\\\"token operator\\\">=</span> <span class=\\\"token function\\\">addSomeNumber</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token number\\\">100</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span> <span class=\\\"token comment\\\">//300</span>\\n</code></pre></div><p>因为用了相同的函数名, 则指针指向了后者.</p><h2 id=\\\"递归\\\"><a href=\\\"#递归\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 递归</h2><p>递归函数是在一个函数内通过名字调用自身的情况下构成的</p><div class=\\\"language-js extra-class\\\"><pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">function</span> <span class=\\\"token function\\\">factorial</span><span class=\\\"token punctuation\\\">(</span>num<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>num <span class=\\\"token operator\\\">&lt;=</span> <span class=\\\"token number\\\">1</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">{</span>\\n        <span class=\\\"token keyword\\\">return</span> <span class=\\\"token number\\\">1</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token punctuation\\\">}</span> <span class=\\\"token keyword\\\">else</span> <span class=\\\"token punctuation\\\">{</span>\\n        <span class=\\\"token keyword\\\">return</span> num <span class=\\\"token operator\\\">*</span> <span class=\\\"token function\\\">factorial</span><span class=\\\"token punctuation\\\">(</span>num<span class=\\\"token operator\\\">-</span><span class=\\\"token number\\\">1</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token punctuation\\\">}</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n</code></pre></div><p>前面提到过, 用 <code>arguments.callee</code> 是一个指向正在执行的函数(<code>arguments</code>对象所在函数)的指针, 用他可以让函数名和函数体解耦.</p><div class=\\\"language-js extra-class\\\"><pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">function</span> <span class=\\\"token function\\\">factorial</span><span class=\\\"token punctuation\\\">(</span>num<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>num <span class=\\\"token operator\\\">&lt;=</span> <span class=\\\"token number\\\">1</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">{</span>\\n        <span class=\\\"token keyword\\\">return</span> <span class=\\\"token number\\\">1</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token punctuation\\\">}</span> <span class=\\\"token keyword\\\">else</span> <span class=\\\"token punctuation\\\">{</span>\\n        <span class=\\\"token keyword\\\">return</span> num <span class=\\\"token operator\\\">*</span> arguments<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">callee</span><span class=\\\"token punctuation\\\">(</span>num<span class=\\\"token operator\\\">-</span><span class=\\\"token number\\\">1</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token punctuation\\\">}</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n</code></pre></div><p>但在严格模式下，不能通过脚本访问 <code>arguments.callee</code>，访问这个属性会导致错误。不过，可以使用<strong>命名函数表达式</strong>来达成相同的结果。</p><p>命名函数表达式 = 函数表达式 + 函数声明</p><div class=\\\"language-js extra-class\\\"><pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">var</span> factorial <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">function</span> <span class=\\\"token function\\\">f</span><span class=\\\"token punctuation\\\">(</span>num<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>num <span class=\\\"token operator\\\">&lt;=</span> <span class=\\\"token number\\\">1</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">{</span> \\n        <span class=\\\"token keyword\\\">return</span> <span class=\\\"token number\\\">1</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token punctuation\\\">}</span> <span class=\\\"token keyword\\\">else</span> <span class=\\\"token punctuation\\\">{</span>\\n        <span class=\\\"token keyword\\\">return</span> num <span class=\\\"token operator\\\">*</span> <span class=\\\"token function\\\">f</span><span class=\\\"token punctuation\\\">(</span>num<span class=\\\"token operator\\\">-</span><span class=\\\"token number\\\">1</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token punctuation\\\">}</span>\\n<span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n</code></pre></div><h2 id=\\\"闭包\\\"><a href=\\\"#闭包\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 闭包</h2><h2 id=\\\"模仿块级作用域\\\"><a href=\\\"#模仿块级作用域\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 模仿块级作用域</h2><h2 id=\\\"私有变量\\\"><a href=\\\"#私有变量\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 私有变量</h2>\")])}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }"]}