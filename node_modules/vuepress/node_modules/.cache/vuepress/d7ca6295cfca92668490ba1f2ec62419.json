{"remainingRequest":"/Users/xiangliu/Projects/Web/front-end-notebook/node_modules/vue-loader/lib/index.js??ref--1-1!/Users/xiangliu/Projects/Web/front-end-notebook/node_modules/vuepress/lib/webpack/markdownLoader.js??ref--1-2!/Users/xiangliu/Projects/Web/front-end-notebook/docs/数据结构与算法/算法/递归.md?vue&type=template&id=94c84308","dependencies":[{"path":"/Users/xiangliu/Projects/Web/front-end-notebook/docs/数据结构与算法/算法/递归.md","mtime":1542162367291},{"path":"/Users/xiangliu/Projects/Web/front-end-notebook/node_modules/cache-loader/dist/cjs.js","mtime":1532111594974},{"path":"/Users/xiangliu/Projects/Web/front-end-notebook/node_modules/vue-loader/lib/loaders/templateLoader.js","mtime":1532111597631},{"path":"/Users/xiangliu/Projects/Web/front-end-notebook/node_modules/cache-loader/dist/cjs.js","mtime":1532111594974},{"path":"/Users/xiangliu/Projects/Web/front-end-notebook/node_modules/vue-loader/lib/index.js","mtime":1532111597630},{"path":"/Users/xiangliu/Projects/Web/front-end-notebook/node_modules/vuepress/lib/webpack/markdownLoader.js","mtime":1532111597717}],"contextDependencies":[],"result":["\n<div class=\"content\"><h1 id=\"递归\"><a class=\"header-anchor\" href=\"#递归\" aria-hidden=\"true\">#</a> 递归</h1>\n<p>递归是一种应用非常广泛的算法（或者编程技巧）</p>\n<p>假如你在站在一个队伍中, 你想知道你在队伍中的具体位置.  于是你就问站在你前面的那个人, 那么人也不清楚, 他就继续问他前面的人.  就这样一个一个地问下去, 一直问道站在队伍中的第一个人.  以他的位置为 '1', 之后他后面的人再在前一个人位置的基础上 '+1'.  一直把位置返回到你这里, 你就知道你的位置了.</p>\n<p>这就是一个非常标准的递归求解问题的分解过程，<strong>去的过程叫“递”, 回来的过程叫“归”</strong>。</p>\n<p>所有的递归问题都可以用递推公式来表示, 刚刚这个生活中的例子，我们用递推公式将它表示出来就是这样的：<code>f(n)=f(n-1)+1</code> 其中，<code>f(1)=1</code></p>\n<p><code>f(n)</code> 表示你想知道自己的位置，<code>f(n-1)</code> 表示前面一个人所在的位置，<code>f(1)=1</code> 表示第一个的人知道自己在第一个。</p>\n<!--beforebegin--><div class=\"language-js extra-class\"><!--afterbegin--><pre v-pre class=\"language-js\"><code><span class=\"token comment\">// 通过 \"递归公式\", 写出 \"递归代码\"</span>\n<span class=\"token keyword\">var</span> <span class=\"token function-variable function\">x</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">===</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">1</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token function\">x</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">x</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 结果为 10</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><h2 id=\"递归需要满足的三个条件\"><a class=\"header-anchor\" href=\"#递归需要满足的三个条件\" aria-hidden=\"true\">#</a> 递归需要满足的三个条件</h2>\n<p>那究竟什么样的问题可以用递归来解决呢？我总结了三个条件，只要同时满足以下三个条件，就可以用递归来解决。</p>\n<ol>\n<li><strong>一个问题的解可以分解为几个子问题的解</strong></li>\n</ol>\n<p>子问题就是数据规模更小的问题。就像前面例子中, 将 &quot;想知道自己所在位置&quot; , 分解成 &quot;想知道前一个人的位置&quot;</p>\n<ol start=\"2\">\n<li><strong>这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样</strong></li>\n</ol>\n<p>前面例子中, &quot;想知道自己所在位置&quot; 和 &quot;想知道前一个人的位置&quot; 的思路是一样的.</p>\n<ol start=\"3\">\n<li><strong>存在递归终止条件</strong></li>\n</ol>\n<p>把问题分解为子问题，把子问题再分解为子子问题，一层一层分解下去，不能存在无限循环，这就需要有终止条件。</p>\n<p>前面例子中, 站在一个的人, 它知道自己的位置为 '1', 不需要再问别人.</p>\n<h2 id=\"如何编写递归代码？\"><a class=\"header-anchor\" href=\"#如何编写递归代码？\" aria-hidden=\"true\">#</a> 如何编写递归代码？</h2>\n<p>写递归代码最关键的是<strong>写出递推公式，找到终止条件</strong>，剩下将递推公式转化为代码就很简单了。</p>\n<p>例题:</p>\n<p>假如这里有 n 个台阶，每次你可以跨 1 个台阶或者 2 个台阶，请问走这 n 个台阶有多少种走法？</p>\n<p>如果有 7 个台阶，你可以 2，2，2，1 这样子上去，也可以 1，2，1，1，2 这样子上去，总之走法有很多，那如何用编程求得总共有多少种走法呢？</p>\n<p>实际上，可以根据第一步的走法把所有走法分为两类:</p>\n<ul>\n<li>第一步走了 1 个台阶</li>\n<li>第一步走了 2 个台阶</li>\n</ul>\n<p>所以 n 个台阶的走法就等于先走 1 阶后, n-1 个台阶的走法, 加上先走 2 阶后，n-2 个台阶的走法。用公式表示就是：</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>f(n) = f(n-1) + f(n-2)\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>当有一个台阶时，我们不需要再继续递归，就只有一种走法。所以 f(1)=1。当剩两个台阶时, 有两种走法, 一步走完或者分两步来走。</p>\n<p>递归终止条件和刚刚得到的递推公式放到一起就是这样的：</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>f(1) = 1;\nf(2) = 2;\nf(n) = f(n-1) + f(n-2)\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>递归代码:</p>\n<!--beforebegin--><div class=\"language-js extra-class\"><!--afterbegin--><pre v-pre class=\"language-js\"><code><span class=\"token keyword\">var</span> <span class=\"token function-variable function\">x</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">===</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">===</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token function\">x</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token function\">x</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">x</span><span class=\"token punctuation\">(</span><span class=\"token number\">50</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>计算机擅长做重复的事情，所以递归正和它的胃口。而我们人脑更喜欢平铺直叙的思维方式。当我们看到递归时，我们总想把递归平铺展开，脑子里就会循环，一层一层往下调，然后再一层一层返回，试图想搞清楚计算机每一步都是怎么执行的，这样就很容易被绕进去.</p>\n<p>那正确的思维方式应该是怎样的呢？</p>\n<p><strong>如果一个问题 A 可以分解为若干子问题 B、C、D，你可以假设子问题 B、C、D 已经解决，在此基础上思考如何解决问题 A</strong>。</p>\n<p>而且，你只需要思考问题 A 与子问题 B、C、D 两层之间的关系即可，不需要一层一层往下思考子问题与子子问题.</p>\n<h2 id=\"递归代码要警惕堆栈溢出\"><a class=\"header-anchor\" href=\"#递归代码要警惕堆栈溢出\" aria-hidden=\"true\">#</a> 递归代码要警惕堆栈溢出</h2>\n<p>在实际的软件开发中，编写递归代码时，很容易堆栈溢出。而堆栈溢出会造成系统性崩溃，后果会非常严重。</p>\n<p>函数调用会使用栈来保存临时变量。每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时，才出栈。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险。</p>\n<p>如何避免出现堆栈溢出呢？</p>\n<p>我们可以通过在代码中限制递归调用的最大深度的方式来解决这个问题.  但这种做法并不能完全解决问题，因为最大允许的递归深度跟当前线程剩余的栈空间大小有关，事先无法计算。所以，如果最大深度比较小，比如 10、50，就可以用这种方法, 否则这种方法并不是很实用。</p>\n<h2 id=\"递归代码要警惕重复计算\"><a class=\"header-anchor\" href=\"#递归代码要警惕重复计算\" aria-hidden=\"true\">#</a> 递归代码要警惕重复计算</h2>\n<p><img src=\"https://i.imgur.com/EsiFkX0.jpg\" alt=\"e7e778994e90265344f6ac9da39e01bf\"></p>\n<p>想要计算 f(5)，需要先计算 f(4) 和 f(3)，而计算 f(4) 还需要计算 f(3)，因此，f(3) 就被计算了很多次，这就是重复计算问题。</p>\n<p>为了避免重复计算，我们可以通过一个数据结构（比如散列表）来保存已经求解过的 f(k)。</p>\n<p>当递归调用到 f(k) 时，先看下是否已经求解过了。如果是，则直接从散列表中取值返回，</p>\n<h2 id=\"怎么将递归代码改写为非递归代码？\"><a class=\"header-anchor\" href=\"#怎么将递归代码改写为非递归代码？\" aria-hidden=\"true\">#</a> 怎么将递归代码改写为非递归代码？</h2>\n<p>递归有利有弊，利是递归代码的表达力很强，写起来非常简洁；而弊就是空间复杂度高、有堆栈溢出的风险、存在重复计算、过多的函数调用会耗时较多等问题。所以，在开发过程中，我们要根据实际情况来选择是否需要用递归的方式来实现。</p>\n<p>比如前面排队的那个问题就可以改写成下面这样:</p>\n<!--beforebegin--><div class=\"language-js extra-class\"><!--afterbegin--><pre v-pre class=\"language-js\"><code><span class=\"token keyword\">var</span> <span class=\"token function-variable function\">x</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// \b\b\b可确定的第一个人位置为 '1'</span>\n    <span class=\"token keyword\">var</span> result <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">===</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        result <span class=\"token operator\">+=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">x</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>笼统地讲，所有的递归代码都可以改为这种<strong>迭代循环</strong>的非递归写法。因为递归本身就是借助栈来实现的，只不过我们使用的栈是系统或者虚拟机本身提供的，如果我们自己在内存堆上实现栈，手动模拟入栈、出栈过程，这样任何递归代码都可以改写成看上去不是递归代码的样子。</p>\n<p>但本质并没有变，而且也并没有解决前面讲到的某些问题，徒增了实现的复杂度.</p>\n<p>极客时间版权所有: https://time.geekbang.org/column/article/41440</p>\n<p>极客时间版权所有: https://time.geekbang.org/column/article/41440</p>\n<p>极客时间版权所有: https://time.geekbang.org/column/article/41440</p>\n<p>极客时间版权所有: https://time.geekbang.org/column/article/41440</p>\n<p>极客时间版权所有: https://time.geekbang.org/column/article/41440</p>\n<p>极客时间版权所有: https://time.geekbang.org/column/article/41440</p>\n<p>极客时间版权所有: https://time.geekbang.org/column/article/41440</p>\n<p>极客时间版权所有: https://time.geekbang.org/column/article/41440</p>\n<p>极客时间版权所有: https://time.geekbang.org/column/article/41440</p>\n<p>极客时间版权所有: https://time.geekbang.org/column/article/41440\n极客时间版权所有: https://time.geekbang.org/column/article/41440</p>\n<p>极客时间版权所有: https://time.geekbang.org/column/article/41440</p>\n<p>极客时间版权所有: https://time.geekbang.org/column/article/41440</p>\n<p>极客时间版权所有: https://time.geekbang.org/column/article/41440</p>\n<p>极客时间版权所有: https://time.geekbang.org/column/article/41440</p>\n<p>极客时间版权所有: https://time.geekbang.org/column/article/41440</p>\n<p>极客时间版权所有: https://time.geekbang.org/column/article/41440</p>\n<p>极客时间版权所有: https://time.geekbang.org/column/article/41440</p>\n<p>极客时间版权所有: https://time.geekbang.org/column/article/41440</p>\n<p>极客时间版权所有: https://time.geekbang.org/column/article/41440\n极客时间版权所有: https://time.geekbang.org/column/article/41440</p>\n</div>\n",null]}