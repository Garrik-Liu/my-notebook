{"remainingRequest":"/Users/xiangliu/Projects/Web/front-end-notebook/node_modules/vue-loader/lib/index.js??ref--1-1!/Users/xiangliu/Projects/Web/front-end-notebook/node_modules/vuepress/lib/webpack/markdownLoader.js??ref--1-2!/Users/xiangliu/Projects/Web/front-end-notebook/docs/前端开发/javascript/ES6/let和const.md?vue&type=template&id=59739fdb","dependencies":[{"path":"/Users/xiangliu/Projects/Web/front-end-notebook/docs/前端开发/javascript/ES6/let和const.md","mtime":1538681619553},{"path":"/Users/xiangliu/Projects/Web/front-end-notebook/node_modules/cache-loader/dist/cjs.js","mtime":1532111594974},{"path":"/Users/xiangliu/Projects/Web/front-end-notebook/node_modules/vue-loader/lib/loaders/templateLoader.js","mtime":1532111597631},{"path":"/Users/xiangliu/Projects/Web/front-end-notebook/node_modules/cache-loader/dist/cjs.js","mtime":1532111594974},{"path":"/Users/xiangliu/Projects/Web/front-end-notebook/node_modules/vue-loader/lib/index.js","mtime":1532111597630},{"path":"/Users/xiangliu/Projects/Web/front-end-notebook/node_modules/vuepress/lib/webpack/markdownLoader.js","mtime":1532111597717}],"contextDependencies":[],"result":["\n<div class=\"content\"><h1 id=\"let-和-const-命令\"><a class=\"header-anchor\" href=\"#let-和-const-命令\" aria-hidden=\"true\">#</a> let 和 const 命令</h1>\n<h2 id=\"let\"><a class=\"header-anchor\" href=\"#let\" aria-hidden=\"true\">#</a> let</h2>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/let\" target=\"_blank\" rel=\"noopener noreferrer\">文档 - MDN<OutboundLink/></a></p>\n<p><code>let</code> 命令，用来声明变量。它的用法类似于 <code>var</code>.  <code>let</code> 声明的变量只在它所在的代码块有效。</p>\n<!--beforebegin--><div class=\"language-js extra-class\"><!--afterbegin--><pre v-pre class=\"language-js\"><code><span class=\"token comment\">// 在 for 循环中, let 声明的 i, 在循环外找不到</span>\n\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// ReferenceError: i is not defined</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><h3 id=\"不存在变量提升\"><a class=\"header-anchor\" href=\"#不存在变量提升\" aria-hidden=\"true\">#</a> 不存在变量提升</h3>\n<p><code>var</code> 命令会发生 ”变量提升“ 现象，即变量可以在声明之前使用，值为 <code>undefined</code></p>\n<p><code>let</code> 所声明的变量一定要在声明后使用，否则报错。</p>\n<!--beforebegin--><div class=\"language-js extra-class\"><!--afterbegin--><pre v-pre class=\"language-js\"><code><span class=\"token comment\">// var 的情况</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>foo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 输出undefined</span>\n<span class=\"token keyword\">var</span> foo <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// let 的情况</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>bar<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 报错ReferenceError</span>\n<span class=\"token keyword\">let</span> bar <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><h3 id=\"暂时性死区\"><a class=\"header-anchor\" href=\"#暂时性死区\" aria-hidden=\"true\">#</a> 暂时性死区</h3>\n<p>只要块级作用域内存在 <code>let</code> 命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。</p>\n<!--beforebegin--><div class=\"language-js extra-class\"><!--afterbegin--><pre v-pre class=\"language-js\"><code><span class=\"token keyword\">var</span> tmp <span class=\"token operator\">=</span> <span class=\"token number\">123</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  tmp <span class=\"token operator\">=</span> <span class=\"token string\">'abc'</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ReferenceError</span>\n  <span class=\"token keyword\">let</span> tmp<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>上面代码中，存在全局变量 <code>tmp</code>，但是块级作用域内 <code>let</code> 又声明了一个局部变量 <code>tmp</code>，导致后者绑定这个块级作用域，所以在 <code>let</code> 声明变量前，对 <code>tmp</code> 赋值会报错。</p>\n<p>在代码块内，使用 <code>let</code> 命令声明变量之前，该变量都是不可用的。这在语法上，称为 “暂时性死区”（temporal dead zone，简称 TDZ）。</p>\n<p>🌰 看看下面这段代码问题出在哪?</p>\n<!--beforebegin--><div class=\"language-js extra-class\"><!--afterbegin--><pre v-pre class=\"language-js\"><code><span class=\"token keyword\">function</span> <span class=\"token function\">bar</span><span class=\"token punctuation\">(</span>x <span class=\"token operator\">=</span> y<span class=\"token punctuation\">,</span> y <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 报错</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>上面代码中，调用 <code>bar</code> 函数之所以报错（某些实现可能不报错），是因为参数 <code>x</code> 默认值等于另一个参数 <code>y</code>，而此时 <code>y</code> 还没有声明，属于”死区“。如果 <code>y</code> 的默认值是 <code>x</code>，就不会报错，因为此时 <code>x</code> 已经声明了。</p>\n<h3 id=\"不允许重复声明\"><a class=\"header-anchor\" href=\"#不允许重复声明\" aria-hidden=\"true\">#</a> 不允许重复声明</h3>\n<p><code>let</code> 不允许在相同作用域内，重复声明同一个变量。</p>\n<!--beforebegin--><div class=\"language-js extra-class\"><!--afterbegin--><pre v-pre class=\"language-js\"><code><span class=\"token comment\">// 报错</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> a <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 报错</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> a <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">let</span> a <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">func</span><span class=\"token punctuation\">(</span>arg<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> arg<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 报错</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><h3 id=\"es5-没有块级作用域\"><a class=\"header-anchor\" href=\"#es5-没有块级作用域\" aria-hidden=\"true\">#</a> ES5 没有块级作用域</h3>\n<p>ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。</p>\n<h4 id=\"内层变量覆盖外层变量\"><a class=\"header-anchor\" href=\"#内层变量覆盖外层变量\" aria-hidden=\"true\">#</a> 内层变量覆盖外层变量</h4>\n<p>变量提升，导致内层的 <code>tmp</code> 变量覆盖了外层的 <code>tmp</code> 变量。</p>\n<!--beforebegin--><div class=\"language-js extra-class\"><!--afterbegin--><pre v-pre class=\"language-js\"><code><span class=\"token keyword\">var</span> tmp <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>tmp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> tmp <span class=\"token operator\">=</span> <span class=\"token string\">'hello world'</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// undefined</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><h4 id=\"计数的循环变量泄露为全局变量\"><a class=\"header-anchor\" href=\"#计数的循环变量泄露为全局变量\" aria-hidden=\"true\">#</a> 计数的循环变量泄露为全局变量</h4>\n<!--beforebegin--><div class=\"language-js extra-class\"><!--afterbegin--><pre v-pre class=\"language-js\"><code><span class=\"token keyword\">var</span> s <span class=\"token operator\">=</span> <span class=\"token string\">'hello'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> s<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 5</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><h3 id=\"es6-的块级作用域\"><a class=\"header-anchor\" href=\"#es6-的块级作用域\" aria-hidden=\"true\">#</a> ES6 的块级作用域</h3>\n<p><code>let</code> 实际上让 JavaScript 实现了块级作用域。</p>\n<!--beforebegin--><div class=\"language-js extra-class\"><!--afterbegin--><pre v-pre class=\"language-js\"><code><span class=\"token keyword\">function</span> <span class=\"token function\">f1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> n <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> n <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 5</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>块级作用域的出现，实际上使得用<strong>立即执行函数表达式</strong>（IIFE）来构建函数作用域变得不再必要了。</p>\n<!--beforebegin--><div class=\"language-js extra-class\"><!--afterbegin--><pre v-pre class=\"language-js\"><code><span class=\"token comment\">// IIFE 写法</span>\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> tmp <span class=\"token operator\">=</span> <span class=\"token operator\">...</span><span class=\"token punctuation\">;</span>\n  <span class=\"token operator\">...</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 块级作用域写法</span>\n<span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> tmp <span class=\"token operator\">=</span> <span class=\"token operator\">...</span><span class=\"token punctuation\">;</span>\n  <span class=\"token operator\">...</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><h3 id=\"块级作用域-与-函数声明\"><a class=\"header-anchor\" href=\"#块级作用域-与-函数声明\" aria-hidden=\"true\">#</a> 块级作用域 与 函数声明</h3>\n<p>函数能不能在块级作用域之中声明？这是一个相当令人混淆的问题。</p>\n<p>ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。但是事实上, 各家浏览器都允许在块级作用域之中声明函数.</p>\n<p>ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于 <code>let</code>，<strong>在块级作用域之外不可引用</strong>。</p>\n<!--beforebegin--><div class=\"language-js extra-class\"><!--afterbegin--><pre v-pre class=\"language-js\"><code><span class=\"token comment\">// ES5 环境</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'I am outside!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">function</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'I am inside!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>上面的代码, 在 ES5 中运行，会得到 “I am inside!”.  在 ES6 中运行理论上会得到 “I am outside!” 但实际上在 ES6 浏览器中运行一下上面的代码，是可能会报错的.</p>\n<p>为了兼容老代码, 浏览器的实现可以不遵守 ES6 的规定.</p>\n<ul>\n<li>允许在块级作用域内声明函数。</li>\n<li>函数声明类似于var，即会提升到全局作用域或函数作用域的头部。</li>\n<li>同时，函数声明还会提升到所在的块级作用域的头部。</li>\n</ul>\n<p>所以我们应在块级作用域中写函数表达式，而不是函数声明语句.</p>\n<p>顺便一提, ES6 的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。</p>\n<!--beforebegin--><div class=\"language-js extra-class\"><!--afterbegin--><pre v-pre class=\"language-js\"><code><span class=\"token comment\">// 不报错</span>\n<span class=\"token string\">'use strict'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">function</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 报错</span>\n<span class=\"token string\">'use strict'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">function</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><h2 id=\"const\"><a class=\"header-anchor\" href=\"#const\" aria-hidden=\"true\">#</a> const</h2>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/const\" target=\"_blank\" rel=\"noopener noreferrer\">文档 - MDN<OutboundLink/></a></p>\n<p><code>const</code> 声明一个只读的常量。一旦声明，常量的值就不能改变。这意味着，<code>const</code> 一旦声明变量，就必须立即初始化</p>\n<p><code>const</code> 命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。</p>\n<p><code>const</code> 的作用域与 <code>let</code> 命令相同：只在声明所在的块级作用域内有效。</p>\n<p><code>const</code> 声明的常量，也与 <code>let</code> 一样不可重复声明。</p>\n<!--beforebegin--><div class=\"language-js extra-class\"><!--afterbegin--><pre v-pre class=\"language-js\"><code><span class=\"token keyword\">const</span> <span class=\"token constant\">PI</span> <span class=\"token operator\">=</span> <span class=\"token number\">3.1415</span><span class=\"token punctuation\">;</span>\n<span class=\"token constant\">PI</span> <span class=\"token comment\">// 3.1415</span>\n\n<span class=\"token constant\">PI</span> <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// TypeError: Assignment to constant variable.</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><p><code>const</code> 实际上保证的，并不是变量的值不得改动，而是<strong>变量指向的那个内存地址所保存的数据不得改动</strong>。</p>\n<p>对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，<code>const</code> 只能保证这个指针是固定的（即总是指向另一个固定的地址）</p>\n<h3 id=\"题外话-顶层对象的属性\"><a class=\"header-anchor\" href=\"#题外话-顶层对象的属性\" aria-hidden=\"true\">#</a> [题外话] 顶层对象的属性</h3>\n<p>顶层对象，在浏览器环境指的是 <code>window</code> 对象，在 Node 指的是 <code>global</code> 对象。ES5 之中，<strong>顶层对象的属性 与 全局变量 是等价的</strong>。</p>\n<!--beforebegin--><div class=\"language-js extra-class\"><!--afterbegin--><pre v-pre class=\"language-js\"><code>window<span class=\"token punctuation\">.</span>a <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\na <span class=\"token comment\">// 1</span>\n\na <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\nwindow<span class=\"token punctuation\">.</span>a <span class=\"token comment\">// 2</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>顶层对象的属性与全局变量挂钩，被认为是 JavaScript 语言最大的设计败笔之一。</p>\n<p>这样的设计带来了几个很大的问题:</p>\n<ul>\n<li>首先, 是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）</li>\n<li>其次, 程序员很容易不知不觉地就创建了全局变量（比如打字出错)</li>\n<li>最后, 顶层对象的属性是到处可以读写的，这非常不利于模块化编程</li>\n</ul>\n<p>另一方面，<code>window</code> 对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。</p>\n<p>ES6 为了改变这一点，一方面规定，为了保持兼容性，<code>var</code> 命令和 <code>function</code> 命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，<code>let</code> 命令、<code>const</code> 命令、<code>class</code> 命令声明的全局变量，不属于顶层对象的属性。</p>\n<h3 id=\"题外话-global-对象\"><a class=\"header-anchor\" href=\"#题外话-global-对象\" aria-hidden=\"true\">#</a> [题外话] global 对象</h3>\n<p>ES5 的顶层对象，本身也是一个问题，因为它在各种实现里面是不统一的。</p>\n<ul>\n<li>浏览器里面，顶层对象是 <code>window</code>，但 Node 和 Web Worker 没有 <code>window</code>。</li>\n<li>浏览器和 Web Worker 里面，<code>self</code> 也指向顶层对象，但是 Node 没有 <code>self</code>。</li>\n<li>Node 里面，顶层对象是 <code>global</code>，但其他环境都不支持。</li>\n</ul>\n<p>为了同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用 <code>this</code> 变量，但是有局限性。</p>\n<ul>\n<li>全局环境中，<code>this</code> 会返回顶层对象。但是，Node 模块和 ES6 模块中，<code>this</code> 返回的是当前模块。</li>\n<li>函数里面的 <code>this</code>，如果函数不是作为对象的方法运行，而是单纯作为函数运行，<code>this</code> 会指向顶层对象。但是，严格模式下，这时 <code>this</code> 会返回 <code>undefined</code>。</li>\n<li>不管是严格模式，还是普通模式，<code>new Function('return this')()</code>，总是会返回全局对象。但是，如果浏览器用了 CSP（Content Security Policy，内容安全策略），那么 <code>eval</code>、<code>new Function</code> 这些方法都可能无法使用。</li>\n</ul>\n<p>那么很难找到一种方法，<strong>可以在所有情况下，都取到顶层对象</strong>.  下面是两种勉强可以使用的方法:</p>\n<!--beforebegin--><div class=\"language-js extra-class\"><!--afterbegin--><pre v-pre class=\"language-js\"><code><span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> window <span class=\"token operator\">!==</span> <span class=\"token string\">'undefined'</span>\n   <span class=\"token operator\">?</span> window\n   <span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> process <span class=\"token operator\">===</span> <span class=\"token string\">'object'</span> <span class=\"token operator\">&amp;&amp;</span>\n      <span class=\"token keyword\">typeof</span> require <span class=\"token operator\">===</span> <span class=\"token string\">'function'</span> <span class=\"token operator\">&amp;&amp;</span>\n      <span class=\"token keyword\">typeof</span> global <span class=\"token operator\">===</span> <span class=\"token string\">'object'</span><span class=\"token punctuation\">)</span>\n     <span class=\"token operator\">?</span> global\n     <span class=\"token punctuation\">:</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 方法二</span>\n<span class=\"token keyword\">var</span> <span class=\"token function-variable function\">getGlobal</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> self <span class=\"token operator\">!==</span> <span class=\"token string\">'undefined'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">return</span> self<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> window <span class=\"token operator\">!==</span> <span class=\"token string\">'undefined'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">return</span> window<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> global <span class=\"token operator\">!==</span> <span class=\"token string\">'undefined'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">return</span> global<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token string\">'unable to locate global object'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--></div>\n",null]}