{"remainingRequest":"/Users/xiangliu/Projects/Web/front-end-notebook/node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!/Users/xiangliu/Projects/Web/front-end-notebook/node_modules/cache-loader/dist/cjs.js??ref--1-0!/Users/xiangliu/Projects/Web/front-end-notebook/node_modules/vue-loader/lib/index.js??ref--1-1!/Users/xiangliu/Projects/Web/front-end-notebook/node_modules/vuepress/lib/webpack/markdownLoader.js??ref--1-2!/Users/xiangliu/Projects/Web/front-end-notebook/docs/javascript/基础知识/函数.md?vue&type=template&id=200c4b9c","dependencies":[{"path":"/Users/xiangliu/Projects/Web/front-end-notebook/docs/javascript/基础知识/函数.md","mtime":1533330151328},{"path":"/Users/xiangliu/Projects/Web/front-end-notebook/node_modules/cache-loader/dist/cjs.js","mtime":1532111594974},{"path":"/Users/xiangliu/Projects/Web/front-end-notebook/node_modules/vue-loader/lib/loaders/templateLoader.js","mtime":1532111597631},{"path":"/Users/xiangliu/Projects/Web/front-end-notebook/node_modules/cache-loader/dist/cjs.js","mtime":1532111594974},{"path":"/Users/xiangliu/Projects/Web/front-end-notebook/node_modules/vue-loader/lib/index.js","mtime":1532111597630},{"path":"/Users/xiangliu/Projects/Web/front-end-notebook/node_modules/vuepress/lib/webpack/markdownLoader.js","mtime":1532111597717}],"contextDependencies":[],"result":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"content\"},[_vm._ssrNode(\"<h1 id=\\\"函数\\\"><a href=\\\"#函数\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 函数</h1><p>函数可以封装任意多条语句，而且可以在任何地方、任何时候调用执行。函数实际上是对象。每个函数都是 <code>Function</code> 类型的实例. 都与其他引用类型一样具有属性和方法。由于函数是对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。</p><p>定义函数的方式有三种：一种是函数声明，另一种就是函数表达式。还有一种是使用 <code>Function</code> 构造函数</p><p><strong>函数声明</strong>的语法是这样的:</p><p>使用 <code>function</code> 关键字来声明，函数名后跟一组参数以及函数体</p><div class=\\\"language-js extra-class\\\"><pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">function</span> <span class=\\\"token function\\\">functionName</span><span class=\\\"token punctuation\\\">(</span>arg0<span class=\\\"token punctuation\\\">,</span> arg1<span class=\\\"token punctuation\\\">,</span> arg2<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token comment\\\">//函数体</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n</code></pre></div><p>函数声明, 它的一个重要特征就是函数声明提升（function declaration hoisting），意思是在执行代码之前会先读取函数声明。这就意味着可以把函数声明放在调用它的语句后面。</p><p><strong>函数表达式</strong>的语法是这样的:</p><div class=\\\"language-js extra-class\\\"><pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">var</span> <span class=\\\"token function-variable function\\\">functionName</span> <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">function</span><span class=\\\"token punctuation\\\">(</span>arg0<span class=\\\"token punctuation\\\">,</span> arg1<span class=\\\"token punctuation\\\">,</span> arg2<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token comment\\\">//函数体 </span>\\n<span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">;</span>\\n</code></pre></div><p>这种形式看起来好像是常规的变量赋值语句，即创建一个函数并将它赋值给变量。这种情况下创建的函数叫做匿名函数（anonymous function），因为 <code>function</code> 关键字后面没有标识符。</p><p><strong>Function 构造函数</strong> 可以接收任意数量的参数，但最后一个参数始终都被看成是函数体, 前面的参数则枚举出了新函数的参数</p><div class=\\\"language-js extra-class\\\"><pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">var</span> sum <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">Function</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">&quot;num1&quot;</span><span class=\\\"token punctuation\\\">,</span> <span class=\\\"token string\\\">&quot;num2&quot;</span><span class=\\\"token punctuation\\\">,</span> <span class=\\\"token string\\\">&quot;return num1 + num2&quot;</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span> <span class=\\\"token comment\\\">// 不推荐</span>\\n</code></pre></div><h2 id=\\\"内部对象\\\"><a href=\\\"#内部对象\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 内部对象</h2><h3 id=\\\"arguments-对象\\\"><a href=\\\"#arguments-对象\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> arguments 对象</h3><p>函数不介意传递进来多少个参数，也不在乎传进来参数是什么数据类型。ECMAScript 中的参数在内部是用一个数组来表示的。函数接收到的始终都是这个数组，而不关心数组中包含哪些参数, 函数体内可以通过 <code>arguments</code> 对象来访问这个参数数组.</p><p><code>arguments</code> 是对象, 不是 <code>Array</code> 的实例, 但是可以像数组一样用方括号语法访问它的每一个属性, 使用 <code>length</code> 属性来确定传递进来多少个参数</p><p>有点像下面这样:</p><div class=\\\"language-js extra-class\\\"><pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">var</span> arguments <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token string\\\">&quot;0&quot;</span><span class=\\\"token punctuation\\\">:</span> arg0<span class=\\\"token punctuation\\\">,</span>\\n    <span class=\\\"token string\\\">&quot;1&quot;</span><span class=\\\"token punctuation\\\">:</span> arg1<span class=\\\"token punctuation\\\">,</span>\\n    <span class=\\\"token string\\\">&quot;2&quot;</span><span class=\\\"token punctuation\\\">:</span> arg2<span class=\\\"token punctuation\\\">,</span>\\n    <span class=\\\"token operator\\\">...</span>\\n    <span class=\\\"token string\\\">&quot;N-1&quot;</span><span class=\\\"token punctuation\\\">:</span> argN<span class=\\\"token punctuation\\\">,</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n\\nconsole<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span>arguments<span class=\\\"token punctuation\\\">[</span><span class=\\\"token number\\\">2</span><span class=\\\"token punctuation\\\">]</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span> <span class=\\\"token comment\\\">// arg2</span>\\n</code></pre></div><p><code>arguments</code> 的值永远与对应命名参数的值保持同步, <code>arguments</code> 对象中的值会自动反映到对应的命名参数, 修改 <code>arguments\\b</code> 对象属性的值, 也会修改对应的命名参数</p><p><code>arguments</code> 对象还有一个名叫 <code>callee</code> 的属性，该属性是一个指针，指向拥有这个 <code>arguments</code> 对象的函数</p><p>一个经典用法是:</p><div class=\\\"language-js extra-class\\\"><pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">function</span> <span class=\\\"token function\\\">factorial</span><span class=\\\"token punctuation\\\">(</span>num<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>num <span class=\\\"token operator\\\">&lt;=</span><span class=\\\"token number\\\">1</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n        <span class=\\\"token keyword\\\">return</span> <span class=\\\"token number\\\">1</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token punctuation\\\">}</span> <span class=\\\"token keyword\\\">else</span> <span class=\\\"token punctuation\\\">{</span>\\n        <span class=\\\"token keyword\\\">return</span> num <span class=\\\"token operator\\\">*</span> <span class=\\\"token function\\\">factorial</span><span class=\\\"token punctuation\\\">(</span>num<span class=\\\"token operator\\\">-</span><span class=\\\"token number\\\">1</span><span class=\\\"token punctuation\\\">)</span>\\n    <span class=\\\"token punctuation\\\">}</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n</code></pre></div><p>定义阶乘函数一般都要用到递归算法；如上面的代码所示，在函数有名字，而且名字以后也不会变的情况下，这样定义没有问题。但问题是这个函数的执行与函数名 <code>factorial</code> 紧紧耦合在了一起。为了消除这种紧密耦合的现象，可以像下面这样使用 <code>arguments.callee</code>。</p><div class=\\\"language-js extra-class\\\"><pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">function</span> <span class=\\\"token function\\\">factorial</span><span class=\\\"token punctuation\\\">(</span>num<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>num <span class=\\\"token operator\\\">&lt;=</span><span class=\\\"token number\\\">1</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n        <span class=\\\"token keyword\\\">return</span> <span class=\\\"token number\\\">1</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token punctuation\\\">}</span> <span class=\\\"token keyword\\\">else</span> <span class=\\\"token punctuation\\\">{</span>\\n        <span class=\\\"token keyword\\\">return</span> num <span class=\\\"token operator\\\">*</span> arguments<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">callee</span><span class=\\\"token punctuation\\\">(</span>num<span class=\\\"token operator\\\">-</span><span class=\\\"token number\\\">1</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token punctuation\\\">}</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n</code></pre></div><p><code>callee</code> 有一个属性是 <code>caller</code>, 这个属性中保存着调用当前函数的函数的引用, 如果是在全局作用域中调用当前函数，它的值为 <code>null</code>。</p><h3 id=\\\"this\\\"><a href=\\\"#this\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> this</h3><p><code>this</code> 引用的是函数执行的环境对象. 比如, 当在网页的全局作用域中调用函数时，<code>this</code> 对象引用的就是 <code>window</code></p><div class=\\\"language-js extra-class\\\"><pre class=\\\"language-js\\\"><code>window<span class=\\\"token punctuation\\\">.</span>color <span class=\\\"token operator\\\">=</span> <span class=\\\"token string\\\">&quot;red&quot;</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token keyword\\\">var</span> o <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">{</span> color<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token string\\\">&quot;blue&quot;</span> <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">;</span>\\n\\n<span class=\\\"token keyword\\\">function</span> <span class=\\\"token function\\\">sayColor</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token function\\\">alert</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span>color<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n\\n<span class=\\\"token function\\\">sayColor</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>     <span class=\\\"token comment\\\">//&quot;red&quot;</span>\\n\\no<span class=\\\"token punctuation\\\">.</span>sayColor <span class=\\\"token operator\\\">=</span> sayColor<span class=\\\"token punctuation\\\">;</span>\\no<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">sayColor</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>   <span class=\\\"token comment\\\">//&quot;blue&quot;</span>\\n</code></pre></div><h2 id=\\\"没有重载\\\"><a href=\\\"#没有重载\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 没有重载</h2><p>ECMAScript 函数不能像传统意义上那样实现重载, 即为一个函数编写两个定义.</p><p>两个同名函数出现, 后面的覆盖前面的.</p><div class=\\\"language-js extra-class\\\"><pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">function</span> <span class=\\\"token function\\\">addSomeNumber</span><span class=\\\"token punctuation\\\">(</span>num<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">return</span> num <span class=\\\"token operator\\\">+</span> <span class=\\\"token number\\\">100</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n\\n<span class=\\\"token keyword\\\">function</span> <span class=\\\"token function\\\">addSomeNumber</span><span class=\\\"token punctuation\\\">(</span>num<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">return</span> num <span class=\\\"token operator\\\">+</span> <span class=\\\"token number\\\">200</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n\\n<span class=\\\"token keyword\\\">var</span> result <span class=\\\"token operator\\\">=</span> <span class=\\\"token function\\\">addSomeNumber</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token number\\\">100</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span> <span class=\\\"token comment\\\">//300</span>\\n</code></pre></div><p>因为函数名保存的是指向函数对象的\\b指针, 以上代码实际上等价于下面的代码:</p><div class=\\\"language-js extra-class\\\"><pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">var</span> <span class=\\\"token function-variable function\\\">addSomeNumber</span> <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">function</span> <span class=\\\"token punctuation\\\">(</span>num<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">return</span> num <span class=\\\"token operator\\\">+</span> <span class=\\\"token number\\\">100</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">;</span>\\n\\n<span class=\\\"token function-variable function\\\">addSomeNumber</span> <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">function</span> <span class=\\\"token punctuation\\\">(</span>num<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">return</span> num <span class=\\\"token operator\\\">+</span> <span class=\\\"token number\\\">200</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">;</span>\\n\\n<span class=\\\"token keyword\\\">var</span> result <span class=\\\"token operator\\\">=</span> <span class=\\\"token function\\\">addSomeNumber</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token number\\\">100</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span> <span class=\\\"token comment\\\">//300</span>\\n</code></pre></div><p>因为用了相同的函数名, 则指针指向了后者.</p><h2 id=\\\"递归\\\"><a href=\\\"#递归\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 递归</h2><h2 id=\\\"闭包\\\"><a href=\\\"#闭包\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 闭包</h2><h2 id=\\\"模仿块级作用域\\\"><a href=\\\"#模仿块级作用域\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 模仿块级作用域</h2><h2 id=\\\"私有变量\\\"><a href=\\\"#私有变量\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 私有变量</h2>\")])}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }"]}