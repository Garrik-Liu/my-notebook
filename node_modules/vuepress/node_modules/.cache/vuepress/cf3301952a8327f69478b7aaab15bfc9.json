{"remainingRequest":"/Users/xiangliu/Projects/Web/front-end-notebook/node_modules/vue-loader/lib/index.js??ref--1-1!/Users/xiangliu/Projects/Web/front-end-notebook/node_modules/vuepress/lib/webpack/markdownLoader.js??ref--1-2!/Users/xiangliu/Projects/Web/front-end-notebook/docs/个人心得/前端教程/NodeJs/入门篇/模块机制.md?vue&type=template&id=df6cfadc","dependencies":[{"path":"/Users/xiangliu/Projects/Web/front-end-notebook/docs/个人心得/前端教程/NodeJs/入门篇/模块机制.md","mtime":1540542625141},{"path":"/Users/xiangliu/Projects/Web/front-end-notebook/node_modules/cache-loader/dist/cjs.js","mtime":1532111594974},{"path":"/Users/xiangliu/Projects/Web/front-end-notebook/node_modules/vue-loader/lib/loaders/templateLoader.js","mtime":1532111597631},{"path":"/Users/xiangliu/Projects/Web/front-end-notebook/node_modules/cache-loader/dist/cjs.js","mtime":1532111594974},{"path":"/Users/xiangliu/Projects/Web/front-end-notebook/node_modules/vue-loader/lib/index.js","mtime":1532111597630},{"path":"/Users/xiangliu/Projects/Web/front-end-notebook/node_modules/vuepress/lib/webpack/markdownLoader.js","mtime":1532111597717}],"contextDependencies":[],"result":["\n<div class=\"content\"><h1 id=\"模块机制介绍\"><a class=\"header-anchor\" href=\"#模块机制介绍\" aria-hidden=\"true\">#</a> 模块机制介绍</h1>\n<h2 id=\"什么是模块\"><a class=\"header-anchor\" href=\"#什么是模块\" aria-hidden=\"true\">#</a> 什么是模块?</h2>\n<p>以编程角度来说, &quot;模块&quot; 指的是能够提供一定功能或数据的程序语句集合.  模块具备和外部联系的接口 (其他模块或程序调用该模块的方式)</p>\n<p>在 Node.js 中, 每个\b文件就被视为一个模块.  这个文件可能是 JavaScript \b编写的文件、JSON 或者用 C/C++ 编译的二进制文件.  通过对外接口来向外部暴露功能或者数据, 模块之间可以互相调用.</p>\n<h2 id=\"为什么要用模块\"><a class=\"header-anchor\" href=\"#为什么要用模块\" aria-hidden=\"true\">#</a> 为什么要用模块?</h2>\n<h3 id=\"传统开发模式面临的问题\"><a class=\"header-anchor\" href=\"#传统开发模式面临的问题\" aria-hidden=\"true\">#</a> 传统开发模式面临的问题</h3>\n<p>随着开发复杂度的提升, 将代码都写在一处的传统开发方式, 显现出了很多问题:</p>\n<ul>\n<li><strong>很容易出现代码重复</strong>.  开发人员很容易将一个功能的代码重复地写了好多遍.  这导致了如果日后功能需求出现了变更, 就要有多处代码需要被更改.  随着应用规模的增大, 代码会变得难以维护.</li>\n<li><strong>难以确保代码质量</strong>.  所有代码都混在一起, 实现不同功能的代码全都被写在一个文件中, 使得对于单个功能的独立测试变得困难.</li>\n<li><strong>难以查错</strong>.  所有代码都混在一起, 程序运行出现 BUG 了, 很难快速定位.</li>\n<li><strong>性能浪费</strong>.  因为代码都写在一个文件中, 在只调用文件中一段代码的时候, 也会导致整个文件都加载一遍.  这会使很多根本用不到的代码对性能造成浪费.</li>\n<li><strong>难以多人写协作</strong>.  所有代码都放在一个文件中, 使得多人协作变得困难.  开发人员难以确认其他人做了什么修改, 添加了什么东西.  很容易一个人出了错误, 导致整个程序崩溃.</li>\n<li><strong>等等</strong>...</li>\n</ul>\n<h3 id=\"什么是模块化开发\"><a class=\"header-anchor\" href=\"#什么是模块化开发\" aria-hidden=\"true\">#</a> 什么是模块化开发</h3>\n<p>通过使用模块机制, 我们可以把一个复杂程序的各个功能拆分, 分别封装到不同的模块.  每个模块职责单一 (各管一件事, 之间没交集) 通过开发新模块, 和对已有模块的复用来实现各种功能.  这种开发方式被称为 &quot;模块化开发&quot;.</p>\n<h3 id=\"模块化开发的好处\"><a class=\"header-anchor\" href=\"#模块化开发的好处\" aria-hidden=\"true\">#</a> 模块化开发的好处</h3>\n<p>应用模块化\b开发, 使得各个功能都封装在独立的文件中, 分而治之, 互不干扰.  使得代码易于维护和复用.</p>\n<h2 id=\"commonjs\"><a class=\"header-anchor\" href=\"#commonjs\" aria-hidden=\"true\">#</a> CommonJS</h2>\n<p>Node.js 参照 CommonJS 标准实现了模块机制.  CommonJS 是一套代码规范, 目的是为了构建 JavaScript 在浏览器之外的生态系统 (服务器端, 桌面端).  JavaScript 诞生之初只是为了写网页小脚本, 并不作为开发大型复杂应用的语言, 其自身有很多不足.  并且, 官方规范 (ECMAScript) 制定的时间较早, 涵盖范围较小, 对于后端开发而言, 例如文件系统, I/O 流, 模块系统, 等等方面都没有相应的标准.  基于种种的不足, CommonJS 规范致力于弥补 JavaScript 没有标准的缺陷, 让 JavaScript 有能力去开发复杂应用, 同时具备跨平台能力.</p>\n<h2 id=\"示例\"><a class=\"header-anchor\" href=\"#示例\" aria-hidden=\"true\">#</a> 示例</h2>\n<!--beforebegin--><div class=\"language-js extra-class\"><!--afterbegin--><pre v-pre class=\"language-js\"><code><span class=\"token keyword\">const</span> http <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'http'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">myNodeServer</span><span class=\"token punctuation\">(</span>req<span class=\"token punctuation\">,</span> res<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    res<span class=\"token punctuation\">.</span><span class=\"token function\">writeHead</span><span class=\"token punctuation\">(</span><span class=\"token number\">200</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span><span class=\"token string\">'Content-type'</span><span class=\"token punctuation\">:</span><span class=\"token string\">'text/plain'</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    res<span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Hello World'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n    res<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\nhttp<span class=\"token punctuation\">.</span><span class=\"token function\">createServer</span><span class=\"token punctuation\">(</span>myNodeServer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">listen</span><span class=\"token punctuation\">(</span><span class=\"token number\">3000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//监听 3000 端口</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Server is running!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n</code></pre>\n<!--beforeend--></div><!--afterend--><p>上面代码中, 开头通过 <code>require</code> 方法引入了 Node.js 自带的 <code>http</code> 模块.  并用此模块实现了一个 HTTP 服务器.</p>\n<h2 id=\"模块分类\"><a class=\"header-anchor\" href=\"#模块分类\" aria-hidden=\"true\">#</a> 模块分类</h2>\n<p>前文说, 在 Node.js 中, 每个\b文件就被视为一个模块.  这个文件可能是 JavaScript \b编写的文件、JSON 或者用 C/C++ 编译的二进制文件.</p>\n<h3 id=\"核心-原生-模块\"><a class=\"header-anchor\" href=\"#核心-原生-模块\" aria-hidden=\"true\">#</a> 核心(原生)模块</h3>\n<h3 id=\"第三方模块\"><a class=\"header-anchor\" href=\"#第三方模块\" aria-hidden=\"true\">#</a> 第三方模块</h3>\n<h2 id=\"包-npm-包管理器\"><a class=\"header-anchor\" href=\"#包-npm-包管理器\" aria-hidden=\"true\">#</a> 包 &amp; NPM 包管理器</h2>\n<h3 id=\"什么是包\"><a class=\"header-anchor\" href=\"#什么是包\" aria-hidden=\"true\">#</a> 什么是包</h3>\n<h3 id=\"什么是包管理器\"><a class=\"header-anchor\" href=\"#什么是包管理器\" aria-hidden=\"true\">#</a> 什么是包管理器</h3>\n<h2 id=\"使用模块\"><a class=\"header-anchor\" href=\"#使用模块\" aria-hidden=\"true\">#</a> 使用模块</h2>\n<p>在了解了什么是模块之后, 让我们来看看如何在 Node.js 中实际应用模块机制.  在使用上, 可以很简单的分为三个方面: 创建, 导出, 引入.  先创建一个模块, 然后导出功能或数据, 模块之间可以互相引入导出的内容.</p>\n<p>Node.js 提供了 <code>exports</code> 和 <code>require</code> 两个对象，其中 <code>exports</code> 是模块用于导出的接口, <code>require</code> 用于从外部引入另一个模块, 即获取模块的 <code>exports</code> 对象.</p>\n<h3 id=\"创建-导出模块\"><a class=\"header-anchor\" href=\"#创建-导出模块\" aria-hidden=\"true\">#</a> 创建 &amp; 导出模块</h3>\n<p>先让我们来看看如何创建并把模块的内容导出.  在 Node.js 中, 一个文件就是一个模块.  创建模块的方法就是创建一个文件.</p>\n<p>通过 <code>exports</code> 对象来指定一个模块的导出内容.</p>\n<p>示例:</p>\n<!--beforebegin--><div class=\"language-js extra-class\"><!--afterbegin--><pre v-pre class=\"language-js\"><code><span class=\"token comment\">// 文件名: nameModule.js</span>\n<span class=\"token keyword\">var</span> name <span class=\"token operator\">=</span> <span class=\"token string\">'Garrik'</span><span class=\"token punctuation\">;</span>\n\nexports<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">setName</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>newName<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    name <span class=\"token operator\">=</span> newName<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\nexports<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">getName</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> name<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>在以上示例中, nameModule.js 文件通过 <code>exports</code> 对象将 <code>setName</code> 和 <code>getName</code> 作为模块的访问接口.  其他的模块可以引入导出的 <code>exports</code> 对象, 直接访问 <code>exports</code> 对象的成员函数.</p>\n<h3 id=\"module-exports-exports\"><a class=\"header-anchor\" href=\"#module-exports-exports\" aria-hidden=\"true\">#</a> module.exports &amp; exports</h3>\n<p>在使用 <code>exports</code> 对象导出内容时, 所有作为对外访问接口的属性和方法都是定义在 <code>exports</code> 属性上的.  上面的例子中 <code>setName</code> 和 <code>getName</code> 方法都直接定义在 <code>exports</code> 对象上.  那如果想直接导出一个对象, 或者基础类型值可不可以呢?</p>\n<p>可能有人会想可不可以这样写:</p>\n<!--beforebegin--><div class=\"language-js extra-class\"><!--afterbegin--><pre v-pre class=\"language-js\"><code><span class=\"token keyword\">var</span> name <span class=\"token operator\">=</span> <span class=\"token string\">'Garrik'</span><span class=\"token punctuation\">;</span>\n\nexports <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>如果你试一下的话会发现, 最后引入的是一个空对象, 而不是你定义在 <code>exports</code> 上的东西.</p>\n<p>在使用 <code>exports</code> \b的时候只能往这个对象里添加新的属性和方法, 而不能对其直接赋值.  如果想直接导出一个对象, 或者基础类型值要使用 <code>module.exports</code> 对象.  例如上面例子就可以改写成:</p>\n<!--beforebegin--><div class=\"language-js extra-class\"><!--afterbegin--><pre v-pre class=\"language-js\"><code><span class=\"token comment\">// 文件名: nameModule.js</span>\n<span class=\"token keyword\">var</span> name <span class=\"token operator\">=</span> <span class=\"token string\">'Garrik'</span><span class=\"token punctuation\">;</span>\n\nmodule<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  setName<span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>newName<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    name <span class=\"token operator\">=</span> newName<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> \n  getName<span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> name<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span> \n</code></pre>\n<!--beforeend--></div><!--afterend--><p>这样写的话, 就导出了一整个对象, <code>setName</code> 和 <code>getName</code> 方法是这个对象的成员函数.  而不是之前的 <code>exports</code> 对象了.</p>\n<p>除此之外 <code>module.exports</code> 还可以直接导出基础类型值:</p>\n<!--beforebegin--><div class=\"language-js extra-class\"><!--afterbegin--><pre v-pre class=\"language-js\"><code><span class=\"token comment\">// 文件名: numMoule.js</span>\n\n<span class=\"token keyword\">var</span> num <span class=\"token operator\">=</span> <span class=\"token number\">123456</span><span class=\"token punctuation\">;</span>\n\nmodule<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> num<span class=\"token punctuation\">;</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><!--beforebegin--><div class=\"language-js extra-class\"><!--afterbegin--><pre v-pre class=\"language-js\"><code><span class=\"token comment\">// 文件名: showNum.js</span>\n<span class=\"token keyword\">var</span> getNum <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'./numModule.js'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// showNum.js 和 numModule.js 在同一目录下</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>getNum<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 结果: 123456</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>这种方式下, 导出的就直接是基础类型的值.</p>\n<p>可能还是很多人在疑惑 <code>exports</code> 和 <code>module.exports</code> 区别和关系.</p>\n<p>上面我说, 一个文件被另一个模块引入时, 会被做一些处理.  文件中代码并不被 Node 执行, 而是被打包进一个函数中, 然后 Node 执行这个函数.  打包函数会被传入 <code>exports</code>，<code>require</code>，<code>module</code>，<code>__filename</code>，<code>__dirname</code> 这五个参数.  所有的这些参数都在 Node 执行函数时赋值, 并且只在当前的函数作用域中有效.  打包函数执行到最后, 返回 <code>module.exports</code> 对象.</p>\n<p>其中, <code>exports</code> 是 <code>module.exports</code> 的引用, <code>module</code> 对象代表被打包进去的代码本身.  <code>module</code> 的 <code>exports</code> 对象用于指定一个模块的导出内容.</p>\n<p>在模块中定义外部可访问接口的时候, 有两个方法:</p>\n<!--beforebegin--><div class=\"language-js extra-class\"><!--afterbegin--><pre v-pre class=\"language-js\"><code>exports<span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token string\">'Garrik'</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><!--beforebegin--><div class=\"language-js extra-class\"><!--afterbegin--><pre v-pre class=\"language-js\"><code>module<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>name<span class=\"token punctuation\">:</span> <span class=\"token string\">'Garrik'</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>在使用 <code>exports</code> \b的时候只能往这个对象里添加新的属性和方法, 而不能对其直接赋值.  因为直接赋值会打破其对 <code>module.exports</code> 的引用.</p>\n<!--beforebegin--><div class=\"language-js extra-class\"><!--afterbegin--><pre v-pre class=\"language-js\"><code><span class=\"token comment\">// 这是可以的:</span>\nexports<span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token string\">'Garrik'</span><span class=\"token punctuation\">;</span>\nexports<span class=\"token punctuation\">.</span>gender <span class=\"token operator\">=</span> <span class=\"token string\">'Male'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 这是不可以的:</span>\nexports <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>name<span class=\"token punctuation\">:</span> <span class=\"token string\">'Garrik'</span><span class=\"token punctuation\">,</span> gender<span class=\"token punctuation\">:</span> <span class=\"token string\">'Male'</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 应该用 module.exports:</span>\nmodule<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>name<span class=\"token punctuation\">:</span> <span class=\"token string\">'Garrik'</span><span class=\"token punctuation\">,</span> gender<span class=\"token punctuation\">:</span> <span class=\"token string\">'Male'</span><span class=\"token punctuation\">}</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>如果想直接\b导出一个对象, 或基本类型值, \b应该使用 <code>module.exports</code>.</p>\n<!--beforebegin--><div class=\"language-js extra-class\"><!--afterbegin--><pre v-pre class=\"language-js\"><code><span class=\"token comment\">// 导出函数</span>\nmodule<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">exports</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> num <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 导出基本类型值</span>\nmodule<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> <span class=\"token number\">123</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><h3 id=\"require\"><a class=\"header-anchor\" href=\"#require\" aria-hidden=\"true\">#</a> require</h3>\n<p>在 Node.js 中, 通过 <code>require</code> 函数来引入外界模块导出的内容.  <code>require</code> 函数接受一个字符串作为路径参数, 函数根据这个字符串参数来进行模块查找. 找到后会返回目标模块导出的 <code>exports</code> 对象.</p>\n<p>示例:</p>\n<!--beforebegin--><div class=\"language-js extra-class\"><!--afterbegin--><pre v-pre class=\"language-js\"><code><span class=\"token comment\">// 文件名: showNameModule.js</span>\n<span class=\"token keyword\">var</span> nameModule <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'./nameModule.js'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>nameModule<span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n<span class=\"token comment\">// 显示: Garrik</span>\n\nnameModule<span class=\"token punctuation\">.</span><span class=\"token function\">setName</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Xiang'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>nameModule<span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 显示: Xiang</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>上面示例中, 通过 <code>require</code> 引入了当前目录下 nameModule.js 导出的 <code>exports</code> 对象, 并让一个本地变量指向引入模块的 <code>exports</code> 对象.  之后在 showNameModule.js 文件中就可以使用 <code>getName</code> 和 <code>setName</code> 这两个方法了.</p>\n<p>在用 <code>require</code> 引入\b模块时, 路径参数可能有下面\b三种形式:</p>\n<ul>\n<li>相对路径: <code>./</code> 开头 或 <code>../</code> 开头</li>\n<li>绝对路径\b: <code>/</code> 开头</li>\n<li>模块名 (例如: <code>http</code>, <code>fs</code>, <code>url</code>)</li>\n</ul>\n<p>根据参数不同, 加载方式也有区别.</p>\n<h4 id=\"绝对路径-或相对路径\"><a class=\"header-anchor\" href=\"#绝对路径-或相对路径\" aria-hidden=\"true\">#</a> 绝对路径, 或相对路径</h4>\n<p>在指定了模块路径的情况下, Node.js 会去指定的位置加载模块.  但因为用 <code>require</code> 来加载模块时可以省略文件后缀, 在省略的情况下, Node.js 会去猜测文件的类型.</p>\n<p>比方说我要去  <code>./modules/</code> 目录下加载一个 <code>haha</code> 模块.</p>\n<!--beforebegin--><div class=\"language-js extra-class\"><!--afterbegin--><pre v-pre class=\"language-js\"><code><span class=\"token keyword\">var</span> haha <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'./modules/haha'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>因为 <code>haha</code> 没写文件后缀, Node.js 将执行的操作顺序为:</p>\n<ul>\n<li>按 js 文件来执行（先找对应路径当中是否有 haha.js 文件\b, 有就加载）</li>\n<li>按 json 文件来解析（若上面的 js 文件找不到时，则找对应路径当中的 haha.json 文件来加载）</li>\n<li>按照预编译好的 C++ 模块来执行（还没有, 寻找对应路径当中的 haha.node 文件来加载）</li>\n<li>若参数字符串为一个目录的路径, 就是说 <code>haha</code> 为一个目录, 则先查找该文件夹下的 package.json 文件，然后再加载该文件当中 <code>main</code> 字段所指定的入口文件.  若 package.json 文件当中没有 <code>main</code> 字段，或者根本没有 package.json 文件，则再默认查找该文件夹下的 index.js 文件, 并作为模块来载入.</li>\n<li>要是还没有就拉倒吧!</li>\n</ul>\n<h4 id=\"无路径-直接模块名\"><a class=\"header-anchor\" href=\"#无路径-直接模块名\" aria-hidden=\"true\">#</a> 无路径, 直接模块名:</h4>\n<p>在没有路径, 参数值直接为一个模块名的情况下:</p>\n<!--beforebegin--><div class=\"language-js extra-class\"><!--afterbegin--><pre v-pre class=\"language-js\"><code><span class=\"token keyword\">var</span> haha <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'haha'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><ul>\n<li>如果 <code>haha</code> 是 Node.js 核心模块就直接加载.</li>\n<li>如果是第三方模块, 则依次从当前目录中的 node_modules 目录, 父级目录中的 node_modules 目录, 一直到根目录下的 node_modules 目录下去查找 <code>haha</code> 的所在.  若有两个同名文件，则遵循就近原则。优先引入目录顺序靠前的模块.</li>\n<li>如果找到的 <code>haha</code> 为一个目录, 则先查找该文件夹下的 package.json 文件，然后再加载该文件当中 <code>main</code> 字段所指定的入口文件.  若 package.json 文件当中没有 <code>main</code> 字段，或者根本没有 package.json 文件，则再默认查找该文件夹下的 index.js 文件, 并作为模块来载入.</li>\n</ul>\n</div>\n",null]}