{"remainingRequest":"/Users/xiangliu/Projects/Web/front-end-notebook/node_modules/vue-loader/lib/index.js??ref--1-1!/Users/xiangliu/Projects/Web/front-end-notebook/node_modules/vuepress/lib/webpack/markdownLoader.js??ref--1-2!/Users/xiangliu/Projects/Web/front-end-notebook/docs/javascript/基础知识/函数.md?vue&type=template&id=200c4b9c","dependencies":[{"path":"/Users/xiangliu/Projects/Web/front-end-notebook/docs/javascript/基础知识/函数.md","mtime":1533330151328},{"path":"/Users/xiangliu/Projects/Web/front-end-notebook/node_modules/cache-loader/dist/cjs.js","mtime":1532111594974},{"path":"/Users/xiangliu/Projects/Web/front-end-notebook/node_modules/vue-loader/lib/loaders/templateLoader.js","mtime":1532111597631},{"path":"/Users/xiangliu/Projects/Web/front-end-notebook/node_modules/cache-loader/dist/cjs.js","mtime":1532111594974},{"path":"/Users/xiangliu/Projects/Web/front-end-notebook/node_modules/vue-loader/lib/index.js","mtime":1532111597630},{"path":"/Users/xiangliu/Projects/Web/front-end-notebook/node_modules/vuepress/lib/webpack/markdownLoader.js","mtime":1532111597717}],"contextDependencies":[],"result":["\n<div class=\"content\"><h1 id=\"函数\"><a class=\"header-anchor\" href=\"#函数\" aria-hidden=\"true\">#</a> 函数</h1>\n<p>函数可以封装任意多条语句，而且可以在任何地方、任何时候调用执行。函数实际上是对象。每个函数都是 <code>Function</code> 类型的实例. 都与其他引用类型一样具有属性和方法。由于函数是对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。</p>\n<p>定义函数的方式有三种：一种是函数声明，另一种就是函数表达式。还有一种是使用 <code>Function</code> 构造函数</p>\n<p><strong>函数声明</strong>的语法是这样的:</p>\n<p>使用 <code>function</code> 关键字来声明，函数名后跟一组参数以及函数体</p>\n<!--beforebegin--><div class=\"language-js extra-class\"><!--afterbegin--><pre v-pre class=\"language-js\"><code><span class=\"token keyword\">function</span> <span class=\"token function\">functionName</span><span class=\"token punctuation\">(</span>arg0<span class=\"token punctuation\">,</span> arg1<span class=\"token punctuation\">,</span> arg2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">//函数体</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>函数声明, 它的一个重要特征就是函数声明提升（function declaration hoisting），意思是在执行代码之前会先读取函数声明。这就意味着可以把函数声明放在调用它的语句后面。</p>\n<p><strong>函数表达式</strong>的语法是这样的:</p>\n<!--beforebegin--><div class=\"language-js extra-class\"><!--afterbegin--><pre v-pre class=\"language-js\"><code><span class=\"token keyword\">var</span> <span class=\"token function-variable function\">functionName</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>arg0<span class=\"token punctuation\">,</span> arg1<span class=\"token punctuation\">,</span> arg2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">//函数体 </span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>这种形式看起来好像是常规的变量赋值语句，即创建一个函数并将它赋值给变量。这种情况下创建的函数叫做匿名函数（anonymous function），因为 <code>function</code> 关键字后面没有标识符。</p>\n<p><strong>Function 构造函数</strong> 可以接收任意数量的参数，但最后一个参数始终都被看成是函数体, 前面的参数则枚举出了新函数的参数</p>\n<!--beforebegin--><div class=\"language-js extra-class\"><!--afterbegin--><pre v-pre class=\"language-js\"><code><span class=\"token keyword\">var</span> sum <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Function</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"num1\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"num2\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"return num1 + num2\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 不推荐</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><h2 id=\"内部对象\"><a class=\"header-anchor\" href=\"#内部对象\" aria-hidden=\"true\">#</a> 内部对象</h2>\n<h3 id=\"arguments-对象\"><a class=\"header-anchor\" href=\"#arguments-对象\" aria-hidden=\"true\">#</a> arguments 对象</h3>\n<p>函数不介意传递进来多少个参数，也不在乎传进来参数是什么数据类型。ECMAScript 中的参数在内部是用一个数组来表示的。函数接收到的始终都是这个数组，而不关心数组中包含哪些参数, 函数体内可以通过 <code>arguments</code> 对象来访问这个参数数组.</p>\n<p><code>arguments</code> 是对象, 不是 <code>Array</code> 的实例, 但是可以像数组一样用方括号语法访问它的每一个属性, 使用 <code>length</code> 属性来确定传递进来多少个参数</p>\n<p>有点像下面这样:</p>\n<!--beforebegin--><div class=\"language-js extra-class\"><!--afterbegin--><pre v-pre class=\"language-js\"><code><span class=\"token keyword\">var</span> arguments <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token string\">\"0\"</span><span class=\"token punctuation\">:</span> arg0<span class=\"token punctuation\">,</span>\n    <span class=\"token string\">\"1\"</span><span class=\"token punctuation\">:</span> arg1<span class=\"token punctuation\">,</span>\n    <span class=\"token string\">\"2\"</span><span class=\"token punctuation\">:</span> arg2<span class=\"token punctuation\">,</span>\n    <span class=\"token operator\">...</span>\n    <span class=\"token string\">\"N-1\"</span><span class=\"token punctuation\">:</span> argN<span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>arguments<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// arg2</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><p><code>arguments</code> 的值永远与对应命名参数的值保持同步, <code>arguments</code> 对象中的值会自动反映到对应的命名参数, 修改 <code>arguments\b</code> 对象属性的值, 也会修改对应的命名参数</p>\n<p><code>arguments</code> 对象还有一个名叫 <code>callee</code> 的属性，该属性是一个指针，指向拥有这个 <code>arguments</code> 对象的函数</p>\n<p>一个经典用法是:</p>\n<!--beforebegin--><div class=\"language-js extra-class\"><!--afterbegin--><pre v-pre class=\"language-js\"><code><span class=\"token keyword\">function</span> <span class=\"token function\">factorial</span><span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>num <span class=\"token operator\">&lt;=</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> num <span class=\"token operator\">*</span> <span class=\"token function\">factorial</span><span class=\"token punctuation\">(</span>num<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>定义阶乘函数一般都要用到递归算法；如上面的代码所示，在函数有名字，而且名字以后也不会变的情况下，这样定义没有问题。但问题是这个函数的执行与函数名 <code>factorial</code> 紧紧耦合在了一起。为了消除这种紧密耦合的现象，可以像下面这样使用 <code>arguments.callee</code>。</p>\n<!--beforebegin--><div class=\"language-js extra-class\"><!--afterbegin--><pre v-pre class=\"language-js\"><code><span class=\"token keyword\">function</span> <span class=\"token function\">factorial</span><span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>num <span class=\"token operator\">&lt;=</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> num <span class=\"token operator\">*</span> arguments<span class=\"token punctuation\">.</span><span class=\"token function\">callee</span><span class=\"token punctuation\">(</span>num<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><p><code>callee</code> 有一个属性是 <code>caller</code>, 这个属性中保存着调用当前函数的函数的引用, 如果是在全局作用域中调用当前函数，它的值为 <code>null</code>。</p>\n<h3 id=\"this\"><a class=\"header-anchor\" href=\"#this\" aria-hidden=\"true\">#</a> this</h3>\n<p><code>this</code> 引用的是函数执行的环境对象. 比如, 当在网页的全局作用域中调用函数时，<code>this</code> 对象引用的就是 <code>window</code></p>\n<!--beforebegin--><div class=\"language-js extra-class\"><!--afterbegin--><pre v-pre class=\"language-js\"><code>window<span class=\"token punctuation\">.</span>color <span class=\"token operator\">=</span> <span class=\"token string\">\"red\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> o <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> color<span class=\"token punctuation\">:</span> <span class=\"token string\">\"blue\"</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">sayColor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>color<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">sayColor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>     <span class=\"token comment\">//\"red\"</span>\n\no<span class=\"token punctuation\">.</span>sayColor <span class=\"token operator\">=</span> sayColor<span class=\"token punctuation\">;</span>\no<span class=\"token punctuation\">.</span><span class=\"token function\">sayColor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">//\"blue\"</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><h2 id=\"没有重载\"><a class=\"header-anchor\" href=\"#没有重载\" aria-hidden=\"true\">#</a> 没有重载</h2>\n<p>ECMAScript 函数不能像传统意义上那样实现重载, 即为一个函数编写两个定义.</p>\n<p>两个同名函数出现, 后面的覆盖前面的.</p>\n<!--beforebegin--><div class=\"language-js extra-class\"><!--afterbegin--><pre v-pre class=\"language-js\"><code><span class=\"token keyword\">function</span> <span class=\"token function\">addSomeNumber</span><span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> num <span class=\"token operator\">+</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">addSomeNumber</span><span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> num <span class=\"token operator\">+</span> <span class=\"token number\">200</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> result <span class=\"token operator\">=</span> <span class=\"token function\">addSomeNumber</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//300</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>因为函数名保存的是指向函数对象的\b指针, 以上代码实际上等价于下面的代码:</p>\n<!--beforebegin--><div class=\"language-js extra-class\"><!--afterbegin--><pre v-pre class=\"language-js\"><code><span class=\"token keyword\">var</span> <span class=\"token function-variable function\">addSomeNumber</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> num <span class=\"token operator\">+</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function-variable function\">addSomeNumber</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> num <span class=\"token operator\">+</span> <span class=\"token number\">200</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">var</span> result <span class=\"token operator\">=</span> <span class=\"token function\">addSomeNumber</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//300</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>因为用了相同的函数名, 则指针指向了后者.</p>\n<h2 id=\"递归\"><a class=\"header-anchor\" href=\"#递归\" aria-hidden=\"true\">#</a> 递归</h2>\n<h2 id=\"闭包\"><a class=\"header-anchor\" href=\"#闭包\" aria-hidden=\"true\">#</a> 闭包</h2>\n<h2 id=\"模仿块级作用域\"><a class=\"header-anchor\" href=\"#模仿块级作用域\" aria-hidden=\"true\">#</a> 模仿块级作用域</h2>\n<h2 id=\"私有变量\"><a class=\"header-anchor\" href=\"#私有变量\" aria-hidden=\"true\">#</a> 私有变量</h2>\n</div>\n",null]}