{"remainingRequest":"/Users/xiangliu/Projects/Web/front-end-notebook/node_modules/vue-loader/lib/index.js??ref--1-1!/Users/xiangliu/Projects/Web/front-end-notebook/node_modules/vuepress/lib/webpack/markdownLoader.js??ref--1-2!/Users/xiangliu/Projects/Web/front-end-notebook/docs/前端开发/javascript/深入探讨/this.md?vue&type=template&id=d26a361e","dependencies":[{"path":"/Users/xiangliu/Projects/Web/front-end-notebook/docs/前端开发/javascript/深入探讨/this.md","mtime":1546199025732},{"path":"/Users/xiangliu/Projects/Web/front-end-notebook/node_modules/cache-loader/dist/cjs.js","mtime":1532111594974},{"path":"/Users/xiangliu/Projects/Web/front-end-notebook/node_modules/vue-loader/lib/loaders/templateLoader.js","mtime":1532111597631},{"path":"/Users/xiangliu/Projects/Web/front-end-notebook/node_modules/cache-loader/dist/cjs.js","mtime":1532111594974},{"path":"/Users/xiangliu/Projects/Web/front-end-notebook/node_modules/vue-loader/lib/index.js","mtime":1532111597630},{"path":"/Users/xiangliu/Projects/Web/front-end-notebook/node_modules/vuepress/lib/webpack/markdownLoader.js","mtime":1532111597717}],"contextDependencies":[],"result":["\n<div class=\"content\"><h1 id=\"this\"><a class=\"header-anchor\" href=\"#this\" aria-hidden=\"true\">#</a> this</h1>\n<p>在 Java 等面向对象的语言中，<code>this</code> 关键字的含义是明确且具体的，即指代当前对象。一般在编译期确定下来，或称为编译期绑定。而在 JavaScript 中，<code>this</code> 是<strong>动态绑定</strong>，或称为运行期绑定的.</p>\n<p>先来看一下 <code>this</code> 的使用例子:</p>\n<!--beforebegin--><div class=\"language-js extra-class\"><!--afterbegin--><pre v-pre class=\"language-js\"><code><span class=\"token keyword\">function</span> <span class=\"token function\">identify</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> \n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span> <span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">.</span><span class=\"token function\">toUpperCase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">speak</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> \n    <span class=\"token keyword\">var</span> greeting <span class=\"token operator\">=</span> <span class=\"token string\">\"Hello, I'm \"</span> <span class=\"token operator\">+</span> identify<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span> <span class=\"token keyword\">this</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span> greeting <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> me <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> \n    name<span class=\"token punctuation\">:</span> <span class=\"token string\">\"Kyle\"</span> \n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">var</span> you <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> \n    name<span class=\"token punctuation\">:</span> <span class=\"token string\">\"Reader\"</span> \n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\nidentify<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span> me <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// KYLE </span>\nidentify<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span> you <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// READER</span>\n\nspeak<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span> me <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Hello, 我是 KYLE </span>\nspeak<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span> you <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Hello, 我是 READER</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>因为使用了 <code>this</code> 这段代码可以在不同的上下文对象（ <code>me</code> 和 <code>you</code> ）中重复使用函数 <code>identify()</code> 和 <code>speak()</code></p>\n<p>如果不使用 <code>this</code> ，那就需要给 <code>identify()</code> 和 <code>speak()</code> 显式传入一个上下文对象。</p>\n<!--beforebegin--><div class=\"language-js extra-class\"><!--afterbegin--><pre v-pre class=\"language-js\"><code><span class=\"token keyword\">function</span> <span class=\"token function\">identify</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> \n    <span class=\"token keyword\">return</span> context<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">.</span><span class=\"token function\">toUpperCase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">speak</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> \n    <span class=\"token keyword\">var</span> greeting <span class=\"token operator\">=</span> <span class=\"token string\">\"Hello, I'm \"</span> <span class=\"token operator\">+</span> <span class=\"token function\">identify</span><span class=\"token punctuation\">(</span> context <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span> greeting <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">identify</span><span class=\"token punctuation\">(</span> you <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// READER </span>\n<span class=\"token function\">speak</span><span class=\"token punctuation\">(</span> me <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//hello, 我是 KYLE</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><p><code>this</code> 提供了一种更优雅的方式来<strong>隐式 “传递” 一个对象引用</strong>，因此可以将 API 设计得更加简洁并且易于复用。</p>\n<h2 id=\"绑定规则\"><a class=\"header-anchor\" href=\"#绑定规则\" aria-hidden=\"true\">#</a> 绑定规则</h2>\n<h3 id=\"调用位置\"><a class=\"header-anchor\" href=\"#调用位置\" aria-hidden=\"true\">#</a> 调用位置</h3>\n<p>在理解 this 的绑定过程之前，首先要理解 &quot;调用位置&quot; 这个概念: <strong>&quot;调用位置&quot; 就是函数在代码中被调用的位置（而不是声明的位置）</strong>。</p>\n<p>寻到 &quot;调用位置&quot; 的方法就是分析 &quot;调用栈&quot;（就是为了到达当前执行位置所调用的所有函数）。我们关心的调用位置就在当前正在执行的函数的前一个调用中 。</p>\n<!--beforebegin--><div class=\"language-js extra-class\"><!--afterbegin--><pre v-pre class=\"language-js\"><code><span class=\"token comment\">// b() 函数被调用时, </span>\n<span class=\"token comment\">// 调用栈为 a() -> b(), </span>\n<span class=\"token comment\">// 调用位置在 a()</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">a</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">b</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">b</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'HAHA'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><p><strong>在函数的执行过程中调用位置决定了 <code>this</code> 的绑定对象。根据情况的不同, 具体可以分为下面四种规则: 默认绑定, 隐示绑定, 显示绑定, new 绑定.</strong></p>\n<h3 id=\"默认绑定\"><a class=\"header-anchor\" href=\"#默认绑定\" aria-hidden=\"true\">#</a> 默认绑定</h3>\n<p>独立函数调用。可以把这条规则看作是无法应用其他规则时的默认规则。</p>\n<!--beforebegin--><div class=\"language-js extra-class\"><!--afterbegin--><pre v-pre class=\"language-js\"><code><span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token number\">123</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 123</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>声明在全局作用域中的变量（比如 <code>var a = 123</code> ）就是全局对象的一个同名属性。在代码中， <code>foo()</code> 是直接使用不带任何修饰的函数引用进行调用的.  函数调用时应用了 <code>this</code> 的默认绑定 ，因此 <code>this</code> 指向全局对象。</p>\n<div class=\"warning custom-block\"><p class=\"custom-block-title\">WARNING</p>\n<p>如果使用严格模式（ strict mode ），那么全局对象将无法使用默认绑定，因此 <code>this</code> 会绑定到 <code>undefined</code></p>\n<p>对于默认绑定来说，决定 1 绑定对象的并不是调用位置是否处于严格模式，而是函数体是否处于严格模式。</p>\n</div>\n<h3 id=\"隐示绑定\"><a class=\"header-anchor\" href=\"#隐示绑定\" aria-hidden=\"true\">#</a> 隐示绑定</h3>\n<p>调用位置是否有上下文对象，或者说函数调用时, 是否被某个对象拥有或者包含.</p>\n<!--beforebegin--><div class=\"language-js extra-class\"><!--afterbegin--><pre v-pre class=\"language-js\"><code><span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    a<span class=\"token punctuation\">:</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span>\n    foo<span class=\"token punctuation\">:</span> foo\n<span class=\"token punctuation\">}</span>\n\nobj<span class=\"token punctuation\">.</span><span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 2</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><p><code>foo()</code> 在 <code>obj</code> 对象的上下文中被调用. 隐式绑定规则会把函数调用中的 <code>this</code> 绑定到这个上下文对象。</p>\n<h4 id=\"隐式丢失\"><a class=\"header-anchor\" href=\"#隐式丢失\" aria-hidden=\"true\">#</a> 隐式丢失</h4>\n<p>一个最常见的 <code>this</code> 绑定问题就是被隐式绑定的函数会丢失绑定对象.  也就是说它会应用默认绑定, 从而把 <code>this</code> 绑定到全局对象或者 <code>undefined</code> 上</p>\n<!--beforebegin--><div class=\"language-js extra-class\"><!--afterbegin--><pre v-pre class=\"language-js\"><code><span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    a<span class=\"token punctuation\">:</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span>\n    foo<span class=\"token punctuation\">:</span> foo\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> x <span class=\"token operator\">=</span> obj<span class=\"token punctuation\">.</span>foo<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token number\">1234</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">x</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//1234</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>虽然 <code>x</code> 是 <code>obj.foo</code> 的一个引用， 但是实际上，它引用的是 <code>foo</code> 函数本身，因此此时的 <code>x()</code> 其实是一个不带任何修饰的函数调用，因此应用了默认绑定。</p>\n<p>一个更容易让人注意不到的情况发生在将函数作为参数传递时.  参数传递其实就是一种隐式赋值, 传递的是引用.</p>\n<!--beforebegin--><div class=\"language-js extra-class\"><!--afterbegin--><pre v-pre class=\"language-js\"><code><span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    a<span class=\"token punctuation\">:</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span>\n    foo<span class=\"token punctuation\">:</span> foo\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token number\">1234</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">doFun</span><span class=\"token punctuation\">(</span>fn<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">doFun</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">.</span>foo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//1234</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><h3 id=\"显示绑定\"><a class=\"header-anchor\" href=\"#显示绑定\" aria-hidden=\"true\">#</a> 显示绑定</h3>\n<p>使用函数的 <code>call(..)</code> 和 <code>apply(..)</code> 方法可以直接指定 <code>this</code> 的绑定对象， 因此我们称之为显式绑定。</p>\n<!--beforebegin--><div class=\"language-js extra-class\"><!--afterbegin--><pre v-pre class=\"language-js\"><code><span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    a<span class=\"token punctuation\">:</span> <span class=\"token number\">2</span>\n<span class=\"token punctuation\">}</span>\n\nfoo<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 2</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><h3 id=\"new-绑定\"><a class=\"header-anchor\" href=\"#new-绑定\" aria-hidden=\"true\">#</a> new 绑定</h3>\n<p>在 JavaScript 中， 构造函数只是一些 使用 <code>new</code> 操作符时被调用的函数。它们并不会属于某个类，也不会实例化一个类。它们只是被 <code>new</code> 操作符调用的普通函数而已。</p>\n<p>使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作:</p>\n<ol>\n<li>创建（或者说构造）一个全新的对象。</li>\n<li>这个新对象会被执行 [[ prototype ]] 连接。</li>\n<li>函数调用时 this 绑定到新对象上。</li>\n<li>如果函数没有返回其他对象，new 表达式中的函数调用会自动返回这个新对象</li>\n</ol>\n<h2 id=\"优先级\"><a class=\"header-anchor\" href=\"#优先级\" aria-hidden=\"true\">#</a> 优先级</h2>\n<p>可以根据优先级来判断函数在某个调用位置应用的是哪条规则。可以按照下面的顺序来进行判断：</p>\n<ol>\n<li>函数是否在 <code>new</code> 中调用（ <code>new</code> 绑定）？如果是的话 <code>this</code> 绑定的是新创建的新对象。</li>\n<li>函数是否通过指定的对象。<code>call</code>, <code>apply</code>（显式绑定) 如果是的话，<code>this</code> 绑定的是指定的对象.</li>\n<li>函数是否在某个上下文对象中调用（隐式绑定）？如果是的话， <code>this</code> 绑定的是那个上下文对象。</li>\n<li>如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到 undefined ，否则绑定到全局对象。</li>\n</ol>\n<div class=\"warning custom-block\"><p class=\"custom-block-title\">WARNING</p>\n<p>如果你把 <code>null</code> 或者 <code>undefined</code> 作为 <code>this</code> 的绑定对象传入 <code>call</code>、 <code>apply</code> 或者 <code>bind</code>， 这些值在调用时会被忽略，实际应用的是默认绑定规则</p>\n</div>\n<h2 id=\"箭头函数\"><a class=\"header-anchor\" href=\"#箭头函数\" aria-hidden=\"true\">#</a> 箭头函数</h2>\n<p>箭头函数不使用 this 的四种标准规则，而是根据外层（函数或者全局）作用域来决 定 this 。</p>\n<p>箭头函数可以像 <code>bind(..)</code> 一样确保函数的 <code>this</code> 被绑定到指定对象，此外，其重要性还体现在它用更常见的词法作用域取代了传统的 <code>this</code> 机制。箭头函数最常用于回调函数中</p>\n<!--beforebegin--><div class=\"language-js extra-class\"><!--afterbegin--><pre v-pre class=\"language-js\"><code><span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    a<span class=\"token punctuation\">:</span> <span class=\"token number\">2</span>\n<span class=\"token punctuation\">}</span>\n\nfoo<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 2</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><p><code>foo()</code> 内部创建的箭头函数会捕获调用时 <code>foo()</code> 的 <code>this</code> 。</p>\n<h2 id=\"误解\"><a class=\"header-anchor\" href=\"#误解\" aria-hidden=\"true\">#</a> 误解</h2>\n<h3 id=\"指向自身-错误\"><a class=\"header-anchor\" href=\"#指向自身-错误\" aria-hidden=\"true\">#</a> 指向自身 (错误)</h3>\n<p>有的人把 <code>this</code> 理解成指向函数自身. 错误的书写了类似于下面的代码:</p>\n<!--beforebegin--><div class=\"language-js extra-class\"><!--afterbegin--><pre v-pre class=\"language-js\"><code><span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">}</span>\n\nfoo<span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token string\">'FOO'</span>\n\n<span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// undefined</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>如果真的想指向函数自身的话, 可以有下面几种写法:</p>\n<h4 id=\"直接用函数名\"><a class=\"header-anchor\" href=\"#直接用函数名\" aria-hidden=\"true\">#</a> 直接用函数名</h4>\n<!--beforebegin--><div class=\"language-js extra-class\"><!--afterbegin--><pre v-pre class=\"language-js\"><code><span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>foo<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">}</span>\n\nfoo<span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token string\">'FOO'</span>\n\n<span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// undefined</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><h4 id=\"使用-arguments-callee\"><a class=\"header-anchor\" href=\"#使用-arguments-callee\" aria-hidden=\"true\">#</a> 使用 <code>arguments.callee</code></h4>\n<p>这是一种传统的但是现在已经被弃用和批判的用法.  这是唯一一种可以从匿名函数对象 内部引用自身的方法。然而，更好的方式是避免使用匿名函数</p>\n<!--beforebegin--><div class=\"language-js extra-class\"><!--afterbegin--><pre v-pre class=\"language-js\"><code><span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>arguments<span class=\"token punctuation\">.</span>callee<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">}</span>\n\nfoo<span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token string\">'FOO'</span>\n\n<span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// undefined</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><h4 id=\"使用-call\"><a class=\"header-anchor\" href=\"#使用-call\" aria-hidden=\"true\">#</a> 使用 <code>call(..)</code></h4>\n<!--beforebegin--><div class=\"language-js extra-class\"><!--afterbegin--><pre v-pre class=\"language-js\"><code><span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">}</span>\n\nfoo<span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token string\">'FOO'</span>\n\nfoo<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>foo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// undefined</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><h3 id=\"指向函数所属的作用域-错误\"><a class=\"header-anchor\" href=\"#指向函数所属的作用域-错误\" aria-hidden=\"true\">#</a> 指向函数所属的作用域 (错误)</h3>\n<p>第二种常见的误解是， <code>this</code> 指向函数的作用域。需要明确的是，<strong><code>this</code> 在任何情况下都不指向函数的词法作用域。</strong></p>\n<!--beforebegin--><div class=\"language-js extra-class\"><!--afterbegin--><pre v-pre class=\"language-js\"><code><span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> \n    <span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">this</span> <span class=\"token punctuation\">.</span><span class=\"token function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> \n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>a <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ReferenceError: a is not defined</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>首先，这段代码试图通过 <code>this.bar()</code> 来引用 <code>bar()</code> 函数。这是绝对不可能成功的.  调用 <code>bar()</code> 最自然的方法是省略前面的 <code>this</code> ，直接使用词法引用标识符。此外，编写这段代码的开发者还试图使用 <code>this</code> 联通 <code>foo()</code> 和 <code>bar()</code> 的词法作用域，从而让 <code>bar()</code> 可以访问 <code>foo()</code> 作用域里的变量 <code>a</code> 。 这是不可能实现的</p>\n</div>\n",null]}