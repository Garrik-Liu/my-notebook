{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{155:function(t,a,r){\"use strict\";r.r(a);var e=r(0),s=Object(e.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,a=t.$createElement,r=t._self._c||a;return r(\"div\",{staticClass:\"content\"},[r(\"h1\",{attrs:{id:\"基础知识\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#基础知识\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 基础知识\")]),r(\"h2\",{attrs:{id:\"基础概念\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#基础概念\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 基础概念\")]),r(\"p\",[t._v(\"Node.js 是一个使用\"),r(\"strong\",[t._v(\"单线程, 事件驱动、非阻塞式 I/O\")]),t._v(\" 的模型, 基于 \"),r(\"strong\",[t._v(\"Chrome V8 引擎\")]),t._v(\"的 \"),r(\"strong\",[t._v(\"JavaScript 运行环境\")]),t._v(\"。\\b允许 J\\bs 可以\\b脱离浏览器去执行.\")]),r(\"blockquote\",[r(\"p\",[t._v(\"要实现在后台运行 JavaScript 代码，代码需要先被解释然后正确的执行。Node.js 的原理正是如此，它使用了 Google 的 V8 虚拟机（ Google 的 Chrome 浏览器使用的 JavaScript 执行环境，来解释和执行 JavaScript 代码。\")])]),r(\"h3\",{attrs:{id:\"非阻塞-i-o-和-事件驱动\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#非阻塞-i-o-和-事件驱动\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 非阻塞 I/O 和 事件驱动\")]),r(\"p\",[t._v(\"Node.js 最大的特点就是应用 非阻塞 I/O 与 事件驱动的编程模式。\")]),r(\"h4\",{attrs:{id:\"什么是阻塞\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#什么是阻塞\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 什么是阻塞?\")]),r(\"p\",[t._v(\"在说非阻塞\\b之前, 先了解什么是阻塞.\\n线程在执行中如果遇到磁盘读写或网络通信(统称为 I/O 操作)， 通常要耗费较长的时间.  这时候操作系统会剥夺这个线程的 CPU 控制权，使其暂停执行，同时将资源让给其他的工作线程，这种线程调度方式称为阻塞。\\n当 I/O 操作完毕时，操作系统 将这个线程的阻塞状态解除，恢复其对CPU的控制权，令其继续执行。这种 I/O 模式就是通常的 \"),r(\"strong\",[t._v(\"阻塞式 I/O\")])]),r(\"p\",[t._v(\"相应地，异步式 I/O 则针对 所有 I/O 操作不采用阻塞的策略。当线程遇到 I/O 操作时，不会以阻塞的方式等待 I/O 操作 的完成或数据的返回. 而只是将 I/O 请求发送给操作系统，继续执行下一条语句。\\n当操作 系统完成 I/O 操作时，以事件的形式通知执行 I/O 操作的线程，线程会在特定时候处理这个 事件。为了处理异步 I/O，线程必须有事件循环，不断地检查有没有未处理的事件，依次予以处理。这种 I/O 模式就是通常的 \"),r(\"strong\",[t._v(\"非阻塞式 I/O\")])]),r(\"p\",[t._v(\"因为采用了非阻塞, 个线程永远在执行计算操作，这个线程所使用的 CPU 核心利用率几近是 100%，可以提高服务器的利用率, 提高系统吞吐量.\")]),r(\"p\",[t._v(\"假设我们有一项工作，可以分为两个计算部分和一个 I/O 部分，I/O 部分占的时间比计算多得多。如果我们使用阻塞 I/O，那么要想获得高并发就必须开启多个线程。而使用异步式 I/O 时，单线程即可胜任。\")]),r(\"p\",[r(\"img\",{attrs:{src:\"https://i.imgur.com/SW5NWqi.png\",alt:\"Screen Shot 2018-07-12 at 4.37.15 PM\"}})]),r(\"p\",[r(\"img\",{attrs:{src:\"https://i.imgur.com/FAfPumU.png\",alt:\"Screen Shot 2018-07-12 at 4.37.22 PM\"}})])])}],!1,null,null,null);a.default=s.exports}}]);","extractedComments":[]}