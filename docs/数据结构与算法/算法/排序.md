# 排序

我按照时间复杂度把它们分成了三类

![fb8394a588b12ff6695cfd664afb17cd](https://i.imgur.com/2FE1uTS.jpg)


## 如何分析一个“排序算法”？

### 排序算法的执行效率 
对于排序算法执行效率的分析，我们一般会从这几个方面来衡量：

1. **最好情况、最坏情况、平均情况时间复杂度**

在分析排序算法的时间复杂度时，要分别给出最好情况、最坏情况、平均情况下的时间复杂度。

除此之外，你还要说出最好、最坏时间复杂度对应的要排序的原始数据是什么样的。我们要知道排序算法在不同数据下的性能表现。

2. **时间复杂度的系数、常数 、低阶**

时间复杂度反应的是数据规模 n 很大的时候的一个**增长趋势**，所以它表示的时候会忽略系数、常数、低阶。

实际的软件开发中，我们排序的可能是 10 个、100 个、1000 个这样规模很小的数据，所以，在对**同一阶时间复杂度**的排序算法性能对比的时候，我们就要把**系数、常数、低阶**也考虑进来。

3. **比较次数和交换（或移动）次数**

基于比较的排序算法的执行过程，会涉及两种操作:

* 元素比较大小，
* 元素交换或移动

所以，如果我们在分析排序算法的执行效率的时候，应该把比较次数和交换（或移动）次数也考虑进去。

### 排序算法的内存消耗

算法的内存消耗可以通过空间复杂度来衡量. 针对排序算法的空间复杂度，我们还引入了一个新的概念，**原地排序**, 特指空间复杂度是 O(1) 的排序算法。

### 排序算法的稳定性

如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。那我们就把这种排序算法叫作**稳定的排序算法**.  如果前后顺序发生变化，那对应的排序算法就叫作**不稳定的排序算法**

## 冒泡排序

冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较.  一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。

假如我们要对一组数据 4，5，6，3，2，1，从小到到大进行排序.  第一次冒泡操作的详细过程就是这样：

![4038f64f47975ab9f519e4f739e464e9](https://i.imgur.com/6vioCt6.jpg)

要想完成所有数据的排序，我们只要进行 6 次这样的冒泡操作就好了.

``` js
var arr = [1, 2, 3, 4, 5, 6, 7, 9, 8];
var temp;

for (var i = 0; i < arr.length; i++) {
    for (var j = i + 1; j < arr.length; j++) {
        if (arr[i] > arr[j]) {
            temp = arr[j];
            arr[j] = arr[i];
            arr[i] = temp;
        }
    }
}
```

冒泡过程还可以优化。当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后续的冒泡操作。

冒泡排序最好情况时间复杂度是 O(n), 也就是要排序的数据已经是有序的了，我们只需要进行一次冒泡操作。而最坏的情况是，要排序的数据刚好是倒序排列的，我们需要进行 n 次冒泡操作，所以最坏情况时间复杂度为  O(n^2)。

![fe107c06da8b290fb78fcce4f6774c0f](https://i.imgur.com/QjIvaW3.jpg)

## 插入排序

一个有序的数组，我们往里面添加一个新的数据后，如何继续保持数据有序呢？很简单，我们只要遍历数组，找到数据应该插入的位置将其插入即可。

插入排序具体是如何借助上面的思想来实现排序的呢？

首先，我们将数组中的数据分为两个区间，**已排序区间** 和 **未排序区间**.

初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的**核心思想是取未排序区间中的元素**，**在已排序区间中找到合适的插入位置将其插入**，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。

![b60f61ec487358ac037bf2b6974d2de1](https://i.imgur.com/PGqn6dD.jpg)

插入排序也包含两种操作:
* 元素的比较
* 元素的移动

当我们需要将一个数据 a 插入到已排序区间时，需要拿 a 与已排序区间的元素依次比较大小，找到合适的插入位置。找到插入点之后，我们还需要将插入点之后的元素顺序往后移动一位，这样才能腾出位置给元素 a 插入。

``` js
var arr = [1, 5, 8, 9, 7, 1, 4, 10, 3]

// 从 1 开始, 因为 0 初始为 "已排序区间"
for (var i = 1; i < arr.length; i++) {
    // 提出 "未排序区间" 的第一位置的值, 用以比较
    var curValue = arr[i];

    // 从最后一个位置开始遍历 "已排序区间"
    for (var j = i - 1; j >= 0; j--) {
        // 如果 curValue 小于 j 位置上的数字, 
        // 则 j 位置数字覆盖 j + 1 位置, 也就是 "往前错一个"
        if (arr[j] > curValue) {
            arr[j + 1] = arr[j];
        } else {
            // 如果 curValue 的值不小于 j 位置上的数字了,
            // 则把 curValue 的值覆盖到 j + 1 位置上, 也就是 "插入"
            arr[j + 1] = curValue;
            break;
        }
    }
}
```

最好是时间复杂度为 O(n)。即排序的数据已经是有序的.  如果数组是倒序的，每次插入都相当于在数组的第一个位置插入新的数据，所以最坏情况时间复杂度为 O(n^2)。

## 选择排序

选择排序算法的实现思路有点类似插入排序，也分**已排序区间** 和 **未排序区间**.  但是选择排序**每次会从未排序区间中找到最小的元素, 将其放到已排序区间的末尾**。

![32371475a0b08f0db9861d102474181d](https://i.imgur.com/xtozcwG.jpg)

``` js
var arr = [1, 5, 8, 9, 7, 1, 4, 10, 3]
var minValue;
var minPosition;
var temp;

for (var i = 0; i < arr.length; i++) {

    for (var j = i; j < arr.length; j++) {
        if (!minValue) {
            minValue = arr[j];
            minPosition = j;
        } else if (arr[j] < minValue) {
            minValue = arr[j];
            minPosition = j;
        }
    }

    temp = arr[minPosition];
    arr[minPosition] = arr[i];
    arr[i] = temp;
    minValue = undefined;
}
```

选择排序的最好情况时间复杂度、最坏情况和平均情况时间复杂度都为 O(n^2)。

不同于冒泡排序, 和插入排序, 选择排序是**不稳定**的排序算法.选择排序每次都要找剩余未排序元素中的最小值，并和前面的元素交换位置，这样破坏了稳定性。比如 5，8，5，2，9 这样一组数据，使用选择排序算法来排序的话，第一次找到最小元素 2，与第一个 5 交换位置，那第一个 5 和中间的 5 顺序就变了，所以就不稳定了。

## 归并排序

如果要排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。

归并排序用到了**分治思想**.  分治，顾名思义，就是分而治之，将一个大问题分解成小的子问题来解决。小的子问题解决了，大问题也就解决了.  分治思想跟我们前面讲的递归思想很像。 分治算法一般都是用递归来实现的。**分治是一种解决问题的处理思想，递归是一种编程技巧**，

要想写出归并排序的代码，我们先写出归并排序的递推公式:
