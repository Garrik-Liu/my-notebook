# Java 集合

## 集合介绍

数组 vs 集合类：

- 数组能储存基本类型数据，和引用类型；
- 集合当中只能储存引用类型数据，基本数据类型需要先转换成引用类型才可以存放；
- 数组的长度固定；
- 集合可以动态更改长度，动态操作内部元素（增加，删除，修改）

什么时候用数组，什么时候用集合类：

- 如果元素的个数固定，就用数组；
- 如果元素不固定，就用集合；

集合类继承体系：

- Java 提供一个 Collection 接口；
- List 和 Set 接口是 Collection 的子接口；
- List 是一个 “有序类” 接口，它下面的实现类有：
  - ArrayList
  - LinkedList
  - Vector
- Set 是一个 “无序类” 接口，它下面的实现类有：
  - HashSet
  - TreeSet

## Collection

[Collection 文档链接](http://www.javaweb.cc/help/JavaAPI1.6/java/util/Collection.html)

![2020-1-31-20-15-14.png](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-1-31-20-15-14.png)

下面讲几个具体案例：

#### Collection 集合转普通数组

```java
class Person {
  private String name;

  Person(name) {
    this.name = name;
  }

  public String getName() {
    return name;
  }
}

// 创建集合
Collection c = new ArrayList();
c.add(new Person("小红"));
c.add(new Person("小明"));
c.add(new Person("小张"));

// 将集合转换成 Object 类型数组
Object[] arr = c.toArray();
for(int i = 0; i < arr.length; i++) {
  // 注意，这个时候 arr 中的元素都是 Object 类型，
  // 我们需要把它 “向下转型” 成 Person 类型，
  // 才可以使用 Person 对象的 getName 方法；
  Person p = (Person) arr[i];
  System.out.println(p.getName());
}
```

#### 迭代器遍历集合

- 通过上面用 `toArray` 转换成数组，可以进行遍历；
- 通过 “Iterator 迭代器” 也可以进行遍历；

```java
// 创建集合的迭代器
Iterator it = c.iterator();
// 通过 hasNext 方法判断，迭代器中是否还有元素
while(it.hasNext()) {
  // next 方法把当前游标内容取出，并且指针往后移动一位
  // 注意，返回的元素类型被 “向上转型” 成 Object 类型
  Object item = it.next();
}
```

因为迭代器 `next` 返回的对象将原本集合中的元素，向上转型成 Object 类型，所以使用时需要记得向下转型；

```java
while(it.hasNext()) {
  // 假如集合中全是 Person 类型元素
  Person p = (Person)it.next();
}
```

## ArrayList

下面介绍一些 ArrayList 常见的操作：

#### 根据角标添加元素

- 根据角标添加元素，只有 ArrayList 支持；
- 注意，指定的下标必须小于等于 ArrayList 的 size；

```java
List list = new ArrayList();
list.add("a");
list.add("b");
// 在下标 1 的位置，添加元素 HAHA
list.add(1, "HAHA");
// 现在集合内容是 a, HAHA, b

// 下面这条代码，会报错，因为下标大于 size
list.add(4, "c");
```

#### 迭代删除元素

- 在用迭代器迭代集合时，不要用集合的 `remove` 方法；
- 会报错：ConcurrentModificationException 并发修改异常；
- 要用迭代器自己的 `remove` 方法；

```java
List list = new ArrayList();
list.add("1");
list.add("2");
list.add("3");
list.add("4");

Iterator it = list.iterator();
while(it.hasNext()) {
  String str = (String) it.next();
  if(str.equals("2")) {
    it.remove(); // 删除正在遍历的元素
  }
}
```

#### 迭代添加元素

- 同理，用迭代器的时候，也不能用集合自己的 `add` 方法；
- 但是 Iterator 自己本身没有 `add` 方法；
- 这里要用 ListIterator，这个是 List 专属的迭代器；

```java
List list = new ArrayList();
list.add("1");
list.add("2");
list.add("3");
list.add("4");

ListIterator it = list.listIterator();
while(it.hasNext()) {
  String str = (String) it.next();
  if(str.equals("2")) {
    it.add("HAHA"); // 在当前所在元素之后添加一个元素
  }
}
```

#### 去除集合当中重复的元素

- 创建一个空的集合；
- 依次取出原来集合中的每一个元素；
- 判断新集合中是否包含这个元素；
- 如果没有就将元素添加到新集合；

```java
ArrayList newList = new ArrayList();
ListIterator it = list.listIterator();
while(it.hasNext()) {
  String item = (String) it.next();
  if(!newList.contains(item)) {
    newList.add(item);
  }
}
```

- `contains` 方法会调用对象里面的 `equals` 去判断是否相等；
- 假如 ArrayList 中保存的是引用类型对象；
- 那么 `equals` 会去判断地址是否相等；
- 我们需要重新改写 `equals` 方法；

```java
class Student {
  String name;
  int age;

  Student(String name, int age) {
    this.name = name;
    this.age = age;
  }

  // 重写
  @Override
  public boolean equals(Object obj) {
    Student stu = (Student) obj;
    return this.name.equals(stu.name) && this.age == stu.age;
  }
}
```

## LinkedList

![2020-2-1-2-55-41](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-2-1-2-55-41)

![2020-2-1-2-56-17.png](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-2-1-2-56-17.png)

## Vector

![2020-2-1-2-57-48.png](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-2-1-2-57-48.png)

## 泛型

### 什么是泛型

- 泛型就是通用的类型；
- 在一开始不确定该是什么类型，在使用的时候才能确定是什么类型；

下面的例子中体现了为什么要使用泛型：

```java
// 声明了集合，里面可以存任何类型的元素
// 希望有办法来约束集合当中只能存某一种类型
List list = new ArrayList();
list.add(1);
list.add("abc")

// 不确定创建时传入什么类型的值
// 不用泛型的话，就要写很多个属性
class Point {
  private String x1;
  private String y1;

  private Integer x2;
  private Integer y2;

  private Double x3;
  private Double y3;
}
```

通过泛型就可以解决这些问题：

- 在定义类时，在类名的后面加上 `<T>`;
- T 代表不确定的类型，在创建对象时，才能知道具体是什么类型；
- 在属性前加 T 代表不确定的类型；
- 因为 T 只是代表不确定的类型，这里也可以写成别的字母，A，B，C 也可以；

- 在创建对象的时候，要指明泛型的类型；
- 注意，只能是**引用类型**；
- 例如：`Point<String> p = new Point<String>()`；
- 如果没有指明，它就默认是 Object 类型；

```java
class Point<T> {
  T x;
  T y;
}

Point<String> p = new Point<String>();
p.x = "123";
p.y = "456";
```

#### 用泛型声明集合

- 前面我们声明的集合，都没有指定集合内元素的类型；
- 集合类支持泛型，我们可以定义的时候，指定集合内元素的类型必须是什么；
- 如果不指定，则默认是 Object 类型；

```java
// 指定集合内只能是字符串类型
ArrayList<String> list = new ArrayList<String>();
list.add("a");
list.add("b");
list.add("c");
list.add(1); // 这一条代码，就会报错，因为它不是字符串类型
```

#### 使用泛型时的注意点

- 泛型前后尖括号内类型必须保持一致：
  - 这样是不行的： `ArrayList<Integer> list = new ArrayList<String>();`
- 从 Java 7 开始，后面尖括号里的类型可以不写：
  - 因为本来前后尖括号内类型必须保持一致，那么只写一个就行了；
  - 例如：`ArrayList<Integer> list = new ArrayList<>();`

### 泛型类 & 泛型方法

下面再定义清楚一下，“泛型类” 和 “泛型方法” 的区别:

- 泛型类：在类上面定义的泛型，在创建对象的时候，指定泛型的类型；
- 泛型方法：在方法上定义的泛型，在调用时，通过传入参数指定具体类型；

这个就是泛型类：

```java
class Point<T> {
  T x;
  T y;
}

Point<String> p = new Point<String>();
```

这个是泛型方法：

```java
<T> void test(T a) {}
test("abc") // 泛型的类型就是字符串类型
```

### 泛型通配符

- 当方法需要接受一个泛型类对象，但是却不知道对象的具体类型；
- 可以使用通配符 `?` 来定义参数；

```java
// 使用通配符，表明还不确定 List 内泛型的类型
void test(List<?> list) {}

List<Integer> list = new ArrayList<>();
test(list);
```

### 泛型的上限 & 下限

- 泛型的**上限**，用来限定元素的类型必须是指定类型的**子类**或指定类型；
- 泛型的**下限**，用来限定元素的类型必须是指定类型的**父类**或指定类型；

```java
// 指定上限，传入的必须是 Number 的子类或指定类型；
void test1(List<? extends Number> list) {}
// 指定下限，传入的必须是 Number 的父类或指定类型；
void test2(List<? super Number> list) {}
```

### 泛型擦除

泛型擦除的意思是，把已经指定了泛型的对象，的泛型类型重新指定成 Object 类型。

```java
List<String> list1 = new ArrayList<>();
list1.add("a");

List list2 = null;
// 这步操作，可以让 list2 称为 list1 的替代；
// list2 的泛型类型为 Object，可以保存其他类型的元素；
list2 = list1;
list2.add("b");
list2.add(3);
```

## HashSet

## TreeSet

## Map
