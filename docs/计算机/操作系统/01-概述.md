# 概述

## 什么是操作系统

计算机系统可以被分为 4 个部件:

- 计算机硬件
- 操作系统
- 应用程序
- 用户

![2020-06-10-10-46-39](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-10-10-46-39.png)

操作系统没有一个十分精确的定义.

**操作系统是一个一直运行在计算机上的程序, 也被称为『 内核 Kernal 』, 作用像是位于 "用户" 和 "硬件" 之间的中介**. 可以提供如下功能:

- 为应用程序提供支持;
- 管理硬件资源;
- 管理应用程序;
- 优化硬件资源;
- 管理 I/O 设备;
- 为用户提供更简便地方法去使用计算机;
- etc.

## 计算机体系结构

**单处理器系统**:

- 只具备一个 CPU 的系统;

**多处理器系统**:

- 具备多个 CPU 的系统, 也称为『 并行系统 parallel system 』和『 紧耦合系统 tightly coupled system 』
- 主要分为两种类型:
  - 『 **非对称多处理** asymmetric multiprocessing 』: 一个 "主处理器" 控制整个系统, 调度多个 "从处理器" 去执行各自的任务;
  - 『 **对称多处理** symmetric multiprocessing, SMP 』: 每个处理器都是平等的, 都可以执行操作系统中的任务;

![2020-06-10-11-04-11](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-10-11-04-11.png)

**集群系统**:

- 是由多个独立的系统, 依靠某种方式连接在一起, 来实现多个 CPU 集中处理任务;
- 集群提供了 "高可用性" 服务, 即使一个系统出错了, 服务也不会挂掉;

![2020-06-10-11-10-59](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-10-11-10-59.png)

## 操作系统结构

**Multiprogramming**:

- 对于操作系统来说, 最终要的能力是 "multiprogram".
- Single program cannot keep CPU and I/O devices busy at all times;
- Multiprogramming organizes jobs (code and data) so CPU always has one to execute
- A subset of total jobs (the **job pool** on disk) in system is kept in memory
- Each job is selected and run via a job **scheduling algorithm**
- When it has to wait (for I/O for example), OS switches to another job;

---

分时系统 Time sharing / Multitasking :

- Time sharing (or multitasking) is a logical extension in which CPU switches jobs so frequently that users can interact with each job while it is running;
- creating **interactive** computing;

## 操作系统操作

现代操作系统是 **interrupt driven** 中断驱动的:

- 如果没有任务去执行, 操作系统就会等待某件事件发生;
- 事件总是由 interrupt 或 trap 引起的;
- Trap 或者 Exception 是一种由程序运行时的错误引起的 software-generated interrupt;
- 对于不同类型的 interrupt, 操作系统有相对应的方式去处理;
- 因为操作系统中, 程序间共享硬件和软件资源. 如果一个程序出了错误, 其他程序也会受影响. 所以操作系统必须对错误进行处理.

### 双重 & 多重模式执行

为了保证操作系统的正确运行, 必须区分 "操作系统代码" 和 "用户代码" 的执行;

很多操作系统的实现方法是, 提供硬件支持, 以允许区分多种 "**执行模式 modes of execution**"

- 至少需要两种执行模式, **user mode** 和 **kernal mode**:
  - kernal mode 也被称为 supervisor mode, system mode, privileged mode;
- 还需要在硬件中增加一个『 **模式位 mode bit** 』, 用以表示当前的模式 ( kernal - 0 / user - 1 );
- 当操作系统正在执行用户应用程序时, 系统处于 user mode. 反之亦然;
- 如果用户应用程序需要调用操作系统服务时, 系统从 user mode 转换成 kernal mode, 系统服务返回结果给应用程序时, 再转换回 user mode;

![2020-06-10-14-54-59](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-10-14-54-59.png)

- 对于那些会可能会引起损害的机器指令, 它们被称为『 **特权指令** privileged instruction 』 如果在 user mode, 有应用程序想要执行特权指令, 该执行会被认为是非法的, 会以 trap 的形式通知操作系统;

为了实现更细致的控制, 操作系统可以提供更多的『 执行模式 』

### 定时器

必须保证操作系统可以维持对于 CPU 的控制, 不能让用户应用程序陷入死循环, 或错误调用系统服务, 或者不将控制器返回给操作系统.

通过使用『 **定时器 Timer** 』可以实现这一目标.

- 在操作系统将控制权交给用户应用程序之前, 会将 Timer 设定好一个时间周期, 当到期后程序仍在运行, 则会产生一个 interrupt, 来停止程序运行, 并将控制权交还给操作系统;
- Timer 可以由一个固定速率的时钟, 或者计数器 Counter 来实现;

## 进程管理

## 内存管理

## 存储管理

## 保护 & 安全

## 分布式系统

## 专用系统
