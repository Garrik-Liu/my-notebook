# 绪论 & 初始阶段

![2020-06-18-08-14-47](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-18-08-14-47.png)

## 绪论

### 面向对象分析和设计

#### 什么是分析和设计

**分析** ( analysis ) : 强调的是对问题和需求的调查研究, 而不是给出解决方案;

- 🌰 分析一个在线交易系统, 应该关注于如何使用它, 它应该具有哪些功能;

**设计** ( design ) : 强调的在是满足需求的概念上, 给出解决方案. 但是不给出具体实现;

- 设计可以被实现, 而实现表达了真实和完整的设计;
- 🌰 对于一个面向对象软件中的各个类, 我们描述它们具有的属性和方法, 以及彼此间的关系, 但是并不写出实际的代码;

#### 什么是面向对象分析和设计

**面向对象分析** ( object-oriented analysis ) : 强调的是在问题领域内 "发现" 和 "描述"『 对象 』

- 🌰 在航班信息系统里, 包含飞机 Plane, 航班 Flight, 飞行员 Pilot 等对象;

**面向对象设计** ( object-oriented design ) : 强调的是 "定义"『 对象 』以及它们之间如何协作以实现需求;

- 🌰 Plane 对象可以有 tailNumber 属性, getFlightHistory 方法;

最后, 开发者根据『 面向对象设计 』去写出实际的代码;

![2020-06-19-16-20-17](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-19-16-20-17.png)

#### 简单示例

#### 什么是 UML

- **UML 全称 Unified Modeling Language, 统一建模语言**;
- UML is a **visual language** for specifying, constructing and documenting the artifacts of systems;
- UML 提供了一个标准的图形化表示法, 去描述系统;
- UML 是一个庞大的表示法体系, 这里只讲它的核心表示法;
- UML 仅仅是标准的图形化表示法, 它用于对设计和思想进行可视化展现. 如果没有良好的设计能力, 精通 UML 也没有用;

**应用 UML 的三种方式**:

- 作为 **草图**: 用非正式, 简化的图, 以可视化的方式去探讨问题或者解决方案中复杂的部分;
- 作为 **蓝图**: 相对详细的设计图:
  - 用 UML 图, 以可视化的形式描述程序代码, 使其易于理解;
  - 例如, UML 包图, 类图, 顺序图;
- 作为 **编程语言**: 用 UML 图去自动生成可执行的代码 ( 这种用途这里不讨论 )

**应用 UML 的三种透视图**:

-

### 迭代,进化和敏捷

#### 什么是 UP

『 **软件开发过程** software development process 』描述了构造, 部署以及维护软件的方式.

『 **统一过程** Unified Process, UP 』是一种流行的构造 "面向对象" 系统的 "迭代" 软件开发过程;

- 『 Rational 统一过程, RUP 』是对统一过程的详细精化;
- UP 很开放, 愿意引用其他迭代方法中有用的实践, 例如:
  - XP 的 测试驱动开发, 重构, 持续集成, 等实践;
  - Scrum 的公共项目室, 和 Scrum 日常会议等实践;

#### 什么是迭代和进化式开发

『 **迭代开发** iterative development 』是一种软件开发的方式. 在这种生命周期方法中, 开发被组织成一系列固定的短期小项目, 称之为『 **迭代** iteration 』

#### 什么是瀑布生命周期

#### 如何进行迭代和进化式分析和设计

#### 什么是风险驱动和客户驱动的迭代计划

#### 什么是敏捷方法

#### 什么是敏捷建模

#### 什么是敏捷 UP

#### 什么是 UP 的阶段

#### 什么是 UP 科目

### 案例研究

## 初始阶段

### 初始不是需求阶段

#### 什么是初始阶段

大多数项目需要一个简短的初始步骤. 在这个阶段:

- 为项目目标建立一些初始的构想, 并与团队成员达成一致;
- 确定项目的可行性, 并决定项目是否值得进一步研究;

初始阶段事件比较短暂:

- 通常只包含第一次需求研讨会, 并制定第一次迭代计划.
- 大约时间控制在一周之内.
- 在初始阶段完成后, 快速进入细化阶段.

#### 初始阶段会创建的制品

下表 👇 列出了, 在初始阶段可能会创建的制品, 以及各个制品所解决的问题.

在初始阶段只需要完成其中部分制品, 在后续的迭代中再对其进行精化. 而且除非认定某个制品很具有实用价值, 否则就不创建.

创建制品或模型的重点不是在于文档或图示, 而是其中蕴含的思想, 分析和前期准备.

建模的目的是增强理解, 而不是记录规格说明.

![2020-06-20-07-56-52](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-20-07-56-52.png)

| Artifact                               | Comment                                                                                                                                                                                             |
| -------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Vision and Business Case               | Describes the high-level goals and constraints, the business case, and provides an executive summary.                                                                                               |
| Use-Case Model                         | Describes the functional requirements. During inception, the names of most use cases will be identified, and perhaps 10% of the use cases will be analyzed in detail.                               |
| Supplementary Specification            | Describes other requirements, mostly non-functional. During inception, it is useful to have some idea of the key nonfunctional requirements that have will have a major impact on the architecture. |
| Glossary                               | Key domain terminology, and data dictionary.                                                                                                                                                        |
| Risk List & Risk Management Plan       | Describes the risks (business, technical, resource, schedule) and ideas for their mitigation or response.                                                                                           |
| Prototypes and proof-ofconcepts        | To clarify the vision, and validate technical ideas.                                                                                                                                                |
| Iteration Plan                         | Describes what to do in the first elaboration iteration.                                                                                                                                            |
| Phase Plan & Software Development Plan | Low-precision guess for elaboration phase duration and effort. Tools, people, education, and other resources.                                                                                       |
| Development Case                       | A description of the customized UP steps and artifacts for this project. In the UP, one always customizes it for the project.                                                                       |

#### 初始阶段需要避免的错误

- 花费时间太长;
  - 一周以内就好;
- 定义大部分的需求;
  - 在细化阶段进行;
- 制定可靠的预算和计划;
  - 只需研究项目是否可行;
- 设计架构;
  - 应该在细化阶段以迭代的方式来定义架构;
  - 顺序: 定义需求 -> 设计架构 -> 实现;
- 不写设想或业务用例;
- 详细编写所有的用例;
  - 只需详细编写 10% - 20% 的用例以便对问题范围有真实的认知;
- 引入大量的图形:
  - 初始阶段主要用文字来表达, 可以用一些简单的 UML 用例图来做辅助, 但是绝对不应该引入大量的图形;

### 进化式需求

#### 进化式需求 & 瀑布式需求

『 **需求** requirement 』就是项目必须提供的能力, 和必须遵从的条件.

UP 提出了『 **需求管理** manage requirement 』的最佳实践, 主张不在一开始就试图完全定义和固化需求. 而是采用『 **迭代式需求分析** 』, 并且引入频繁的涉众参与, 评估和对局部结果的反馈.

之所以这样是因为, 软件项目的需求具有『 **高变更率** 』, 不同于传统的工程项目 ( 制造业, 建筑业, etc. )

『 **瀑布式需求分析** 』, 尝试在一开始就详细定义和固化所有的需求, 这种做法是有缺陷的. 因为很多需求可能在后期就会被改变, 而团队却为错误的需求花费了大量的资源 ( 时间, 金钱, 人力, 时机, etc. ) 这会很大程度导致项目最终失败.

#### 需求的类型 & 种类

在 UP 中, 需求按照 **FURPS +** 模型进行分类:

- **功能性**（ Functional ）: 特性、功能、安全性；
- **可用性**（ Usability ）: 人性化因素、帮助、文档；
- **可靠性**（ Reliability ）: 故障频率、可恢复性、可预测性；
- **性能**（ Performance ）: 响应时间、吞吐量、准确性、有效性、资源利用率；
- **可支持性**（ Supportability ）: 适应性、可维护性、国际化、可配置性。

FURPS+ 中的 `+` 是指一些辅助性的和次要的因素，比如:

- **实现**（ Implementation ）: 资源限制、语言和工具、硬件等；
- **接口**（ Interface ）；强加于外部系统接口之上的约束；
- **操作**（ Operation ）: 对其操作设置的系统管理；
- **包装**（ Packaging ）例如物理的包装盒；
- **授权**（ Legal ）: 许可证或其他方式。

**FURPS+** 模型提供的『 分类方案 』是很全面的, 作为需求范围检查列表可以避免遗漏系统中某些重要的方面.

其中, "可用性, 可靠性, 性能, 可支持性" 可以统称为系统的『 **质量需求** quality requirement 』或『 **质量属性** quality attribute 』

还可以把需求按照『 功能性 』和『 非功能性 』( 其他的所有需求 ) 来分类.

#### UP 制品如何组织需求

UP 提供了一些制品来组织需求, 它们都是可选的.

![2020-06-20-09-50-07](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-20-09-50-07.png)

### 用例

#### 什么是用例

『 **用例** use case 』是文本形式的情节描述, 用以说明参与者如何使用系统去实现某些目标的『 情节 stories 』;

- 用例本质是 “发现” 和 “记录”『 功能性的需求 』
- 用例不是图形, 而是文本. UML 用例图可能用于辅助情节描述, 但是它不是用例本身;

#### 定义: 参与者, 场景, 用例

- **参与者** actor:
  - 具有某些行为的东西;
  - 🌰 人, 计算机系统, 组织, etc.;
  - 🌰 结账系统: 收银员, 经理;
  - 🌰 网络协议栈: 运输层, 网络层, etc;
- **场景** scenario:
  - 参与者与系统之间一系类特定的活动和交互;
  - 也称为『 **用例实例** use case instance 』
  - 是参与者使用系统的一个特定情节, 或用例的一条执行路径;
  - 🌰 使用现金成功购买商品的场景;
  - 🌰 信用卡付款被拒, 造成购买失败的场景;
- **用例** use case:
  - 就是一组相关的成功或失败场景的集合;
  - 用来描述参与者如何使用系统来实现目标;

#### 定义: 参与者的三种类型

- **主要参与者** primary actor: 具有用户目标, 并通过系统提供的服务实现;
  - 🌰 收银员, 使用收银系统来处理顾客购物支付.
- **协助参与者** supporting actor: 为系统提供服务;
  - 🌰 自动付费授权系统, 用户认证登录系统;
- **幕后参与者** offstage actor: 在用例行为中具有影响或利益, 但不是主要或协助参与者;
  - 🌰 政府税收机构, 从收银系统的流水中确定税收金额;

#### 表示法: 用例的三种常用形式

**摘要** brief: 简洁的一段式概要, 通常用于主成功场景;

- 何时使用: 在早期需求分析过程中使用, 为快速了解主题和范围;

::: details-open 🌰 例子：

**处理销售**: 顾客携带所购商品到收银台, 收银台使用 POS 系统记录每件商品. 系统连续显示累计总额, 并逐行显示明细. 顾客输入支付信息, 系统对支付信息进行验证和记录. 系统更新库存信息. 顾客从系统得到购物小票, 然后携带商品离开.

:::

**非正式** casual: 非正式的段落, 用来描述不同的场景;

- 何时使用: 在早期需求分析过程中使用, 为快速了解主题和范围;

::: details-open 🌰 例子：

![2020-06-20-12-06-41](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-20-12-06-41.png)

:::

**详述** fully dressed: 以结构化的方式, 详细编写所有的步骤及各种变化 ( 分支 ) , 同时具有补充部分, 如前置条件和成功保证;

- 何时使用: 在以摘要形式编写了大量用例后, 在第一次需求讨论会汇总, 详细地编写少量的 10% 的具有重要架构意义的详述用例;

#### 🌰 示例: 详述风格的处理销售

下表 👇 展示了详述风格用例的各部分名称, 及其意义:

![2020-06-20-12-14-25](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-20-12-14-25.png)

![2020-06-20-12-22-14](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-20-12-22-14.png)
![2020-06-20-12-23-02](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-20-12-23-02.png)
![2020-06-20-12-23-15](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-20-12-23-15.png)
![2020-06-20-12-23-37](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-20-12-23-37.png)
![2020-06-20-12-23-49](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-20-12-23-49.png)
![2020-06-20-12-24-00](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-20-12-24-00.png)

#### 各小结的含义

📚 **绪言元素 Preface Elements**:

**范围**:

- 界定了所要设计的系统 / 业务;

**级别**:

- 『 **用户目标级别** user-goal level 』: 描述了实现主要参与者目标的的场景;
- 『 **子功能级别** subfunction level 』: 用例描述支持用户目标所需的子步骤;
  - 通常这个 "子步骤" 在多个用例中都被使用到, 所以单独分离出来定义为一个 "子功能级别用例";

**主要参与者**:

- 调用系统服务来完成目标的主要参与者;

**涉众及其关注点列表 Interest List**:

- 列出所以与这个系统相关的人, 以及他们希望这个系统能够给他们带来的好处;
- 在编写具体用例之前, 就要确定好 "涉众及其关注点", 这样可以对系统的职责有更清晰的认识;
- 所写的用例应该满足所有涉众的关注点. 以此列表去检查所写的用例, 可以避免职责遗漏;

**前置条件 & 成功保证 ( 后置条件 )** :

- 『 **前置条件** 』: 给出用例在开始之前必须为真的条件;
- 『 **成功保证 / 后置条件** 』: 给出用例成功结束后必须为真的条件. 这些条件应该满足所有涉众的需求;

---

📚 **主成功场景 & 基本流程**:

描述了满足涉众关注点的典型成功路径;

通常不包含任何条件或分支, 所以的条件处理都推延到扩展部分;

主成功场景记录以下三种步骤:

- 参与者之间的交互;
- 确认过程;
- 系统完成的状态变更;

场景中的第 1 个步骤通常不属于以上的分类, 一般是启动场景的触发事件;

![2020-06-20-17-29-00](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-20-17-29-00.png)

---

📚 **扩展 ( 替代流程 )** :

描述了其他所有场景或分支, 包括成功和失败路径;

- 通常占据文本的大部分篇幅, 一般比主成功场景更长更复杂;
- 主成功场景和扩展相结合, 应该满足几乎所有涉众关注点. 但是必须是功能性的需求;
- 非功能性需求在 "补充规格说明" 中描述, 而不是用例;

因为扩展场景是主成功场景的分支, 所以用主成功场景中对应的步骤 $1 ... N$ 对扩展场景进行标识;

- 🌰 在主成功场景的第 `3` 步, 出现了多条分支路径, 那么对应的第一个扩展被标记为 `3a`, 第二个扩展被标记为 `3b`, 以此类推;

扩展由两部分组成: 条件 & 处理;

![2020-06-20-17-45-38](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-20-17-45-38.png)

扩展处理结束后, 默认来说, 应该重新并入主成功场景, 除非扩展指出了其他处理方式;

- 🌰 系统直接中断;

如果想要描述在任何 ( 大多数 ) 步骤都有可能发生的扩展, 可以用 `*a`, `*b` 这样的标记:

![2020-06-20-17-50-07](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-20-17-50-07.png)

**执行其他用例场景**: 有时候用例会产生分支以执行其他用例场景, 那么可以用 "下划线" 来标识另一个用例;

![2020-06-20-17-38-24](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-20-17-38-24.png)

---

📚 **特殊需求**:

包含于用例相关的 "非功能性需求, 质量属性 ( 性能, 可靠性, 可用性 ) , 设计约束":

![2020-06-20-17-56-45](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-20-17-56-45.png)

虽然 UP 建议把特殊需求写入用例, 但是很多从业者发现, 最终把所有的非功能性需求集中于 "补充规范规格说明" 中, 对于内容管理, 可理解性和可读性而言更为有效.

---

📚 **技术 & 数据变元表** Technology & Data Variations List:

技术和数据变元, 是关于如何实现系统的约束;

- 🌰 涉众要求, POS 系统必须使用键盘来作为输入设备;
- 🌰 使用条形码体系中的 UPC 或 EAN 对商品进行编码;

虽然应该避免早期就做出不成熟的设计决策和约束, 但是有些决策是显而易见不可避免的;

![2020-06-20-18-03-58](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-20-18-03-58.png)

#### 表示法: 两栏变体

详述风格的用例还可以用『 两栏对话 』的格式来写, 用以强调 "参与者和系统之间" 的交互.

![2020-06-20-17-00-13](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-20-17-00-13.png)

---

用例可以用各种各样的格式来表述, 不存在最好的格式.

关键点是要详细地编写出『 主要成功场景 』及其『 扩展 ( 替代流程 ) 』

#### 一些准则

**在初始阶段, 本质风格编写用例**:

- 把抛除具体实现细节, 而只集中于用户真实意图的用例编写风格称为『 **本质** essential 』风格. 与之相对的是『 **具体** 』风格;

![2020-06-20-18-11-25](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-20-18-11-25.png)
![2020-06-20-18-11-48](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-20-18-11-48.png)

**尽量保持用例描述的简洁**:

- 应当尽量抛出不必要的词汇;
- 🌰 "系统认证" 要好与 "这个系统认证功能";

**编写黑盒用例**:

- 黑盒用例不对系统内部具体的设计, 工作原理进行描述;
- 它只描述系统的 "**职责**", 也就是描述系统 "能够做" 什么, 而不是 "怎么做";

**关注系统的参与者**:

- 编写需求时, 应该关注于系统的参与者及其目标;
- 用例中的每个场景执行完的结果, 应该是对参与者有价值的;
- 如果系统不能满足参与者所需, 那就是失败的;

#### 如何发现用例

为满足主要参与者的目标而定义用例, 基本过程如下:

📚 **1 - 选择系统边界**:

定义什么东西在系统之外, 什么在系统之内.

如果对系统边界定义不清, 可以先定义外部的 "主要参与者" 和 "协助参与者", 然后再去定义系统边界.

📚 **2 & 3 - 确定主要参与者和目标**:

在识别用户目标之前, 要先识别清楚主要参与者和他们的目标.

系统是服务于参与者以实现其目标的, 用例描述了这个过程. 优先关注与参与者及其目标, 可以以更高层的角度去思考涉众想从系统中获得的核心价值.

**可以通过问以下问题, 来寻找参与者和目标**:

![2020-06-21-12-15-45](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-21-12-15-45.png)

**如何组织参与者 & 目标**:

有至少如下两种方式:

1. 先绘制出用例图, 以目标作为用例名称;
2. 先写出 "参与者 - 目标" 列表, 然后绘制用例图;

![2020-06-21-12-22-34](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-21-12-22-34.png)

**系统边界不同, 主要参与者和目标也不同**:

![2020-06-21-12-34-05](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-21-12-34-05.png)

🌰 例如, "POS 系统" 的主要服务于 "收银员", 而不是 "顾客". 所以主要参与者是 "收银员".

📚 **4 - 定义用例**:

为每个用户目标分别定义用例. 用例的名称形容了用户目标, 以动词开头.

- 🌰 **目标**: 处理销售; **用例**: 处理销售;

对于分散的 CRUD ( 创建, 提取, 更新, 删除 ) 目标, 可以合并成一个用例, 一般称为 "管理 XXX".

- 🌰 例如, "管理用户" 用例, 可以同时满足 "编辑用户", "创建用户", "删除用户" 等目标.

#### UML 用例图

『 UML 用例图 』以可视化的方式, 描述外部参与者对系统的使用.

![2020-06-20-18-29-36](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-20-18-29-36.png)

![2020-06-21-11-07-18](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-21-11-07-18.png)

#### 在迭代方法中如何使用用例

UP 提出『 **用例驱动开发** use-case driven development 』

- 团队的设计与开发目的是为了实现用例;
- 迭代的工作是通过选择一些用例场景, 或整个用例来定义的;

![2020-06-21-12-47-17](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-21-12-47-17.png)

在第一次迭代接近结束后, 举行了 "第二次需求讨论会". 这次讨论会中, 根据第一次迭代会的的反馈 ( 用户评估, 测试, etc. ) 再详细编写 30% 的用例;

**在 UP 中, 提倡在需求讨论会上编写用例**, 具体场景如下图 👇:

![2020-06-21-12-57-03](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-21-12-57-03.png)

**何时创建各种 UP 制品**:

![2020-06-21-13-03-53](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-21-13-03-53.png)
![2020-06-21-13-04-17](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-21-13-04-17.png)

**在初始阶段如何编写用例**:

- 先开始写 "参与者 - 目标 - 用例" 列表;
- 在写了很多之后, 以 "**摘要**" 的形式编写大部分需要关注的, 复杂的, 具有风险的用例;
- 之后再以 "**详述**" 的形式编写其中 10% 代表系统核心功能, 关乎系统核心架构, 或再某一方面有高危险性的用例;

**在细化阶段如何编写用例**:

- 细化阶段包含多次时迭代;
- 每次迭代之前根据上次迭代的反馈调整精化用户目标, 用例列表. 并以详述形式编写更多的用例;
- 在细化阶段结束时, 大约要详细编写 80% - 90% 的用例;
- 在细化阶段结束后, 开发团队应该不仅有一个更详细的用例定义, 还应该有一个可执行的软件;

**在构造阶段如何编写用例**:

- 在细化阶段已经把所有的核心问题都解决了, 在构造阶段, 每次迭代着重于完成系统;
- 这一阶段可能要编写一些次要的用例;

### 其他需求
