# 细化迭代 1 - 基础

## 迭代 1 - 基础

### 迭代 1 的需求 & 重点

> 下面 👇 给出的只是用以讲解的案例. 真实项目中, 应当以架构为核心, 先迭代最重要, 最困难, 最具风险的需求.

![2020-06-21-23-16-36](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-21-23-16-36.png)

上面 👆 例子, 只展示了在第一次迭代中, 对于『 **处理销售** 』用例要处理的需求. 除此之外, 还需要对其他大量的用例展开分析;

每次迭代只处理一个用例的一部分需求, 通过若干次迭代对同一个用例进行 "增量式开发"

- 简短的用例可以在一次迭代内完成;

### 过程: 初始 & 细化

『 **细化** elaboration 』是一般项目中最初的一系列迭代. 此阶段需要, **构建核心架构, 解决高风险元素, 定义大部分需求, 以及预计总体进度和资源**

细化阶段构建的核心架构被称为『 **架构原型** architectural prototype 』

- 这不是一个可以废弃掉, 实验性的原型. 它是最终完成的系统的一部分;
- 这个架构也可以称为『 **可执行架构** executable architecture 』和『 **架构基线** architectural baseline 』

![2020-06-21-23-36-37](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-21-23-36-37.png)

**细化阶段需要创建的制品**:

- 注意这些制品不是在一次迭代中完成的, 是跨越多次迭代进行精化的;

![2020-06-21-23-39-03](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-21-23-39-03.png)

**细化阶段要避免的错误** ❌:

- 如果出现了这些错误, 说明你在 UP 之上强加了瀑布思想;

![2020-06-21-23-38-22](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-21-23-38-22.png)

### 过程: 计划下一个迭代

可以通过 "风险, 覆盖范围, 关键程度" 组织需求和迭代:

- **风险**: 即包含技术复杂性, 也包含其他因素, 例如工作量或可用性的不确定性;
- **覆盖范围**: 早期迭代中至少要涉及系统的所有主要部分;
- **关键程度**: 客户认为具有高业务价值的功能;

这些标准用来对不同迭代中的工作划分等级.

- 早期迭代用于实现高等级的场景;
- 某些与用例核心业务逻辑无关的高阶特性, 例如 "日志服务". 此类需求也需要划分等级;
- 在每次新的迭代中, 都需要重新划分需求的等级. 因为新的需求和新理解, 会影响等级的排列;

![2020-06-21-23-46-15](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-21-23-46-15.png)

## 领域模型

### 什么是领域模型

![2020-06-22-14-33-44](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-22-14-33-44.png)

『 **领域模型** domain model 』是对现实世界事物概念上的抽象表示, 其中包含了各种概念类具有的属性, 以及它们之间的关联:

- 通过 UML 表示法, 领域模型被描述为一组没有定义操作的 『 **类图** class diagram 』
- 也被称为『 **概念模型** 』『 **领域对象模型** 』『 **分析对象模型** 』
- 在 UP 中, 领域模型用于抽象的解释业务领域中涉及到的各种事物;
- 通过领域模型, 团队可以在具体开发之前, 对整个项目的涉及的关键概念, 核心业务有一个整体且简化的了解. 并且领域模型可以一直作为参考在项目的各个阶段被使用, 便于团队间沟通和理解;

![2020-06-22-15-10-03](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-22-15-10-03.png)

---

『 **概念类** conceptual class 』是指对现实世界事物抽象出来的类.

定义一个概念类时, 可以从三个角度出发:

- **符号**: 表示概念类的词语或图像;
- **内涵**: 概念类的定义;
- **外延**: 概念类所使用的的一组示例;

🌰 例如, 在考虑购买交易事件的概念类时:

- 使用符号 `Sale` 对其命名;
- Sale 的内涵是 "表示购买交易的事件, 并且具有 购买日期 和 具体时间 属性"
- Sale 的外延是 "所有销售的购买交易实例集合";

![2020-06-22-15-14-20](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-22-15-14-20.png)

---

领域模型是对现实世界事物的抽象表示, ❌ **不是对软件对象的表示** ( 例如, Java 类 )

- 领域模型中不应该包含『 软件制品 』或包含任何指责与方法的『 软件类 』
- 除非要针对现实世界中的软件, 进行概念上的抽象;

![2020-06-22-14-58-32](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-22-14-58-32.png)

在软件开发中, 也有人把软件中的『 **领域层** domain layer 』 称为『 领域对象 』

- 『 领域层 』中的类包含业务逻辑, 例如, `Board` 类具有 `gerSquare` 方法.

![2020-06-22-15-03-55](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-22-15-03-55.png)

**对于术语的混淆, 会造成团队之中理解的不一致**. 在本书中:

- 『 领域模型 』指对现实世界事物的抽象;
- 『 领域层 』指对具有业务逻辑的软件对象的抽象;

在开发领域层的软件类时, **"软件类的名称" 应该源于 "领域模型中的名称"**:

- 这样可以**减小** "领域模型" 与 "软件模型" 之间的 "**表示差异**";
- 以便于开发团队可以更简便地理解软件;

![2020-06-22-20-28-26](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-22-20-28-26.png)

### 创建领域模型 & 寻找概念类

#### 如何创建领域模型

以当前迭代中所有设计的需求为边界:

- 先寻找概念类;
- 再将其绘制为 UML 类图中的类;
- 最后添加类的属性, 以及类与类之间的关联

#### 如何找到概念类

**方法 1: 重用现有的模型**: 这是最简单的方法, 很多领域都存在已发布的领域模型. 根据自己的项目需求, 稍加修改就可以.

**方法 2: 使用分类列表**: 可以通过制作概念类候选列表来开始创建领域模型;

- 根据需求去列出项目会涉及到的概念类的类别列表;
- 然后在每个类别下再列出具体的概念类;

![2020-06-22-20-41-00](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-22-20-41-00.png)
![2020-06-22-20-41-21](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-22-20-41-21.png)

**方法 3: 识别名词短语**: 从需求的文本性描述中, 识别出名词和短语, 将其作为候选的概念类或属性;

- 但是要注意, 自然语言并不精确, 不用的名词短语可能指的是同一个概念类或属性, 还可能有歧义. 使用时要谨慎;
- 建议与 "分类列表" 一起使用;

![2020-06-22-20-45-29](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-22-20-45-29.png)

#### 敏捷建模

在领域建模过程中, 通常会遗漏掉一些概念类, 在后面进行草图设计或编程时可能会发现这些类.

但是如果领域模型采用的是『 **敏捷建模** 』的方法:

- 那么就没有必要再将遗漏掉的类更新到领域模型上.
- 因为领域模型的目的是为了让团队能快速理解和沟通项目的关键概念. 并不需要完美;
- 如果没有十足的理由, 就没有必要更新最初的领域模型;

#### 不要把概念类和属性弄混

不要把应该是 "概念类" 的事物表示为 "属性".

如果我们认为某个东西不能用字面量的值 ( 数字, 文本 ) 来表示, 那么它应该是 "概念类". 反之就是 "属性".

![2020-06-22-21-27-17](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-22-21-27-17.png)

### 关联

『 **关联** association 』是类 ( 更准确的说, 是这些类的实例 ) 之间的关系.

- 关联被表示为类之间的连线;
- 中间放上首字母大写的 "关联名称";
  - 使用动词短语, 不要使用不会增强我们对领域理解的词语 ( 例如. "使用", "拥有", etc. )
- 关联的末端可以包含 "多重性" 表达式, 用以指明类的实例之间的数量关系;

![2020-06-22-22-57-36](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-22-22-57-36.png)

#### 多重性表达式

『 **多重性** multiplicity 』定义了类 A 有多少个实例可以和类 B 的一个实例关联.

![2020-06-23-09-40-22](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-23-09-40-22.png)

#### 🌰 示例: NextGen POS 的领域模型

下图 👇 展示了 POS 系统基于本次迭代的部分领域模型:

![2020-06-23-09-43-25](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-23-09-43-25.png)

### 属性

当 "需求" 中需要概念类的实例记住一些信息时, 就需要引入『 **属性** 』

🌰 例如, 在 "处理销售" 用例中, 票据通常含有 "日期", "时间" 信息. 这些信息都应该作为票据概念类的属性;

![2020-06-23-09-48-19](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-23-09-48-19.png)

- 通常把属性可见性假设为 "私有的 ( `-` )" 所以一般不会显式的写出来;
- `Sale` 中的 `total` 属性可以从 `SalesLineItems` 中的信息计算出来, 所以 `total` 是一个『 **导出属性** 』在名字前加 `/` 符号;

#### 属性的类型

领域模型属性的类型应该是『 **基本类型** 』例如, Boolean, Number, Character, String, Date 之类的;

如果想表达一个类中使用了另一个类, 应该使用『 **关联** 』而不是把概念类作为属性.

![2020-06-23-09-59-45](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-23-09-59-45.png)

软件的 "设计模型" 中, 一个类的属性的数据类型可以是另一个类.

但是, 即使属性的类型是基本类型, 但是它作为『 **外键** 』来将两个类关联起来, 这样也是不行的. **在 "领域模型" 中表示类与类之间关系只能用 "关联" 而不是 "属性"**.

![2020-06-23-10-15-49](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-23-10-15-49.png)

#### 定义新的数据类型

在以下 👇 的这些情况中, 数据值不仅仅是简单的字符串或数字, 所以可以创建新的数据类型:

![2020-06-23-10-04-30](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-23-10-04-30.png)

![2020-06-23-10-11-10](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-23-10-11-10.png)

是否把新创建的数据类型作为一个 "概念类" 表现在领域模型中, 取决于你想让领域模型表达什么, 具体看情况而定.

![2020-06-23-10-06-54](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-23-10-06-54.png)

#### 🌰 示例: NextGen POS

下图 👇 中的属性反映本次迭代的 "处理销售" 用例的 "现金支付场景" 中的信息需求:

![2020-06-23-10-09-58](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-23-10-09-58.png)
![2020-06-23-10-10-07](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-23-10-10-07.png)

## 系统顺序图

通过用例中描述的一系列特定事件, 我们可以绘制 "系统顺序图". 而它是 "操作契约" 和 "软件对象设计" 的重要输入.

![2020-06-23-10-36-28](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-23-10-36-28.png)

### 什么是系统顺序图

用例描述了外部参与者如何与我们希望创建的系统进行交互的. 交互中, 参与者发起了『 **系统事件** system event 』, 系统会通过一些『 **系统操作** system operation 』来对这些事件进行处理.

- 通过 **UML 的顺序图**作为表示法;
- 系统顺序图中, 将系统视为**黑盒**, 它只表现出系统可以通过 "系统操作" 处理参与者发起的 "系统事件", 但是不说如何处理的;

![2020-06-23-10-52-00](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-23-10-52-00.png)

#### 系统事件的命名

- 系统事件的名称应该表达 "**操作的意图**", 而不是具体的实现;
  - `enterItem(itemId)` 要好于 `scan (itemId)`, 因为这个操作的目的是把商品的 ID 输入到系统中, 而具体使用什么设备 ( 扫描仪, 键盘, 语音输入 ... ) 我是不管的;
- 系统事件的名称一般**以 "动词" 开始**:
  - 🌰 增加..., 输入..., 产生..., 请求..., etc.

![2020-06-23-10-45-22](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-23-10-45-22.png)

### 系统顺序图和用例的关系

系统顺序图 SSD 展示的是用例中一个场景的系统事件, 因此它是从对用例的观察中产生的;

![2020-06-23-10-40-28](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-23-10-40-28.png)

## 操作契约

### 什么是操作契约

系统操作是作为黑盒的系统在其公共接口中提供的操作. 参与者触发 "系统事件", 然后通过调用系统中对应的 "系统操作" 来处理这个事件;

![2020-06-23-14-03-35](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-23-14-03-35.png)

有时候我们需要对系统行为进行更为详细和精确的描述.

操作契约使用 "前置条件" 和 "后置条件" 的形式, 描述了系统操作被调用前后, 领域模型里对象的详细状态变化.

在编写完了 SSD 后, 如果觉得系统操作太复杂, 其执行后的结果不明显, 或者在用例中描述的不清楚, 则可以为其构造契约.

![2020-06-23-14-01-33](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-23-14-01-33.png)

### 后置条件

![2020-06-23-14-10-45](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-23-14-10-45.png)
![2020-06-23-14-11-20](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-23-14-11-20.png)

记住, 前置条件和后置条件描述的是领域模型中的对象的状态, 受系统操作所引起的状态变化的 "**观察结果**".

所有, 在编写上应该使用描述状态的语句, 而不是指令式的语句:

![2020-06-23-14-18-26](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-23-14-18-26.png)

### 🌰 示例: NextGen POS 契约

![2020-06-23-14-20-04](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-23-14-20-04.png)
![2020-06-23-14-19-48](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-23-14-19-48.png)

## 逻辑架构 & UML 包图

## 迈向对象设计

## UML 交互图

## UML 类图

## GRASP 基于职责设计对象

## 对可见性进行设计

## 将设计映射为代码

## 测试驱动开发 & 重构
