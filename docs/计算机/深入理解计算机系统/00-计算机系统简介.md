# 计算机系统简介

计算机系统是由硬件和软件组成的, 它们共同工作来运行应用程序.

虽然各种计算机的具体实现各有不同, 但整体概念却都是相似的.

下面 👇 就看一下计算机系统中的各个部分是如何协调工作, 使得这段 C 语言 `hello` 程序能够运行的:

![2020-05-13-10-49-23](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-05-13-10-49-23.png)

## 二进制文件 & 文本文件

上面的这段程序, 被称为『 源代码 』, 即程序员通过文本编辑器创建并保存的文件, 名字叫 `hello.c`:

- 源代码在计算机中其实就是一堆由 `0` 和 `1` 组成的『 位序列 』( 位 `bit`, 又称做 "比特" )
- 8 个位组成一组, 称为『 字节 `byte` 』
- 文本字符在计算机中用字节来表示, 根据文件所采用『 编码格式 』, 每个字符都有其对应的整数值. 整数值会以字节为单位, 转换成二进制格式;
- 编码格式不同, 每个字符对应的整数值也不同;

上面 👆 的 C 语言程序, 用 ASCII 编码格式来表示, 会被翻译成如下字节序列:

![2020-05-13-11-13-02](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-05-13-11-13-02.png)

在计算机中, 程序员写的文本程序就会被翻译成这样的『 字节序列 』被储存文件中.

计算机中所有的信息, 都是由一串比特序列表示的. 根据采用的编码格式不同, 相同的二进制序列会被翻译成不同的表示.

- 编码格式, 以及其他用来解释信息的数据, 被称作『 上下文 』
- 上下文 Context: 用来解释一段信息, 运行一个程序, 所属的额外信息;

---

储存了没有指定编码格式的二进制序列的文件, 叫做『 **二进制文件** 』

指定了编码格式的二进制文件, 叫做『 **文本文件** 』

文本文件本质上也是二进制文件, 这种区分只不过是在逻辑上. 物理上, 它们都是一堆储存在计算机中的二进制序列.

## 源代码 -> 可执行目标文件

程序员写完的程序文本只是给人来看的, 为了能够让程序在计算机中运行, 还需要把源代码翻译成底层的『 机器语言 』指令, 这些指令会按照一种称为『 可执行目标程序 』的格式打好包. 最终, 这个目标程序才能够被计算机真正地加载运行.

以 👆 的 `hello.c` 程序为例, 通过 GCC 编译器, 可以把它翻译成一个可执行目标程序 `hello`. 大致流程如下:

![2020-05-13-19-27-44](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-05-13-19-27-44.png)

✏️ **预处理阶段**:

- 预处理器根据以字符 `#` 开头的命令. 修改原始的代码;
- 🌰 `#include<stdio.h>` 命令告诉预处理器读取系统头文件 `stdio.h` 的内容, 并把它插入到代码中.
- 经过预处理阶段, 原始代码被修改成了新的代码, 通过以 `.i` 作为文件扩展名;

✏️ **编译阶段**:

- 将经过预处理的 C 语言程序, 翻译成汇编语言;
- 编译器将 `hello.i` 翻译成汇编语言程序 `hello.s`;

![2020-05-13-19-38-15](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-05-13-19-38-15.png)

✏️ **汇编阶段**:

- 汇编器将 `hello.s` 翻译成机器语言指令;
- 并把这些指令打包成一种称作『 可重定位目标程序 』的格式;
- 并将结果保存在文件 `hello.o` 中;

✏️ **链接阶段**:

- 在 `hello` 源代码中调用了 `printf` 函数, 它是每个 C 编译器都提供的标准 C 库中的一个函数;
- 这种函数都有已经单独预编译好了的目标文件;
- 链接器负责把这些预编译好的文件合并到之前的 `hello.o` 目标文件中;
- 最终得到了 `hello` 文件, 这是一个『 可执行目标文件 』, 它可以被加载到内存中, 让计算机系统去执行;

## 计算机的硬件组成

下面 👇 简单介绍一下计算机系统的典型硬件组织:

![2020-05-13-19-54-36](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-05-13-19-54-36.png)

✏️ **总线**;

- 贯穿整个系统的一组电子管道, 称作『 总线 』;
- 它以字节为单位, 负责在各个部件之间传输信息;
- 现在大多数的计算机, 总线能传输的字节数量是 4 个 (32 位) 或 8 个 (64 位);

✏️ **I/O 设备**:

- I/O 设备是计算机系统与外部进行联系的通道;
- 🌰 例如: 鼠标, 键盘, 显示器, USB 移动储存设备, 磁盘驱动器, 等;
- 每个 I/O 设备都通过『 控制器 』或『 适配器 』与 I/O 总线相连;
  - 控制器: I/O 设备本身, 或计算机主板上的芯片组;
  - 适配器: 一块插在主板插槽上的卡;
- 无论是控制器, 还是适配器, 它们的主要功能都是在 I/O 设备与 I/O 总线之间传递信息;

✏️ **主存**:

- 主存是一个临时储存设备;
- 在处理器执行程序时, 用于存放程序和程序处理的数据;
- 物理上说, 主存是由一组动态随机存取储存器芯片组成的;
- 逻辑上说, 储存器是一个线性的字节数组, 每个字节都有其唯一的地址;

✏️ **处理器**:

- 中央处理单元 CPU, 简称处理器, 是执行储存在主存中指令的引擎;
- 处理器的核心是一个存储设备, 被称为『 程序计数器 Program Counter 』;
- 在计算机执行程序时, 程序计数器总是指向主存中的某条机器语言指令, 即含有该条这令的内存地址;
- 处理器会不断地执行程序计数器所指向的指令, 然后更新程序计数器, 让其指向下一条指令;

## 运行 hello 程序

在 `hello.c` 源代码已经被编译成可执行目标程序 `hello` 之后, 我们在命令行中输入 `./hello` 来运行程序.

- 在敲击回车之后, shell 程序会将 `hello` 目标程序从磁盘中复制到主存里;
- 之后处理器就可以开始一行行地执行主存中的机器语言指令了;
- 程序执行时, `hello world` 字符串通过总线, 从主存复制到寄存器, 再复制到显示设备上, 最后被显示在屏幕中;

![2020-05-13-20-24-34](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-05-13-20-24-34.png)

![2020-05-13-20-24-43](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-05-13-20-24-43.png)

## 高速缓存

在计算机中, 花费了大量时间把数据从一个地方移动到另外一个地方. 这使得计算机的性能被减慢.

较大的存储设备要比较小的存储设备运行得慢. CPU 从寄存器中读取数据, 要比从内存中读取数据快很多很多倍.

为了让数据传输更高效, 系统设计者使用『 **高速缓存存储器 cache memory** 』作为暂时的数据存储区域, 存放 CPU 近期可能会频繁需要的信息. 这要比每次都从内存获取数据要快得多.

![2020-05-13-20-53-01](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-05-13-20-53-01.png)

事实上, 计算机系统中的存储设备被组织成了一个存储器层次结构:

- 从上至下, 访问速度越来越慢, 容量越来越大, 每字节的造价越来越便宜;
- 存储器层次结构的主要思想是上一层的存储器作为低一层存储器的高速缓存;

![2020-05-13-20-54-35](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-05-13-20-54-35.png)

## 操作系统

操作系统被看成是应用程序和硬件之间插入的一层软件:

- 所有应用程序对硬件的操作都必须通过操作系统传达;
- 操作系统能够防止硬件被应用程序滥用;
- 操作系统向应用程序提供了简单一致的机制, 来控制复杂, 而且彼此大不相同的底层硬件设备;
- 操作系统通过几个基本的抽象概念来实现这些功能:
  - 进程, 线程;
  - 虚拟内存;
  - 文件;

✏️ **进程 & 线程**:

- 『 **进程** 』是操作系统对一个正在运行的程序的一种抽象;
- 即使是单核 CPU, 也可以同时运行多个进程;
- 这是通过『 并发 』来实现的, 也就是进程与进程之间是交错执行的, 同一时间只有一个进程被运行;
- 操作系统实现这种进程交错执行的机制被称为『 上下文切换 』
- 操作系统保持跟踪进程运行所需的所有信息, 这些信息就是上下文;
  - 🌰 各个寄存器中的值, 主存的内容, 等等;

![2020-05-13-21-07-54](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-05-13-21-07-54.png)

- 一个进程内部可以包含多个称为『 **线程** 』的执行单元;
- 每个线程都运行在所属进程的上下文中, 并共享数据;
- 多线程比多进程之间更容易共享数据, 在执行『 并行 』任务时更高效;

✏️ **虚拟内存**:

- 虚拟内存是一个抽象概念, 它给每个进程提供一个假象, 即每个进程都独占地使用主存;
- 每个进程看到的内存都是一致的, 被称为『 虚拟地址空间 』;
- 虚拟地址空间由很多个区域构成:
  - **程序代码和数据**: 用户进程定义的程序代码和数据;
  - **运行时堆**: 存放程序运行时创建的数据;
  - **共享库**: 存放像 C 标准库之类的共享库代码和数据;
  - **用户栈**: 保存函数调用关系的栈结构;
  - **内核虚拟内存**: 虚拟地址空间顶部区域, 保留给操作系统使用, 不允许应用程序读写这个区域的内容;

![2020-05-13-21-11-26](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-05-13-21-11-26.png)

✏️ **文件**:

- 文件本质上就是字节序列;
- 每个 I/O 设备都可以看成是文件;
- 系统中的所有输入输出, 都是操作系统通过调用系统函数读写文件来实现的;
- 通过操作系统, 程序员不需要知道具体 I/O 硬件的物理实现, 只需要调用操作系统提供的读写函数, 就可以使用这些硬件设备;
- 这也使得同一个程序可以在使用不同硬件设备的机器上运行;

## 网络通信

计算机可以通过网络连接在一起. 网络也可以视为是一个 I/O 设备.

计算机将主存中的数据传递到网络适配器上, 然后再通过网络流通到另一个计算机上面去.

![2020-05-13-21-43-30](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-05-13-21-43-30.png)
