# 模块机制介绍

## 什么是模块?

以编程角度来说, "模块" 指的是能够提供一定功能或数据的程序语句集合.  模块具备和外部联系的接口 (其他模块或程序调用该模块的方式)

在 Node.js 中, 每个文件就被视为一个模块.  这个文件可能是 JavaScript 编写的文件、JSON 或者用 C/C++ 编译的二进制文件.  通过对外接口来向外部暴露功能或者数据, 模块之间可以互相调用.  

## 为什么要用模块?

### 传统开发模式面临的问题

随着开发复杂度的提升, 将代码都写在一处的传统开发方式, 显现出了很多问题:

* **很容易出现代码重复**.  开发人员很容易将一个功能的代码重复地写了好多遍.  这导致了如果日后功能需求出现了变更, 就要有多处代码需要被更改.  随着应用规模的增大, 代码会变得难以维护. 
* **难以确保代码质量**.  所有代码都混在一起, 实现不同功能的代码全都被写在一个文件中, 使得对于单个功能的独立测试变得困难.  
* **难以查错**.  所有代码都混在一起, 程序运行出现 BUG 了, 很难快速定位.  
* **性能浪费**.  因为代码都写在一个文件中, 在只调用文件中一段代码的时候, 也会导致整个文件都加载一遍.  这会使很多根本用不到的代码对性能造成浪费.
* **难以多人写协作**.  所有代码都放在一个文件中, 使得多人协作变得困难.  开发人员难以确认其他人做了什么修改, 添加了什么东西.  很容易一个人出了错误, 导致整个程序崩溃.
* **等等**...

### 什么是模块化开发

通过使用模块机制, 我们可以把一个复杂程序的各个功能拆分, 分别封装到不同的模块.  每个模块职责单一 (各管一件事, 之间没交集) 通过开发新模块, 和对已有模块的复用来实现各种功能.  这种开发方式被称为 "模块化开发".

### 模块化开发的好处

应用模块化开发, 使得各个功能都封装在独立的文件中, 分而治之, 互不干扰.  使得代码易于维护和复用.  

## CommonJS

Node.js 参照 CommonJS 标准实现了模块机制.  CommonJS 是一套代码规范, 目的是为了构建 JavaScript 在浏览器之外的生态系统 (服务器端, 桌面端).  JavaScript 诞生之初只是为了写网页小脚本, 并不作为开发大型复杂应用的语言, 其自身有很多不足.  并且, 官方规范 (ECMAScript) 制定的时间较早, 涵盖范围较小, 对于后端开发而言, 例如文件系统, I/O 流, 模块系统, 等等方面都没有相应的标准.  基于种种的不足, CommonJS 规范致力于弥补 JavaScript 没有标准的缺陷, 让 JavaScript 有能力去开发复杂应用, 同时具备跨平台能力. 

## 示例

``` js
const http = require('http');

function myNodeServer(req, res){
    res.writeHead(200, {'Content-type':'text/plain'});
    res.write('Hello World'); 
    res.end();
}

http.createServer(myNodeServer).listen(3000); //监听 3000 端口

console.log('Server is running!'); 
```

上面代码中, 开头通过 `require` 方法引入了 Node.js 自带的 `http` 模块.  并用此模块实现了一个 HTTP 服务器.

## 模块分类

前文说, 在 Node.js 中, 每个文件就被视为一个模块.  这个文件可能是 JavaScript 编写的文件、JSON 或者用 C/C++ 编译的二进制文件.  

### 核心(原生)模块

### 文件模块

## 使用模块 

在了解了什么是模块之后, 让我们来看看如何在 Node.js 中实际应用模块机制.  在使用上, 可以很简单的分为三个方面: 创建, 导出, 引入.  先创建一个模块, 然后导出功能或数据, 模块之间可以互相引入导出的内容.  

Node.js 提供了 `exports` 和 `require` 两个对象，其中 `exports` 是模块用于导出的接口, `require` 用于从外部引入另一个模块, 即获取模块的 `exports` 对象.

### 创建 & 导出模块

先让我们来看看如何创建并把模块的内容导出.  在 Node.js 中, 一个文件就是一个模块.  创建模块的方法就是创建一个文件.  

通过 `exports` 对象来指定一个模块的导出内容. 

示例: 

``` js
// 文件名: nameModule.js
var name = 'Garrik';

exports.setName = function(newName) {
    name = newName;
}

exports.getName = function() {
    return name;
}
```

在以上示例中, nameModule.js 文件通过 `exports` 对象将 `setName` 和 `getName` 作为模块的访问接口.  其他的模块可以引入导出的 `exports` 对象, 直接访问 `exports` 对象的成员函数.

### module.exports & exports

在使用 `exports` 对象导出内容时, 所有作为对外访问接口的属性和方法都是定义在 `exports` 属性上的.  上面的例子中 `setName` 和 `getName` 方法都直接定义在 `exports` 对象上.  那如果想直接导出一个对象, 或者基础类型值可不可以呢?

可能有人会想可不可以这样写:

``` js
var name = 'Garrik';

exports = name;
```

如果你试一下的话会发现, 最后引入的是一个空对象, 而不是你定义在 `exports` 上的东西.

在使用 `exports` 的时候只能往这个对象里添加新的属性和方法, 而不能对其直接赋值.  如果想直接导出一个对象, 或者基础类型值要使用 `module.exports` 对象.  例如上面例子就可以改写成:

``` js
// 文件名: nameModule.js
var name = 'Garrik';

module.exports = {
  setName: function(newName) {
    name = newName;
  }, 
  getName: function() {
    return name;
  }
} 
```

这样写的话, 就导出了一整个对象, `setName` 和 `getName` 方法是这个对象的成员函数.  而不是之前的 `exports` 对象了.

除此之外 `module.exports` 还可以直接导出基础类型值:

``` js
// 文件名: numMoule.js

var num = 123456;

module.exports = num;
```

``` js
// 文件名: showNum.js
var getNum = require('./numModule.js'); // showNum.js 和 numModule.js 在同一目录下

console.log(getNum); // 结果: 123456
```

这种方式下, 导出的就直接是基础类型的值.

---

可能还是很多人在疑惑 `exports` 和 `module.exports` 区别和关系.

上面我说, 一个文件被另一个模块引入时, 会被做一些处理.  文件中代码并不被 Node 执行, 而是被打包进一个函数中, 然后 Node 执行这个函数.  打包函数会被传入 `exports`，`require`，`module`，`__filename`，`__dirname` 这五个参数.  所有的这些参数都在 Node 执行函数时赋值, 并且只在当前的函数作用域中有效.  打包函数执行到最后, 返回 `module.exports` 对象.

其中, `exports` 是 `module.exports` 的引用, `module` 对象代表被打包进去的代码本身.  `module` 的 `exports` 对象用于指定一个模块的导出内容.  

在模块中定义外部可访问接口的时候, 有两个方法:

``` js
exports.name = 'Garrik';
```

``` js
module.exports = {name: 'Garrik'};
```

在使用 `exports` 的时候只能往这个对象里添加新的属性和方法, 而不能对其直接赋值.  因为直接赋值会打破其对 `module.exports` 的引用.  

``` js
// 这是可以的:
exports.name = 'Garrik';
exports.gender = 'Male';

// 这是不可以的:
exports = {name: 'Garrik', gender: 'Male'};

// 应该用 module.exports:
module.exports = {name: 'Garrik', gender: 'Male'}
```

如果想直接导出一个对象, 或基本类型值, 应该使用 `module.exports`.

``` js
// 导出函数
module.exports = function(num) {
    return num + 1;
};

// 导出基本类型值
module.exports = 123;
```

### require

在 Node.js 中, 通过 `require` 函数来引入外界模块导出的内容.  `require` 函数接受一个字符串作为路径参数, 函数根据这个字符串参数来进行模块查找. 找到后会返回目标模块导出的 `exports` 对象.

示例: 

``` js
// 文件名: showNameModule.js
var nameModule = require('./nameModule.js');

console.log(nameModule.getName()); 
// 显示: Garrik

nameModule.setName('Xiang');

console.log(nameModule.getName());
// 显示: Xiang
```

上面示例中, 通过 `require` 引入了当前目录下 nameModule.js 导出的 `exports` 对象, 并让一个本地变量指向引入模块的 `exports` 对象.  之后在 showNameModule.js 文件中就可以使用 `getName` 和 `setName` 这两个方法了.

## 包 & NPM 包管理器

### 什么是包

### 什么是包管理器

### require 的路径参数

在用 `require` 引入模块时, 路径参数可能有下面三种形式:
  * 相对路径: `./` 开头 或 `../` 开头
  * 绝对路径: `/` 开头
  * 模块名 (例如: `http`, `fs`, `url`)

根据参数不同, 加载方式也有区别.

如果我引入了一个 haha 模块，并没有指定它的路径的话：

``` js
var haha = require('haha');
```



#### 无路径, 直接模块名:

#### 绝对路径, 或相对路径

### 模块查找策略

前面说 `require` 函数接受一个字符串作为参数, 函数根据这个字符串参数进行模块查找.  但其具体的内部加载步骤是怎么样的呢?


![nodejs-require](https://i.imgur.com/YSRahKr.jpg)


前面提到了, Node.js 中模块可以分为 原生模块 和 文件模块.  根据模块类型的不同, 加载的优先级也不同.

#### 从文件模块缓存中加载

会先从文件模块的缓存中加载已经存在的模块.

#### 从原生模块加载

原生模块的优先级仅次于文件模块缓存的优先级.  `require` 方法在解析文件名之后，优先检查模块是否在原生模块列表中。

#### 从文件加载

当文件模块缓存中不存在，而且不是原生模块的时候，Node.js 会解析 `require` 方法传入的参数，并从文件系统中加载实际的文件

## 文件被 require 后发生了什么

从 [lib/module.js](https://github.com/nodejs/node/blob/v5.x/lib/module.js) 代码中分析一个文件被 `require` 后发生了什么:

### require 函数被调用

``` js
// Loads a module at the given file path. Returns that module's
// `exports` property.
Module.prototype.require = function(path) {
  assert(path, 'missing path');
  assert(typeof path === 'string', 'path must be a string');
  return Module._load(path, this, /* isMain */ false);
};
```

`require` 函数在执行时会调用 `Module._load` 函数.

### Module._load 函数被调用

`Module._load` 函数完整代码:

``` js
// Check the cache for the requested file. 
// 1. If a module already exists in the cache: return its exports object.
// 2. If the module is native: call `NativeModule.require()` with the
//    filename and return the result.
// 3. Otherwise, create a new module for the file and save it to the cache.
//    Then have it load  the file contents before returning its exports
//    object.
Module._load = function(request, parent, isMain) {
  if (parent) {
    debug('Module._load REQUEST %s parent: %s', request, parent.id);
  }

  var filename = Module._resolveFilename(request, parent);

  var cachedModule = Module._cache[filename];
  if (cachedModule) {
    return cachedModule.exports;
  }

  if (NativeModule.nonInternalExists(filename)) {
    debug('load native module %s', request);
    return NativeModule.require(filename);
  }

  var module = new Module(filename, parent);

  if (isMain) {
    process.mainModule = module;
    module.id = '.';
  }

  Module._cache[filename] = module;

  var hadException = true;

  try {
    module.load(filename);
    hadException = false;
  } finally {
    if (hadException) {
      delete Module._cache[filename];
    }
  }

  return module.exports;
};
```

下面来一步步的分析 `Module._load` 函数内都发生了什么.

### 获取模块完整路径

`Module._load` 函数先调用内部方法 `Module._resolveFilename`.

`Module._resolveFilename` 函数完整代码:

``` js
Module._resolveFilename = function(request, parent) {
  if (NativeModule.nonInternalExists(request)) {
    return request;
  }

  var resolvedModule = Module._resolveLookupPaths(request, parent);
  var id = resolvedModule[0];
  var paths = resolvedModule[1];

  // look up the filename first, since that's the cache key.
  debug('looking for %j in %j', id, paths);

  var filename = Module._findPath(request, paths);
  if (!filename) {
    var err = new Error("Cannot find module '" + request + "'");
    err.code = 'MODULE_NOT_FOUND';
    throw err;
  }
  return filename;
};
```

可以看到 `Module._resolveFilename` 函数内进行了一些参数预处理后，最终会调用 `Module._findPath` 方法，来得到需被导入模块的完整路径

`Module._findPath` 函数完整代码:

``` js
Module._findPath = function(request, paths) {
  if (path.isAbsolute(request)) {
    paths = [''];
  }

  // 优先检查缓存
  var cacheKey = JSON.stringify({request: request, paths: paths});
  if (Module._pathCache[cacheKey]) {
    return Module._pathCache[cacheKey];
  }

  const exts = Object.keys(Module._extensions);
  const trailingSlash = request.slice(-1) === '/';

  // For each path
  for (var i = 0, PL = paths.length; i < PL; i++) {
    // Don't search further if path doesn't exist
    if (paths[i] && stat(paths[i]) < 1) continue;
    var basePath = path.resolve(paths[i], request);
    var filename;

    if (!trailingSlash) {
      const rc = stat(basePath);
      if (rc === 0) {  // File. 文件
        filename = toRealPath(basePath);
      } else if (rc === 1) {  // Directory. 目录
        filename = tryPackage(basePath, exts);
      }

      if (!filename) {
        // try it with each of the extensions 
        // 带上 .js .json .node 后缀进行尝试
        filename = tryExtensions(basePath, exts);
      }
    }

    if (!filename) {
      filename = tryPackage(basePath, exts);
    }

    if (!filename) {
      // try it with each of the extensions at "index"
      // // 尝试 index.js index.json index.node
      filename = tryExtensions(path.resolve(basePath, 'index'), exts);
    }

    if (filename) {
      // Warn once if '.' resolved outside the module dir
      if (request === '.' && i > 0) {
        warned = internalUtil.printDeprecationMessage(
          'warning: require(\'.\') resolved outside the package ' +
          'directory. This functionality is deprecated and will be removed ' +
          'soon.', warned);
      }

      Module._pathCache[cacheKey] = filename;
      return filename;
    }
  }
  return false;
};
```

`tryPackage` 完整代码:

``` js
function tryPackage(requestPath, exts) {
  // 获取 package.json 中 main 属性的值
  var pkg = readPackage(requestPath);

  if (!pkg) return false;

  var filename = path.resolve(requestPath, pkg);
  return tryFile(filename) || tryExtensions(filename, exts) ||
         tryExtensions(path.resolve(filename, 'index'), exts);
}
```

`Module._findPath` 函数中的路径分析十分清晰:

* 若模块的路径不以 `/` 结尾，则先检查该路径是否真实存在：
  * 若存在且为一个文件，则直接返回文件路径作为结果。
  * 若存在且为一个目录，则尝试读取该目录下的 `package.json` 中 `main` 属性所指向的文件路径。
    * 判断该文件路径是否存在，若存在，则直接作为结果返回。
    * 尝试在该路径后依次加上 `.js` ， `.json` 和 `.node` 后缀，判断是否存在，若存在则返回加上后缀后的路径。
    * 尝试在该路径后依次加上 `index.js` ， `index.json` 和 `index.node`，判断是否存在，若存在则返回拼接后的路径。
  * 若仍未返回，则为指定的模块路径依次加上 `.js`, `.json` 和 `.node` 后缀，判断是否存在，若存在则返回加上后缀后的路径。
    * 若模块以 `/` 结尾，则尝试读取该目录下的 `package.json` 中 `main` 属性所指向的文件路径。
      * 判断该文件路径是否存在，若存在，则直接作为结果返回。
      * 尝试在该路径后依次加上 .`js`, .`json` 和 `.node` 后缀，判断是否存在，若存在则返回加上后缀后的路径。
      * 尝试在该路径后依次加上 `index.js`, `index.json` 和 `index.node`，判断是否存在，若存在则返回拼接后的路径。
  * 若仍未返回，则为指定的模块路径依次加上 `index.js`, `index.json` 和 `index.node`，判断是否存在，若存在则返回拼接后的路径。
