# 模块机制

在开发相对复杂的程序时, 通过使用模块机制, 我们可以把一个复杂程序的各个功能拆分, 分别封装到不同的文件. 在需要的时候引入相关的模块. 这样做可以让代码的可读性, 复用性, 和易维护性够变得更高.  

Node.js 参照 CommonJS 标准实现了模块机制.  在 Node.js 中, 每个文件就被视为一个模块.  这个文件可能是 JavaScript 编写的文件、JSON 或者用 C/C++ 编译的二进制文件.  在上一篇结尾的 Node 代码实例中, `http` 就是一个 Node 自带的核心模块, 用以实现 HTTP 协议.

> CommonJS 规范: 因为 JavaScript 诞生之初只是为了写网页小脚本, 并不作为开发大型复杂应用的语言, 其自身有很多不足.  由于官方规范 (ECMAScript) 制定的时间较早, 涵盖范围较小, 对于后端开发而言, 例如文件系统, I/O 流, 模块系统, 等等方面都没有相应的标准.  CommonJS 规范让 JavaScript 弥补了没有标准的缺陷, 让 JavaScript 有能力去开发复杂应用, 同时具备了跨平台能力. 

## 模块类型

 核心模块

## 创建 & 导出模块

在了解了什么是模块之后, 让我们来看看如何创建并导出模块.  在 Node.js 中, 一个文件就是一个模块.  创建模块的方法就是创建一个文件.  我们要关注的问题是怎么样把这个模块的内容导出, 以让其他文件能够获取到. 在这一篇里我只关注 JavaScript 编写的模块.

在 Node.js 中, 通过 `exports` 对象来指定一个模块的导出内容.

示例: 

``` js
// 文件名: nameModule.js
var name = 'Garrik';

exports.setName = function(newName) {
    name = newName;
}

exports.getName = function() {
    return name;
}
```

在以上示例中, nameModule.js 文件通过 `exports` 对象导出了 `setName` 和 `getName` 两个方法.  其他的模块可以通过引入这两个方法来操作 nameModule.js 文件中的 `name` 变量.

## 引入模块

在 Node.js 中, 通过 `require` 方法来引入外界模块导出的内容.

示例: 

``` js
// 文件名: showNameModule.js
var nameModule = require('./nameModule');

console.log(nameModule.getName()); 
// 显示: Garrik

nameModule.setName('Xiang');

console.log(nameModule.getName());
// 显示: Xiang
```

上面示例中, 通过 `require` 引入 nameModule.js 导出的对象 (后缀 `.js` 可以省略).  我们就可以在 showNameModule.js 文件中使用 `getName` 和 `setName` 这两个方法了.




### 路径解析

## 包 & 包管理器