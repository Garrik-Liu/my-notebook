# 使用模板引擎

在这一节, 我们尝试用 EJS 模板引擎让 Node.js 渲染动态页面

## 什么是模板引擎? 为什么要用?

在说什么是『 模板引擎 』之前请先思考一个问题: 我们之前响应给客户端的都是静态 HTML 页面, 也就是内容都已经写好的页面, 浏览器只要加载渲染就行了.  但是平时我们看到的网页大多内容都是变动的, 根据数据的不同内容也随之改变.  很明显不能靠人力去实时更新 HTML 文件.  那么该怎么让 HTML 页面去动态改变内容呢 ?

你应该能想到在前端用 JavaScript 代码去获取数据, 然后渲染页面.  这的确是个好办法, 但也有两个明显缺陷是:
* 因为浏览器先加载了一个内容不完全的页面, 然后用 JavaScript 获取数据渲染页面内容.  也就是当搜索引擎想抓取页面解析 HTML 内容的时候, JavaScript 代码还未被调用.  这会影响到 SEO
* 页面在刚刚加载之后, 用户还要等一个 JavaScript 代码执行时间, 一个数据请求时间, 一个 DOM 渲染时间, 这增加的等待时间, 可能让用户体验打折扣.


『 模板引擎 』让表现层 (HTML 文档) 和业务数据分离.  通过特定的语法, 来动态地用数据渲染出 HTML 文档.

通过使用模板引擎就可以解决刚刚提到的问题.  HTML 文档在服务器用模板引擎根据数据动态地渲染好.  然后直接将渲染完整的页面响应给客户端.  浏览器加载完页面内容可以立即展示, 也可以减少显示页面所花的时间.

## EJS 模板引擎介绍

[EJS 文档](http://ejs.co/)

在这一篇里, 我要介绍的是 『 EJS 模板引擎 』它是 "Embedded JavaScript" 的缩写, 通过在 HTML 文件内嵌入 JavaScript 代码来进行 HTML 模板渲染。 

Node.js 支持模板引擎有非常多, 之所以选择讲 EJS, 是因为个人觉得它上手最快, 可以让你在不破坏 HTML 文档结构的情况下, 直接在标签内书写 JavaScript 代码.  对于前端开发人员来说学习成本很低.

---

### EJS 模板语法

简单来说, EJS 用起来非常简单, 你只要像之前写 HTML 代码一样去写就好了.  只要最后文件后缀名改成 `.ejs` 那这就是一个 EJS 模板文件了.  在模板中, `<% %>` 括起来的内容会作为 Javascript 来编译, `<%= %>` 和 `<%- %>`将括起来的变量中的数据渲染到模板, 区别是用 `<%=...%>` 输出变量值，变量值若包含 `'<'` `'>'` `'&'` 等字符会被转义, 而 `<%-...%>` 不会, 也就是变量值是什么就输出什么.

当然除了上面讲的标签之外还有其他的, 但这里我就不多做介绍了, 大家可以自行查阅[文档](http://ejs.co/).

光说文字, 大家理解的不清晰, 我先给两个示例:

下面的模板会将 `users` 数组中的值用 `for` 循环一个个地渲染到 `<li>` 元素里.  

``` html
<body>
<ul>
<% for(var i = 0; i < users.length; i++) { %>
<% var user = users[i]; %>
    <li><%= user %></li>
<% } %>
</ul>
</body>
```

假如说 `users = ['郭建国', '刘幸福', '张富强', '王大宝', '李钢蛋']` 那么渲染出来的结果应该如下:

![Screen Shot 2018-10-10 at 1.50.47 PM](https://i.imgur.com/utKilb7.png)

让我们再来看另一个例子:

``` html
<body>
<% if (state === 'danger') { %>
     <p>危险区域, 请勿进入</p>
<% } else if (state === 'warning') { %>
    <p>警告, 你即将进入危险区域</p>
<% } else { %>
    <p>状态安全</p>
<% } %>
</body>
```

如果我传入变量 `state = 'danger'`, 页面应该如下图:

![Screen Shot 2018-10-10 at 2.54.47 PM](https://i.imgur.com/1XeqK29.png)


### 在 Node.js 中渲染页面

前面我们写了 EJS 的模板代码, 但我们还需要让服务器根据传入数据渲染出 HTML 页面.  

首先, 还是要安装 ejs 模块:

``` bash
npm install ejs --save
```

之后我们根据数据和模板来渲染页面.  ejs 模块提供多种方法实现, 但是我们这里先只介绍 `ejs.renderFile` 函数.  其余的大家可以自行查阅文档.

``` js
ejs.renderFile(filename, data, options, function(err, str){});
```

* `filename` 参数是目标文件路径
* `data` 是你要传进模板的数据对象
*  `option` 是配置选项, 可以省略, 具体内容查看文档
* `function(err, str){}` 是回调函数.  
  * `err` 是错误信息, 没有错误时为 `null`.  
  * `str` 是模板生成的 HTML 内容.

前面的第一个 EJS 模板例子在服务器的调用代码为:

``` js
// 搭建 HTTP 服务器
var server = http.createServer(function(req, res) {
    var users = ['郭建国', '刘幸福', '张富强', '王大宝', '李钢蛋'];

    ejs.renderFile('./index.ejs', { users: users }, function(err, str) {
        if (err) {
            console.log(err);
        } else {
            res.writeHead(200, { 'Content-Type': 'text/html' });
            res.write(str);
            res.end();
        }
    })
});
```

## include 指令

有很多时候一个网站的不同页面里有一些部分是相同的, 比如下面这些例子:

![Screen Shot 2018-10-12 at 12.12.15 PM](https://i.imgur.com/9blKMP0.png)

---

![Screen Shot 2018-10-12 at 12.12.39 PM](https://i.imgur.com/xFseWtj.png)

---

![Screen Shot 2018-10-12 at 12.13.00 PM](https://i.imgur.com/kuesrvg.png)

这些内容在网站中的不同页面里重复出现.  如果在每一个 HTML 文件里都重新写一遍, 很明显是低效率地 "笨" 行为.

在 EJS 模板中, 通过 `include` 指令可以将其他的模板片段引入到当前模板.

例如，如果我有 `"./index.ejs"` 和 `"./header.ejs"` 两个模板文件，我可以通过 `<%- include('./header'); %>` 代码让 `header.ejs` 被 `index.ejs` 引入.

大多数情况下, 我们需要使用能够输出**原始内容**的标签 `<%-` 在 `include` 指令上，避免对输出的 HTML 代码做转义处理。

---

现在来让我们看一个实例.  假如我要做一个个人介绍网页, 它包含: **关于我**, **项目介绍**, **个人博客**, 三个页面.

每个页面都包含一个代码相同的 `header` 元素:

``` html
<header>
    <a href="/">我的网站</a>
    <nav>
        <li><a href="aboutme">关于我</a></li>
        <li><a href="projects">项目介绍</a></li>
        <li><a href="blog">个人博客</a></li>
    </nav>
</header>
```

那么我们就可以把这段代码提取出来, 单独作为一个模板片段, 取名 `common-header.ejs
`

之后在各个页面中引入:

``` html
<body>
    <%- include('./templates/common-header.ejs'); %>
    <h1>关于我</h1>
</body>
```

为了管理方便, 我把所有的 EJS 模板放在了 `views` 目录, 把模板片段放在了 `views` 目录下的 `templates` 目录:

![Screen Shot 2018-10-12 at 12.58.15 PM](https://i.imgur.com/82n7Srg.png)

HTTP 服务器路由代码如下:

``` js
// 搭建 HTTP 服务器
var server = http.createServer(function(req, res) {
    var urlObj = url.parse(req.url, true);
    var pathname = urlObj.pathname;

    switch (pathname) {
        case '':
        case '/':
        case '/aboutme':
            ejs.renderFile('./views/aboutme.ejs', {}, function(err, str) {
                res.writeHead(200, { "Content-Type": "text/html" });
                res.write(str);
                res.end();
            });
            break;
        case '/blog':
            ejs.renderFile('./views/blog.ejs', {}, function(err, str) {
                res.writeHead(200, { "Content-Type": "text/html" });
                res.write(str);
                res.end();
            });
            break;
        case '/projects':
            ejs.renderFile('./views/projects.ejs', {}, function(err, str) {
                res.writeHead(200, { "Content-Type": "text/html" });
                res.write(str);
                res.end();
            });
            break;
        default:
            ejs.renderFile('./views/404.ejs', {}, function(err, str) {
                res.writeHead(404, { "Content-Type": "text/html" });
                res.write(str);
                res.end();
            });
            break;
    }
});
```

服务器运行起来, 在浏览器里访问网站, 效果如下:

![2018-10-12 13_01_19](https://i.imgur.com/Y4p02E1.gif)

在每个页面上, `common-header.ejs` 模板片段都被引入了.  代码的复用性, 简洁性都得到了提高.