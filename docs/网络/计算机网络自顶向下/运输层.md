# 运输层

## 运输层服务

- 网络层提供了主机之间的逻辑通信, 运输层为运行在不同主机上的进程提供了进程间的逻辑通信;
  - 对于应用程序来说, 把报文交给运输层就可以与其他主机上的进程进行通信;
  - 而数据实际是由更下层的链路层和物理层进行传输的, 但是对于应用程序来说, 它们并不在乎数据究竟是谁传输的;
- 运输层协议只工作在端系统中, 它们把来自进程的报文移动到网络层;
  - 像应用层一样, 运输层也不管报文段在网络层是被如何传输的;
  - 它们只知道网络层可以把数据送到另外一个主机上;
- 运输层存在多种运输层协议, 每种协议为应用程序提供不同的服务:
  - TCP: 可靠的, 面向连接的服务;
  - UDP: 不可靠的, 无连接的服务;
- 根据应用程序业务上的需求, 开发者选择合适的运输层协议;

## 多路复用 & 多路分解

- 在主机中, 可能同时运行着多个应用程序, 每个应用都有一个『 进程 』, 同时一个进程对应着一个或多个『 套接字 socket 』. 通过『 套接字 』应用程序获得『 运输层 』传来的数据, 同时还能够向『 运输层 』传入数据;
- 主机上有很多的套接字, 为了让『 运输层 』能够区分它们. 『 套接字 』需要有唯一标示. 主机上可以为不同应用的进程分配独享的『 端口号 』, 进程对应的『 套接字 』也使用这个端口号作为自己的唯一标识;
- 在主机上, 『 运输层 』从不同的套接字中收集报文, 并在报文上加上运输层的『 首部信息 』从而生成报文段, 再把报文段向下传递到『 网络层 』, 这个过程叫做『 **多路复用** multiplexing 』
  - 其中有『 首部字段 』是用来指示该报文段所需交付到的套接字;
  - 『 **源端口号字段** source port number field 』
  - 『 **目的端口号字段** destination port number field 』
- 在接收端,『 运输层 』检查接收到的『 报文段 』的首部信息, 找到对应字段指示出的『 目的端口号 』然后把报文段传递给以这个端口号作为标识的套接字. 这个过程称为『 **多路分解** demultiplexing 』
- 『 源端口号字段 』对于『 接收端 』的作用是, 当接收端需要向发送端发送『 响应 』时, 『 源端口号字段 』就变成了响应报文段中的『 目的端口号字段 』

![2020-06-03-11-42-45](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-03-11-42-45.png)

::: warning 端口的范围

:::

### 无连接的多路复用 & 多路分解

假设使用 UDP 协议作为运输层的协议, 创建套接字时, 我们可以选择让运输层自动给其分配一个端口, 也可以自己指定一个端口;

- 一般来说, 客户端应用, 让运输层自动分配端口;
- 服务端应用, 开发者自己制定端口;

**UDP 套接字的标识**:

- 一个 UDP 套接字是由一个『 **二元组** 』来进行标识的;
- 该二元组包含一个『 目的 IP 地址 』和一个『 目的端口号 』
- 如果两个 UDP 报文段来自于不同的主机, 它们有不同的『 源 IP 地址/源端口号 』, 但是具有相同的『 目的 IP 地址 』和『 目的端口号 』, 那么这两个报文段也会被传向同一个『 目的套接字 』, 然后被定向到同一个『 目的进程 』;

下面 👇 通过一个例子精确地描述 **UDP 的复用与分解**:

- 假定在主机 A 中的一个进程具有 UDP 端口 19157，它要发送一个应用程序数据块给位于主机 B 中的另一进程，该进程具有 UDP 端口 46428;
- 主机 A 中的『 运输层 』创建一个『 运输层 』报文段，其中包括应用层的报文和『 运输层 』的首部字段:
  - 源端口号字段: 19157;
  - 目的端口号: 46428;
- 『 运输层 』将得到的报文段传递到网络层。『 网络层 』将该报文段封装到一个 IP 数据报中，并尽力而为地将报文段交付给接收主机;
- 如果该报文段到达接收主机 B，接收主机『 运输层 』检查到该报文段中的『 目的端口号 』 46428, 并将该报文段交付给端口号 46428 所标识的套接字;
- B 需要回发一个报文段给 A 时，B 将 A 传送来的报文段中的『 源端口号 』中作为响应报文段的『 目的端口号 』;

![2020-06-03-15-39-06](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-03-15-39-06.png)

### 面向连接的多路复用 & 多路分解

**TCP 套接字的标识**:

- TCP 套接字使用一个『 **四元组** 』进行标识;
- 该四元组包含『 源 IP 地址 』,『 源端口号 』,『 目的 IP 地址 』,『 目的端口号 』
- 在接收主机的运输层, 使用这四个值来将报文段定向到对应的『 目的套接字 』;
- 两个具有不同『 源 IP 地址/源端口号 』, 但是有相同『 目的 IP 地址 』和『 目的端口号 』的报文段, 会被定向到不同的『 目的套接字 』
- 服务器主机可以支持很多并行的 TCP 套接字, 每个套接字与一个进程相联系;
- 通过这种标识方法, TCP 协议可以分辨来自不同主机的, 或者同一个主机不同端口发送过来的报文;

![2020-06-03-15-38-52](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-03-15-38-52.png)

## 无连接的运输 UDP

UDP 协议只是在运输层上为数据提供了最基本的多路复用/分解的服务. 以便让网络层和应用层之间可以传输数据;

### UDP 的特点

- **无需建立连接**: 使用 UDP 协议传输数据之前, 不需要在两端建立连接, 这省去了建立连接的时延;
- **容忍丢失**: UDP 协议只是把应用层的数据交给网络层进行传输, 而不在乎接收端是否真的收到. 对于很多实时应用, 为了追求低延迟, 它们可以容忍数据丢失;
- **无连接状态**: TCP 需要在端系统间维护连接状态, 而 UDP 不需要;
- **分组首部开销小**: 每个 TCP 报文段有 20 个字节, 而 UDP 只有 8 个字节;

![2020-06-03-22-06-01](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-03-22-06-01.png)

### UDP 报文段结构

![2020-06-03-22-23-07](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-03-22-23-07.png)

- 应用层『 **报文** 』占用 UDP 报文段的『 **数据字段** 』
- UDP 首部有 4 个字段, 每个字段由两个字节组成:
  - **源端口号, 目的端口号**: 指定了发送端和接收端对应进程的端口;
  - **长度**: 指示了 UDP 报文段的长度 ( 首部 + 数据 ) 以字节为单位;
  - **检验和**: 用来检验在该报文段中是否存在差错;

### UDP 校验和

- UDP『 检验和 』提供了差错检测功能;
- 其用于确定当 UDP 报文从发送端向目的端移动时, 其中的数据是否发生改变;
- 具体计算方法:
  - 『 发送方 』在运输层, 对报文段中的数据以 16 比特为单位将它们进行分割, 然后加在一起;
  - 之后对得出来的『 和 』进行『 反码 』运算, 求和时遇到的任何溢出, 都把它加到最后一位上, 这称为『 回卷 』
  - 最终得出的结果, 被放到了『 校验和 』字段;
  - 『 接收方 』在运输层, 将报文段的数据, 仍旧以 16 比特为单位将它们进行分割, 然后加在一起;
  - 得出来的结果, 与源端系统发送过来的『 校验和 』加在一起;
    - 如果没有差错发生, 则最终的和为 `1111111111111111`;
    - 如果其中任何一个比特位是 `0` 则说明有错误;
- 虽然 UDP 提供差错检测, 但是它对于恢复差错无能为力:
  - 某种 UDP 实现, 会丢弃受损的报文段;
  - 有的 UDP 实现, 会将受损的报文段交给应用程序, 并发出警告;

## 可靠数据传输原理

这一节介绍一般性的可靠数据传输实现原理.

『 **可靠数据传输协议** reliable data transfer protocol 』, 为上层实体提供的服务抽象是: 数据可以通过一条可靠的信道进行传输, 传输数据不会被损坏或丢失, 而且所有的数据都能按照发送顺序进行交付.

在实现可靠数据传输时, 我们假设『 较低层 』提供的都是『 不可靠的通信信道 』.

![2020-06-03-23-01-53](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-03-23-01-53.png)

> 注: 在本节, 我们仅考虑『 单项数据传输 unidirectional data transfer 』的情况, 即数据传输是从发送端到接收端的. 不考虑『 双向数据传输 bidirectional data transfer 』的情况.

### 构造可靠数据传输协议

下面 👇 让我们一步步地研究一系类协议, 它们一个比一个复杂, 最终得到一个**无错, 可靠的**数据传输协议;

#### 1. 经完全可靠信道的可靠数据传输: rdt 1.0

最简单的情况, 我们假定底层的信道是**完全可靠的**.

- 下图 👇 展示的是发送方和接收方的『 有限状态机 Finite State Machine, FSM 』
- 图中每个 FSM 只有一个状态;
- FSM 右边 👉 将引起状态变化的『 事件 』显示在了横线上方;
- 将事件发生时所采取的『 动作 』显示在了横线下方;
- FSM 左上的虚线箭头, 指向了 FSM 的初始状态;
- 在图中, 发送端中 rdt 1.0 协议的更高层调用 `rdt_send` 方法来将数据传递给它, 之后经由 `make_pkt` 动作生成了一个分组;
- 在接收端, rdt 1.0 协议的更低层通过 `rdt_rcv` 向其传递一个分组, 然后经由 `extract` 动作将分组中的上一层关心的数据取出, 并通过 `deliver_data` 传递给上一层;

![2020-06-03-23-22-35](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-03-23-22-35.png)

#### 2. 经具有比特差错信道的可靠数据传输: rdt 2.0

下面考虑分组在传播的过程中**数据可能受损**的情况.

为了让发送方知道哪些内容被正确地传送给了接收方, 数据传输协议需要建立『 **重传机制** 』, 具备这种机制的协议称为『 **自动重传请求协议** automatic repeat request. ARQ 』

- 接收者在收到正确数据时, 会回复给发送者一个『 **肯定确认** positive acknowledgement 』
- 接收者在收到受损数据时, 会回复给发送者一个『 **否定确认** negative acknowledgement 』要求对方再重复发送一遍刚刚是数据

---

下图中展示了在添加了自动重传功能后, 发送端和接收端的有限状态机:

- 在发送端中, 更高层调用 `rdt_send` 方法把数据传送到当前层后, 会计算出数据的『 校验和 』然后和数据一起打包成分组发送出去;
- 发送出分组后, 发送方会等待来自接收方响应回的 ACK 或 NAK 分组;
  - 如果收到 ACK 代表分组被正确接收, 发送方继续接收上层传来的数据, 然后传输给接收方;
  - 如果收到 NAK 分组, 则发送方重新传送刚才发送的分组, 并等待接收方对于重传分组的 ACK 或 NAK 响应;
  - 在发送方等待 ACK 或 NAK 时, 不会从上层获得新的数据, 也不会发送新的数据给接收方, 具有这种行为的协议称为『 停等协议 stop-and-wait 』
- 接收方仍旧只有一种状态, 当接收到分组后, 根据分组数据受损与否, 要么回答一个 ACK, 要么回答 NAK;

![2020-06-04-00-40-37](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-04-00-40-37.png)

---

上面 👆 所述的协议并没有考虑到, 如果接收方返回的 ACK 或 NAK 分组受损该怎么办. 受损的话, 发送方就不知道接收方是否正确接收到了刚才发送的分组.

解决方法是当接收方收到受损的 ACK 或 NAK 分组时, 就直接重传当前分组, 这种方法会在通信信道中引入『 **冗余分组** duplicate packet 』

冗余分组的问题是, 接收方不知道刚才发送的 ACK 或 NAK 响应是否被发送方正确接收, 也就无法知道现在发送方传来的数据是新的, 还是重传的.

解决方案是, 发送方在发出的分组上添加一个『 **分组编号** 』字段, 接收方只要检查该序号是否与上一个分组序号相同, 则可判断该分组是不是一个新分组了.

分组序号字段的长度『 1 比特 』就够了, 可能的值只有 0 和 1. 与接收的上一个分组序号的数字相同代表是重传分组, 数字不同代表是新的分组;

![2020-06-04-09-15-17](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-04-09-15-17.png)
![2020-06-04-10-22-34](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-04-10-22-34.png)

#### 3. 经具有比特差错的丢包信道的可靠数据传输: rdt 3.0

现在假定除了比特受损外, 底层信道还会丢包;

假定发送方传输一个数据分组, 该『 分组 』或接收方对该分组的『 确认响应 』可能在传输中发生丢失, 无论哪情况下, 发送方都接收不到接收方发回的响应. 发送方也就无法判断就下来该执行的行为了.

有很多种方法可以解决丢包问题. 这里讲的方法是『 **基于时间的重传机制** 』

- 在发送方传输出一个分组时, 启动一个『 **倒数定时器** countdown timer 』
- 如果在定时器设置的时间内, 发送方接收到了接收方响应, 则认为发送成功;
- 如果当定时器到期后仍没有收到接收方的响应, 发送方就重传分组数据;

![2020-06-04-10-33-37](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-04-10-33-37.png)

因为分组的序号一直在 0 和 1 之间来回交替, 所以这种协议也被称为『 **比特交替协议** alternating bit protocol 』

![2020-06-04-12-26-09](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-04-12-26-09.png)

### 流水线可靠数据传输协议

上面所讲的可靠数据传输协议是一个『 **停等协议** 』, 每次发送出数据后, 都要等待响应, 而期间不传输新的数据.

可以想象这样的协议肯定带来了很大的『 **时延** 』, 而且对于信道的『 **利用率** 』很低;

---

为了解决上述问题, 协议可以采用『 **流水线机制** pipelining 』其不使用停等机制, 允许发送方发送多个分组而不需等待确认响应.

![2020-06-04-12-27-01](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-04-12-27-01.png)

![2020-06-04-12-40-52](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-04-12-40-52.png)

为了使用流水线机制, 协议需要做如下修改:

- **增加分组序号的可选范围**: 因为同时在传的分组数量变多了, 所以分组序号的范围也要加大;
- **发送方和接收方需要缓存多个分组**: 发送方需要缓存多个已经发出, 但未得到确认响应的分组. 同时接收方也需要缓存部分已正确接收的分组;
- **差错恢复机制**: 解决流水线的差错恢复有两种基本方法:
  - **回退 N 步** Go-Back-N. GBN;
  - **选择重传** Selective Repeat, SR;

### 回退 N 步

在『 **回退 N 步 ( GBN ) 协议** 』中流水线中已发送但是未确认的分组不得超过某个最大允许数 $N$.

![2020-06-04-13-04-18](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-04-13-04-18.png)

- 『 **基序号** base 』定义为最早的未确认分组的序号, 它之前的序号都是已经发送并且得到确认的分组;
- 『 **下一个序号** nextseqnum 』定义为最小的未使用序号, 即将要被发送出去的分组可以使用这个序号;
- 大于 $base + N$ 的序号都是不能使用的;

#### GBN 发送方

- 上层调用 `rdtr_send` 想要发送数据时, 发送方先检查是否有可用的序号, 如果有就打包一个分组, 并发送出去. 如果没有可用序号, 也就是已发送但未确认的分组数量为 $N$, 则发送方把数据返回给上层;
- 在 GBN 协议中, 发送方对接收方返回的序号为 $n$ 的分组, 采用『 **累计确认** cumulative acknowledgment 』的方式, 该响应表明接收方已经正确接收包括序号为 $n$ 及其以前的分组;
- GBN 协议仍旧使用『 定时器 』来解决分组丢失:
  - 其只使用一个定时器, 它用来给『 基序号 』分组计时;
  - 当在流水线中的**第一个已发送未确认分组的定时器超时, 则重发所有已发送但是未确认的分组**, 这也是协议名字『 **回退 N 步** 』的由来;
  - 当发送方收到一个 ACK 响应时, 但是仍旧有已发送未确认分组, 则定时器重新启动, 给新的『 基序号 』分组计时;
  - 当流水线中已经没有已发送未确认分组时, 则定时器终止;

![2020-06-04-13-00-43](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-04-13-00-43.png)

#### GBN 接收方

- 接收方发送给上层的数据必须是有序的;
- 假如成功接收了一个失序分组, 也就是这个分组之前的某些分组还没有收到, 那么接收方需要丢弃这个正确接收的失序分组;
- 接收方需要维护的唯一变量就是下一个按序接收的分组的序号, 它只接收有序分组, 而抛弃失序分组;
- 这样做的缺点是, 传输过程中发生错误时, 发送方需要重复传很多传输正确的数据;

![2020-06-04-13-00-59](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-04-13-00-59.png)

下图 👇 展示了一个 $N = 4$ 的 GBN 协议运行情况:

![2020-06-04-13-33-18](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-04-13-33-18.png)

### 选择重传

『 **选择重传** Selective Repeat, SR 』通过让发送方仅重传那些怀疑在接收方出错的分组, 而避免不必要的重传.

- 在 SR 协议下的发送方, 每个已发送未确认分组都有一个自己的定时器;
- 接收方如果收到失序的分组, 会返回 ACK 给发送方, 并且将其先进行缓存. 直到接收到的分组可以有序排列后, 才交付给上层;

![2020-06-04-15-59-14](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-04-15-59-14.png)

---

SR 协议有个问题, 发送方和接收方并不能够正确判断自己发出的分组, 哪些被接收了, 哪些没有.

🌰 举例:

- 有 4 个分组序号 0 1 2 3, 窗口长度为 3;
- 发送序号为 0 1 2 的分组, 并且接收方正确接收且确认了. 接收方的窗口向后移动三格, 落在第 4 5 6 个分组上, 它们的序号分别是 3 0 1;

考虑下面 👇 两种情况:

- 情况一:
  - 所有返回的三个 ACK 确认分组都丢失了, 发送方的计时器超时后, 准备先重传序号为 0 的分组;
- 情况二:
  - 假设发送方接收到 0 分组的 ACK 确认, 发送方窗口向前移一格, 并且发送序号为 3 的新分组;
  - 之后又接收到了 1 分组的 ACK 确认, 然后继续重复上个步骤, 发送序号为 0 的新分组;

上述 👆 两种情况下, 接收方最后都收到了来自于发送方传来的, 序号为 0 的分组. **但是它并不能够判断, 这是一个重传分组, 还是一个初次传输的新分组**;

为了避免这种问题, **对于 SR 协议而言, 窗口长度必须小于或等于序号空间大小的一半**;

![2020-06-04-16-04-22](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-04-16-04-22.png)

#### 总结

![2020-06-04-16-33-53](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-04-16-33-53.png)

## 面向连接的运输 TCP

### TCP 连接

- TCP 是『 **面向连接** connection-oriented 』的, 两个端系统在用 TCP 协议发送数据前, 必须通过『 **三次握手** 』建立 TCP 连接;
- 连接建立时, 双方会初始化很多与 TCP 连接相关的状态变量. 这些状态变量完全保存在两个端系统中, 也就是说在两个主机的运输层中间的网络元素 ( 路由器, 交换机 ... ) 完全不关心两端间的 TCP 连接. 它们只关系传输的数据报 datagram;
- TCP 连接提供『 **全双工服务** full-duplex service 』也就是两端间可以互相传数据;
- TCP 连接是『 **点对点** point-to-point 』的, 一个发送方只能连接一个接收方. 一对多连接是不可以的;
- TCP 会先将应用层传来的数据放在『 **发送缓存** send buffer 』里, 之后 TCP 会在方便的时候以报文段的形式, 从缓存中取出数据进行发送;
  - TCP 可以从缓存中取出放入报文段的数据数量受限于『 **最大报文段长度** Maximum Segment Size, MSS 』
  - 而 MSS 的大小又由『 **最大链路层帧长度** 』也称为『 **最大传输单元** Maximum Transmission Unit, MTU 』来计算得出, MSS 的大小要保证一个 TCP 报文段, 被封装到网络层的数据报中时 ( 加上网络层首部 ), 数据报的大小适合单个链路层帧的长度;
  - ⚠️ 注意, MSS 指的是报文段里的应用层数据的最大长度, 不包括 TCP 的首部字段. 这个术语名称经常容易造成混淆;

![2020-06-05-11-42-51](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-05-11-42-51.png)

### TCP 报文段结构

TCP 报文段由『 **首部字段** 』加『 **数据字段** 』组成.

下图 👇 显示了首部字段的结构:

- 『 **源端口号** 』『 **目的端口号** 』被用于多路复用和多路分解;
- 『 **校验和字段** 』用于判断数据是否在传输中发生字节错误;
- 『 **序号字段** sequence nmber field 』和『 **确认号字段** acknowledgment number field 』这两个字段用于建立可靠的数据传输服务;
- 『 **接收窗口字段** receive window field 』 用以控制流量, 指示接收方愿意接受的字节数量;
- 『 **首部长度字段** header length field 』指示首部字段的长度. 因为 TCP 选项字段的存在, TCP 首部字段的长度是可变的. 当选项字段为空, 默认 TCP 首部长度为 20 字节;
- 『 **选项字段** options field 』定义了一些选项, 具体参照 RFC 854 和 RFC 1323 文档;
- 『 **标志字段** flag field 』用以表示一个报文段的发送目的:
  - ACK: 表示肯定确认;
  - RST: 表示连接重置;
  - SYN: 表示建立连接;
  - FIN: 表示关闭连接;

![2020-06-05-10-34-00](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-05-10-34-00.png)

#### 序号和确认号

『 **序号字段** sequence nmber field 』和『 **确认号字段** acknowledgment number field 』这两个字段用于建立可靠的数据传输服务.

---

**序号**:

- TCP 把传输的数据看作是一个有序的字节流;
- TCP 传输的报文段的『 **序号** 』是建立在字节流之上的;
- 一个报文段的序号是, 该报文段首字节在字节流中的编号;

🌰 举例, 假如一个数据流是由长度为 500,000 个字节的文件组成. 其『 最大报文段长度 MMS 』为 1000 个字节;

- TCP 将数据流切割成 500 个报文段;
- 数据流中的首字节编号为 0;
- 因此第 1 个报文段的序号为 0;
- 第 2 个报文段的序号为 1000;
- 第 3 个报文段的序号为 2000;
- 以此类推;

![2020-06-05-12-09-49](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-06-05-12-09-49.png)

---

**确认号**:

因为 TCP 是全双工的, 所以主机 A 向主机 B 发送数据时, 也可能会接收来自 B 主机的数据;

- 主机 B 送达主机 A 的每个报文段中, 都包含一个『 **序号** 』用于标识 B 流向 A 的数据;
- 而主机 A 发送给主机 B 的报文段中的『 **确认号** 』标识了主机 A 期望从主机 B 收到的下一个报文段的序号;

🌰 举例说明:

- 主机 A 已经收到来自主机 B 的编号为 0 ~ 535 的所有字节, 主机 A 期望从主机 B 继续接收到编号为 536 及其之后的所有字节, 那么下次主机 A 发送的报文段中的『 确认号 』就是 536;
- 如果主机 A 没有接收到『 确认号 』为 536 的报文段, 而是接到了一个『 确认号 』为 900 的报文段, 说明 536 报文段丢失了;
- 那么, 主机 A 在给主机 B 的报文段中的『 确认号 』仍旧为 536;
- TCP 只确认该流中从 0 至第一个丢失字节为止的字节, 所以 TCP 协议采用的是『 **累计确认** 』
- 对于刚才的『 确认号 』为 900 的失序报文, TCP 可以采用之前说的两种解决方案:
  - 回退 N 步: 直接丢弃失序报文段, 让发送方重传;
  - 选择重传: 先保存失序报文段, 等待缺失的报文段;

### 往返时间的估计与超时

::: warning

🚧 施工中...

:::

### 可靠数据传输

::: warning

🚧 施工中...

:::

### 流量控制

::: warning

🚧 施工中...

:::

### TCP 连接管理

## 拥塞控制原理

::: warning

🚧 施工中...

:::

## TCP 拥塞控制

::: warning

🚧 施工中...

:::
