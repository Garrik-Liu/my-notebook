# 应用层

- 网络应用可以说是计算机网络存在的意义, 没有应用, 网络也就没什么用了;
- 这一节, 学习有关网络应用通信的原理和实现;

## 应用层协议原理

### 网络应用程序体系结构

- 不同于网络体系结构是固定, 应用开发者可以自行设计『 **应用程序体系结构** application architecture 』
- 应用程序体系结构, 规定了如何在各种端系统上组织该应用程序;
- 开发者通常, 会采用两种主流的体系结构:
  - **客户 - 服务器体系结构** client-server architecture;
  - **P2P 体系结构** P2P architecture:

#### 客户 - 服务器体系结构

- 这种结构中, **总有一个打开的主机称为『 服务器 』, 它服务来自于许多称为『 客户 』的主机的请求**;
- 请求会在服务器端进行处理, 然后服务器返回一个对应的响应给客户端;
- 客户 - 服务器体系结构中, **各个客户端之间不直接通信**;
- 🌰 Web 应用就是使用的 "客户 - 服务器" 体系结构, Web 服务器处理来自与浏览器发送过来的请求;
- 这种结构的**缺点**是, 随着客户请求的增大, 服务提供商必须不断地升级服务处理能力, 并且负担增加的流量和带宽的费用. **成本较大**;

#### P2P 体系结构

- 这种结构中, **应用程序在主机之间直接通信, 这些主机称为『 对等方 』, 通信不依赖专有的服务器**;
- 🌰 很多流量密集型应用都是 P2P 结构, 文件共享程序 (例如, BitTorrent), 对等方协助下载加速器 (例如, 迅雷), IPTV (例如, 迅雷看看)
- P2P 体系结构具有『 **自扩展性** self-scalability 』, 随着用户的增多, 有更多的对等方互相之间分发文件, 整个系统的服务能力自发提升, 同时不需要服务器能力和带宽;

![2020-05-27-08-49-32](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-05-27-08-49-32.png)

### 进程通信

- 程序员编写的应用程序, 最终会调用操作系统中的『 **进程** process 』进行通信;
- 在一台主机上, 使用操作系统提供的『 **进程间通信机制** 』进行通信;
- 而在不同端系统上, 进程通过计算机网络交换『 **报文** message 』进行通信;

#### 客户 & 服务器进程

> ⚠️ 注意, 这里的『 客户 』和『 服务器 』形容的是『 进程 』.
> 和『 客户 - 服务器体系结构 』所指的不是一回事.

- 网络应用程序由成对的进程进行通信;
- 每队通信进程, 将发起通信的进程标识为『 **客户** 』, 将等待联系的进程称为『 **服务器** 』
- 🌰 在 Web 应用中, 由一个客户浏览器进程与一台 Web 服务器进程交换报文;
- 🌰 在 P2P 文件共享系统中, 下载文件的对等方是客户, 上传文件的对等方是服务器;

#### 进程与计算机网络之间的接口

- 应用程序调用的进程通过『 **套接字** socket 』接口来向网络发送发文和从网络接收报文;
- 套接字是主机内应用层与运输层之间的通信接口, 也就是运输层提供给应用层的 API;
- 通过套接字, 开发者可以控制应用层想要使用的运输层协议, 相关参数, 以及想要传送给运输层的相关数据;
- 套接字使用了运输层什么协议, 我们就说 "应用程序建立在由该协议提供的运输层服务之上";

![2020-05-27-09-16-44](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-05-27-09-16-44.png)

#### 进程寻址

- 为了正确的向另外一个主机上进程发送分组, 接收进程需要有一个**地址**, 该地址定义了两种信息:
  - 主机的地址: 由『 **IP 地址** 』标识
  - 定义在目的主机中的接收进程的标识符: 由主机上的『 **端口号** 』来标识;

### 可供应用程序使用的运输服务

存在着不止一种的运输层协议, 在开发应用程序时, 我们需要根据自己的需求选择合适的运输层协议;

应用程序对运输层协议的需求, 大致可以分为如下四个方面:

**可靠的数据运输**:

- 分组在网络中传输时可能会造成丢包;
- 如果一个运输层协议能够确保从一端应用程序发来的数据能够准确无误的发送到另外一端的应用程序上, 那么就称此协议提供了『 **可靠数据传输** reliable data transfer 』
- 应用程序可以放心把数据发送给提供可靠数据传输的运输层, 完全相信数据可以准确无误地传递到目的地;
- 对于『 **容忍丢失的应用** loss-tolerant application 』不提供可靠数据传输的运输层协议是可以接收的;
  - 🌰 例如, 音视频应用可以容许稍微的丢包;

**吞吐量**:

- 可用吞吐量就是发送进程能够向接收进程交付数据的速率;
- 具有吞吐量要求的应用程序被称为『 **带宽敏感的应用** bandwidth sensitive application 』
- 对于这种应用, 有的运输层协议提供确保传输速率的服务;
- 对于没有特定的吞吐量需求的应用, 称为『 **弹性应用** elastic application 』
- 但无论如何, 吞吐量越大越好是无疑的;

**定时**:

- 对于实时交互式应用程序, 它们对于数据交付的时间有严格的要求;
- 有的运输层协议可以提供『 定时保障 』, 保证数据能够以限定的时间内传输到目的地;
- 🌰 对于数据传输时间有严格要求的应用有: 网络游戏, 音视频直播;

**安全性**:

- 有的运输层协议可以为应用程序提供各种各样的安全性服务;
- 🌰 例如, 提供加密服务的运输层协议, 可以加密由发送进程传输的所有数据, 并且在接收端的运输层里将数据解密, 然后交付给接收进程;

### 因特网提供的运输服务

- 因特网为应用程序提供两个运输层协议:
  - UDP
  - TCP
- 每个协议都为调用他们的应用程序提供了不同的服务集合;
- 开发者需要根据应用的需求, 选择合适的运输层协议. 下图 👇 展示了不同应用的网络需求:

![2020-05-27-12-39-08](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-05-27-12-39-08.png)

---

**TCP 服务**:

- TCP 服务模型为应用程序提供如下两种服务:
  - **面向连接服务**:
    - 在应用层数据报文开始传送之前，TCP 让客户和服务器互相交换运输层控制信息，这被称为『 **握手** 』
    - 在握手阶段后，一个『 **TCP 连接** 』就在两个进程的套接字之间建立了;
    - 这条链接是『 **全双工** 』的, 即连接双方的进程都可以在此连接之上互相收发报文;
    - 当应用程序结束报文传输之后，必须断开该连接;
  - **可靠度数据传送服务**:
    - 通信进程能够依靠 TCP 无差错，按适当顺序交付所有发送的数据;

**UDP 服务**:

- UDP 协议提供一种『 **不可靠数据传送服务** 』
- UDP 是『 **无连接** 』的，因此两个进程通信前没有握手过程;
- 当进程将一个报文发送给 UDP 套接字时, UDP 协议并不保证将这报文能传送到接收进程。

### 应用层协议

- 上面讲了如何把应用层报文发送进套接字, 使网络进程间实现互相通信。但是如何构造这些报文，这些报文中各个字段的含义，以及进程何时去发送这些报文，这些问题由应用层协议去解决;
- 『 **应用层协议** 』定义了如下内容:
  - 交换的报文类型，例如请求报文和响应报文;
  - 各种报文类型的语法，如报文中的各个字段以及这些字段如何描述;
  - 字段的语义，即这些字段中包含的信息的含义;
  - 一个进程何时以及如何发送这些报文, 对报文进行响应的规则;

## HTTP

### HTTP 概述

- 20 世纪 90 年代, **万维网** (World Wide Web, WEB) 作为一个因特网应用程序被开发出来;
- Web 的应用层协议是『 **超文本传输协议** HyperText Transfer Protocol, HTTP 』
- HTTP 由两个程序实现, 一个客户程序, 一个服务器程序, 它们分别运行在不同的端系统中. 通过交换 HTTP 报文进行会话;
  - 客户程序通常指『 Web 浏览器 』;
  - 服务器程序通常指『 Web 服务器 』;
- HTTP 定义了这些报文的结构以及客户和服务器进行报文交换的方式;

---

- Web 页面是由『 **对象** 』构成的;
- 通常以一个 HTML 文件作为基本对象, 文件里会引用几个其他对象;
  - 🌰 例如, CSS 文件, JS 文件, 图像文件, 视频文件, 等;
- Web 对象储存在 Web 服务器端, 每个对象都可以通过一个 URL 地址进行引用;
- URL 地址由两个部分组成, 存放对象服务器主机名, 和对象的路径名;
  - 🌰 例如, `www.xxxx.com/resources/index.html`

---

- HTTP 使用 **TCP** 作为它的支撑运输协议;
- HTTP 客户端，首先发起一个与服务器的 TCP 连接，一旦建立连接，该浏览器与服务器进程就可以通过套接字接口访问 TCP;
- 因为 TCP 连接提供可靠的数据传输服务，所以一个客户进程发出的每个 HTTP 请求，最终报文都能完整的送达服务器。同理服务器的响应也能够完整地到达客户端;
- HTTP 是一个『 **无状态协议** 』，HTTP 服务器并不保存关于客户的任何信息;

### 非持续连接 & 持续连接

- 在客户端与服务器建立 TCP 连接时, 有如下两种方式:
- **非持续连接** non-persistent connection:
  - 每个 TCP 连接只传输一个请求报文和一个响应报文;
  - 在客户端接收到服务端响应后, TCP 连接就会断开;
  - 等下次客户端想要给服务器发请求时, 再重新建立 TCP 连接;
- **持续连接** persistent connection:
  - TCP 连接可以保持, 持续的发送请求和响应;
  - 通常会对连接设置一个闲置时间, 如果 TCP 连接空闲超过这个时间, 连接就会断开;
  - **HTTP 协议默认使用持续连接**;

### HTTP 报文格式

HTTP 报文有两种:

- 请求报文;
- 响应报文;

#### 请求报文

下图 👇 是请求报文的组成结构:

![2020-05-27-18-40-20](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-05-27-18-40-20.png)

![2020-05-27-20-42-32](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-05-27-20-42-32.png)

#### 响应报文

下图 👇 是响应报文的组成结构:

![2020-05-27-20-43-55](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-05-27-20-43-55.png)

响应报文中会根据请求的结果, 给出一个对应的状态码. 例如:

- 200: 请求成功;
- 301: 请求的对象被永久转移了;
- 400: 请求不被服务器理解;
- 404: 被请求的资源不在服务器上;

### Cookie

- 因为 HTTP 协议是无状态的, 服务器默认不知道请求的客户端是谁;
- 但是很多功能的实现需要依靠对于用户的识别, Cookie 技术可以帮应用实现这个功能;

下图 👇 展示了客户端与服务器之间如何使用 Cookie 实现客户识别:

![2020-05-27-20-50-24](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-05-27-20-50-24.png)

- 当客户端第一次访问服务器时, 服务器生成关于客户端的唯一识别码 ID, 并把此 ID 作为索引, 用于在数据库中储存和客户端相关的信息;
- 接下来服务器将一个包含 `Set-cookie` 的首部字段的 HTTP 响应报文发送给客户端, 首部字段的值包含服务器生成的 ID;
- 当客户端接收到响应后, 浏览器检测到报文中的 `Set-cookie` 首部字段, 它会在浏览器中管理 Cookie 的文件中添加一行, 该行包含服务器的主机名和 `Set-cookie` 字段的值;
- 当客户端再去向服务器发送请求时, 浏览器会把自身保存的 Cookie 信息放到 HTTP 请求报文的 `cookie` 首部行中;
- 服务器接收到请求报文, 解析 `cookie` 字段的值, 把它放到数据库中去检索出和对应客户端相关的信息;

### Web 缓存

- 『 **Web 缓存器** Web Cache 』也称『 **代理服务器** Proxy Server 』
- 它位于客户端与初始服务器之间。 通过配置浏览器，使客户端的所有 HTTP 请求首先指向 WEB 缓存器;
- 缓存器会先在自身找是否有客户端想要请求的对象的副本。如果有的话就直接返回给客户端;
- 如果没有的话就去向初始服务器进行请求，并会在接收到响应后，现在缓存器中保存一份副本，然后再返回给客户端;

![2020-05-27-21-09-30](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-05-27-21-09-30.png)

---

**WEB 缓存器的好处**:

- WEB 缓存器通常由 ISP 提供;
- 在因特网上部署 WEB 缓存器只要有如下原因:
  - 当客户端与初始服务器之间的瓶颈宽带低于客户端与 WEB 缓存器之间的瓶颈宽带时，**WEB 缓存器可以大大减少客户请求的响应时间**。( 通常客户与 WEB 缓存器之间有一个高速连接 )
  - **WEB 缓存器能够大大减少一个机构的接入链路到因特网的通信量**，通过减少通信量可以减少该机构的带宽需求，并因此来降低费用;

![2020-05-27-21-17-42](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-05-27-21-17-42.png)

---

**内容分发网路**:

- 『 内容分发网络 Content Distribution Network, CDN 』是 WEB 缓存器的一个重要应用;
- CDN 公司在因特网上安装了许多地理上分散的缓存器, 使得大量流量可以实现本地化;
- 可以提高客户端请求远距离服务器时的响应速度;

![2020-05-27-21-36-22](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-05-27-21-36-22.png)

## FTP

## SMTP

## DNS

## P2P

## TCP 套接字编程

::: warning
🚧 **施工中...**
:::
