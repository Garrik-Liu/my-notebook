(window.webpackJsonp=window.webpackJsonp||[]).push([[159],{367:function(t,a,s){"use strict";s.r(a);var r=s(0),v=Object(r.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"排序"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#排序"}},[t._v("#")]),t._v(" 排序")]),t._v(" "),s("p",[t._v("这一节介绍一些常用的排序算法。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-1-19-17-26-59.png",alt:"2020-1-19-17-26-59.png"}})]),t._v(" "),s("h2",{attrs:{id:"如何分析一个-“排序算法”"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何分析一个-“排序算法”"}},[t._v("#")]),t._v(" 如何分析一个 “排序算法”")]),t._v(" "),s("h3",{attrs:{id:"执行效率"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#执行效率"}},[t._v("#")]),t._v(" 执行效率")]),t._v(" "),s("p",[t._v("对于排序算法执行效率的分析，我们一般会从这几个方面来衡量：")]),t._v(" "),s("h4",{attrs:{id:"最好情况、最坏情况、平均情况时间复杂度"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#最好情况、最坏情况、平均情况时间复杂度"}},[t._v("#")]),t._v(" 最好情况、最坏情况、平均情况时间复杂度")]),t._v(" "),s("p",[t._v("在分析排序算法的时间复杂度时，要分别给出最好情况、最坏情况、平均情况下的时间复杂度。")]),t._v(" "),s("p",[t._v("除此之外，你还要说出最好、最坏时间复杂度对应的要排序的原始数据是什么样的。")]),t._v(" "),s("h4",{attrs:{id:"时间复杂度的系数、常数-、低阶"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#时间复杂度的系数、常数-、低阶"}},[t._v("#")]),t._v(" 时间复杂度的系数、常数 、低阶")]),t._v(" "),s("p",[t._v("算法时间复杂度反应的是数据规模 n 增大的时候的一个增长趋势。当 n 很大的时候，我们会忽略系数、常数、低阶。")]),t._v(" "),s("p",[t._v("但是实际的软件开发中，我们排序的可能是 10 个、100 个、1000 个这样规模很小的数据，所以，在对同一阶时间复杂度的排序算法性能对比的时候，我们就要把系数、常数、低阶也考虑进来。")]),t._v(" "),s("h4",{attrs:{id:"比较次数和交换（或移动）次数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#比较次数和交换（或移动）次数"}},[t._v("#")]),t._v(" 比较次数和交换（或移动）次数")]),t._v(" "),s("p",[t._v("基于比较的排序算法的执行过程，会涉及两种操作，一种是元素比较大小，另一种是元素交换或移动。")]),t._v(" "),s("p",[t._v("所以，如果我们在分析排序算法的执行效率的时候，应该把比较次数和交换（或移动）次数也考虑进去。")]),t._v(" "),s("h3",{attrs:{id:"内存消耗"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#内存消耗"}},[t._v("#")]),t._v(" 内存消耗")]),t._v(" "),s("p",[t._v("针对排序算法的空间复杂度，我们引入了一个新的概念，"),s("strong",[t._v("原地排序")]),t._v("（Sorted in place）。")]),t._v(" "),s("p",[t._v("原地排序算法，就是指在排序过程中不申请多余的存储空间，只在原来存储待排数据的存储空间，进行比较和交换的排序算法。其空间复杂度是 "),s("mjx-container",{staticClass:"MathJax",attrs:{jax:"SVG"}},[s("svg",{staticStyle:{"vertical-align":"-0.566ex"},attrs:{xmlns:"http://www.w3.org/2000/svg",width:"4.618ex",height:"2.262ex",viewBox:"0 -750 2041 1000"}},[s("g",{attrs:{stroke:"currentColor",fill:"currentColor","stroke-width":"0",transform:"matrix(1 0 0 -1 0 0)"}},[s("g",{attrs:{"data-mml-node":"math"}},[s("g",{attrs:{"data-mml-node":"mi"}},[s("path",{attrs:{"data-c":"4F",d:"M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"}})]),s("g",{attrs:{"data-mml-node":"mo",transform:"translate(763, 0)"}},[s("path",{attrs:{"data-c":"28",d:"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"}})]),s("g",{attrs:{"data-mml-node":"mn",transform:"translate(1152, 0)"}},[s("path",{attrs:{"data-c":"31",d:"M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"}})]),s("g",{attrs:{"data-mml-node":"mo",transform:"translate(1652, 0)"}},[s("path",{attrs:{"data-c":"29",d:"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"}})])])])])]),t._v(" 。")],1),t._v(" "),s("h3",{attrs:{id:"稳定性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#稳定性"}},[t._v("#")]),t._v(" 稳定性")]),t._v(" "),s("p",[t._v("针对排序算法，还有一个重要的度量指标，"),s("strong",[t._v("稳定性")]),t._v("。")]),t._v(" "),s("p",[t._v("这个概念是说，"),s("strong",[t._v("如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变")]),t._v("。")]),t._v(" "),s("p",[t._v("举例来讲，比如我们有一组数据 2，9，3，4，8，3，按照大小排序之后就是 2，3，3，4，8，9。这组数据里有两个 3。经过某种排序算法排序之后，如果两个 3 的前后顺序没有改变，那我们就把这种排序算法叫作"),s("strong",[t._v("稳定的排序算法")]),t._v("；如果前后顺序发生变化，那对应的排序算法就叫作"),s("strong",[t._v("不稳定的排序算法")]),t._v("。")]),t._v(" "),s("p",[t._v("🌰 通过一个例子来说明，为什么要判断一个算法是否稳定。")]),t._v(" "),s("details",{staticClass:"custom-block details",attrs:{open:"open"}},[s("summary",[t._v("例子：")]),t._v(" "),s("p",[t._v("比如说，我们现在要给电商交易系统中的“订单”排序。订单有两个属性，一个是下单时间，另一个是订单金额。如果我们现在有 10 万条订单数据，我们希望按照金额从小到大对订单数据排序。对于金额相同的订单，我们希望按照下单时间从早到晚有序。对于这样一个排序需求，我们怎么来做呢？")]),t._v(" "),s("p",[t._v("借助稳定排序算法，这个问题可以非常简洁地解决。解决思路是这样的：我们先按照下单时间给订单排序，注意是按照下单时间，不是金额。排序完成之后，我们用稳定排序算法，按照订单金额重新排序。两遍排序之后，我们得到的订单数据就是按照金额从小到大排序，金额相同的订单按照下单时间从早到晚排序的。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-1-19-17-38-13.png",alt:"2020-1-19-17-38-13.png"}})])]),t._v(" "),s("h2",{attrs:{id:"冒泡排序"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#冒泡排序"}},[t._v("#")]),t._v(" 冒泡排序")]),t._v(" "),s("h2",{attrs:{id:"插入排序"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#插入排序"}},[t._v("#")]),t._v(" 插入排序")]),t._v(" "),s("h2",{attrs:{id:"选择排序"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#选择排序"}},[t._v("#")]),t._v(" 选择排序")]),t._v(" "),s("h2",{attrs:{id:"归并排序"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#归并排序"}},[t._v("#")]),t._v(" 归并排序")]),t._v(" "),s("h2",{attrs:{id:"快速排序"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#快速排序"}},[t._v("#")]),t._v(" 快速排序")]),t._v(" "),s("h2",{attrs:{id:"堆排序"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#堆排序"}},[t._v("#")]),t._v(" 堆排序")]),t._v(" "),s("h2",{attrs:{id:"桶排序"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#桶排序"}},[t._v("#")]),t._v(" 桶排序")]),t._v(" "),s("h2",{attrs:{id:"计数排序"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#计数排序"}},[t._v("#")]),t._v(" 计数排序")]),t._v(" "),s("h2",{attrs:{id:"基数排序"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#基数排序"}},[t._v("#")]),t._v(" 基数排序")])])}),[],!1,null,null,null);a.default=v.exports}}]);