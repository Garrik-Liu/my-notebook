(window.webpackJsonp=window.webpackJsonp||[]).push([[76],{155:function(t,a,e){"use strict";e.r(a);var r=e(0),s=Object(r.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("div",{staticClass:"content"},[e("h1",{attrs:{id:"模块机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#模块机制","aria-hidden":"true"}},[t._v("#")]),t._v(" 模块机制")]),e("p",[t._v("在开发相对复杂的程序时, 通过使用模块机制, 我们可以把一个复杂程序的各个功能拆分, 分别封装到不同的文件. 在需要的时候引入相关的模块. 这样做可以让代码的可读性, 复用性, 和易维护性够变得更高.")]),e("p",[t._v("Node.js 参照 CommonJS 标准实现了模块机制.  在 Node.js 中, 每个\b文件就被视为一个模块.  这个文件可能是 JavaScript \b编写的文件、JSON 或者用 C/C++ 编译的二进制文件.  在上一篇结尾的 Node 代码实例中, "),e("code",[t._v("http")]),t._v(" 就是一个 Node 自带的核心模块, 用以实现 HTTP 协议.")]),e("blockquote",[e("p",[t._v("CommonJS 规范: 因为 JavaScript 诞生之初只是为了写网页小脚本, 并不作为开发大型复杂应用的语言, 其自身有很多不足.  由于官方规范 (ECMAScript) 制定的时间较早, 涵盖范围较小, 对于后端开发而言, 例如文件系统, I/O 流, 模块系统, 等等方面都没有相应的标准.  CommonJS 规范让 JavaScript 弥补了没有标准的缺陷, 让 JavaScript 有能力去开发复杂应用, 同时具备了跨平台能力.")])]),e("h2",{attrs:{id:"创建-导出模块"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#创建-导出模块","aria-hidden":"true"}},[t._v("#")]),t._v(" 创建 & 导出模块")]),e("p",[t._v("在了解了什么是模块之后, 让我们来看看如何创建并导出模块.")]),e("p",[t._v("在 Node.js 中, 一个文件就是一个模块.")]),e("h2",{attrs:{id:"引入模块"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#引入模块","aria-hidden":"true"}},[t._v("#")]),t._v(" 引入模块")]),e("h3",{attrs:{id:"路径解析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#路径解析","aria-hidden":"true"}},[t._v("#")]),t._v(" 路径解析")]),e("h2",{attrs:{id:"包-包管理器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#包-包管理器","aria-hidden":"true"}},[t._v("#")]),t._v(" 包 & 包管理器")])])}],!1,null,null,null);a.default=s.exports}}]);