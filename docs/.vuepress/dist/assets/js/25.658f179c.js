(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{234:function(t,s,a){"use strict";a.r(s);var n=a(0),e=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"深入浅出-node-js"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#深入浅出-node-js"}},[t._v("#")]),t._v(" 深入浅出 Node.js")]),t._v(" "),a("p",[a("a",{attrs:{href:"http://www.ituring.com.cn/book/1290",target:"_blank",rel:"noopener noreferrer"}},[t._v("传送门"),a("OutboundLink")],1)]),t._v(" "),a("h2",{attrs:{id:"网络编程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#网络编程"}},[t._v("#")]),t._v(" 网络编程")]),t._v(" "),a("p",[t._v("Node 提供了net、dgram、http、https这4个模块，分别用于处理TCP、UDP、HTTP、HTTPS，适用于服务器端和客户端。")]),t._v(" "),a("h3",{attrs:{id:"构建tcp服务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#构建tcp服务"}},[t._v("#")]),t._v(" 构建TCP服务")]),t._v(" "),a("p",[t._v("TCP全名为传输控制协议，在OSI模型（由七层组成，分别为物理层、数据链结层、网络层、传输层、会话层、表示层、应用层）中属于"),a("strong",[t._v("传输层协议")]),t._v("。许多应用层协议基于TCP构建，典型的是HTTP、SMTP、IMAP等协议。")]),t._v(" "),a("p",[t._v("TCP是面向连接的协议，其显著的特征是在传输之前需要"),a("strong",[t._v("3次握手")]),t._v("形成会话，")]),t._v(" "),a("p",[t._v("在创建会话的过程中，服务器端和客户端分别提供一个"),a("strong",[t._v("套接字")]),t._v("，这两个套接字共同形成一个连接。服务器端与客户端则通过套接字实现两者之间连接的操作。")]),t._v(" "),a("h2",{attrs:{id:"构建-web-应用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#构建-web-应用"}},[t._v("#")]),t._v(" 构建 WEB 应用")]),t._v(" "),a("h3",{attrs:{id:"路由解析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#路由解析"}},[t._v("#")]),t._v(" 路由解析")]),t._v(" "),a("p",[t._v("Web请求过程中的预处理过程，对于不同的业务，我们还是期望有不同的处理方式，这带来了路由的选择问题。本节将会介绍文件路径、MVC、RESTful等路由方式。")]),t._v(" "),a("h4",{attrs:{id:"文件路径型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#文件路径型"}},[t._v("#")]),t._v(" 文件路径型")]),t._v(" "),a("p",[t._v("『 静态文件 』: URL的路径与网站目录的路径一致，无须转换.  这种路由的处理方式也十分简单，将请求路径对应的文件发送给客户端即可。")]),t._v(" "),a("p",[t._v("『 动态文件 』: 根据文件路径执行动态脚本也是基本的路由方式，它的处理原理是Web服务器根据URL路径找到对应的文件，如/index.asp 或 /index.php。Web服务器根据文件名后缀去寻找脚本的解析器，并输出响应报文，达到完成服务的目的。  这种方式在Node中不太常见，主要原因是文件的后缀都是 "),a("code",[t._v(".js")])]),t._v(" "),a("h4",{attrs:{id:"mvc"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mvc"}},[t._v("#")]),t._v(" MVC")]),t._v(" "),a("p",[t._v("MVC 模型的主要思想是将业务逻辑按职责分离")]),t._v(" "),a("ul",[a("li",[t._v("控制器（Controller），一组行为的集合。")]),t._v(" "),a("li",[t._v("模型（Model），数据相关的操作和封装。")]),t._v(" "),a("li",[t._v("视图（View），视图的渲染。")])]),t._v(" "),a("p",[t._v("它的工作模式如下:")]),t._v(" "),a("ul",[a("li",[t._v("路由解析，根据 URL 寻找到对应的 控制器 和 行为。")]),t._v(" "),a("li",[t._v("行为调用相关的模型，进行数据操作。")]),t._v(" "),a("li",[t._v("数据操作结束后，调用视图和相关数据进行页面渲染，输出到客户端。")])]),t._v(" "),a("p",[t._v("如何根据URL做路由映射，这里有两个分支实现:")]),t._v(" "),a("ul",[a("li",[t._v("通过手工关联映射")]),t._v(" "),a("li",[t._v("自然关联映射")])]),t._v(" "),a("p",[t._v("前者会有一个对应的路由文件来将URL映射到对应的控制器，后者没有这样的文件。")]),t._v(" "),a("p",[a("img",{attrs:{src:"http://www.ituring.com.cn/figures/2013/Node.js/12.d08z.03.png",alt:"img"}})]),t._v(" "),a("p",[t._v("『 手工映射 』: 在入口程序中判断URL，然后执行对应的逻辑，于是就完成了基本的路由映射过程\n『 正则匹配 』: 如果请求需要根据不同的用户显示不同的内容，这里只有两个用户，假如系统中存在成千上万个用户，我们就不太可能去手工维护所有用户的路由请求，因此正则匹配应运而生\n『 自然映射 』: 路由按一种约定的方式自然而然地实现了路由，而无须去维护路由映射。")]),t._v(" "),a("h4",{attrs:{id:"restful"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#restful"}},[t._v("#")]),t._v(" RESTful")]),t._v(" "),a("p",[t._v("表现层状态转化。符合REST规范的设计，我们称为RESTful设计。它的设计哲学主要将服务器端提供的内容实体看作一个资源，并表现在URL上。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://i.imgur.com/jTLofWy.png",alt:"Screen Shot 2018-11-11 at 1.17.13 PM"}})]),t._v(" "),a("p",[t._v("在RESTful设计中，资源的具体格式由请求报头中的Accept字段和服务器端的支持情况来决定")]),t._v(" "),a("p",[t._v("REST的设计就是，通过URL设计资源、请求方法定义资源的操作，通过Accept决定资源的表现形式。")]),t._v(" "),a("h3",{attrs:{id:"中间件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#中间件"}},[t._v("#")]),t._v(" 中间件")]),t._v(" "),a("p",[t._v("中间件（middleware）来简化和隔离这些基础设施与业务逻辑之间的细节，让开发者能够关注在业务的开发上，以达到提升开发效率的目的。")]),t._v(" "),a("p",[t._v("中间件的含义借指了这种"),a("strong",[t._v("封装底层细节")]),t._v("，"),a("strong",[t._v("为上层提供更方便服务")]),t._v("的意义")]),t._v(" "),a("p",[t._v("中间件的行为比较类似Java中过滤器（filter）的工作原理，就是在进入具体的业务处理之前，先让过滤器处理。")]),t._v(" "),a("p",[t._v("对于Web应用的各种基础功能，我们通过中间件来完成，每个中间件处理掉相对简单的逻辑，最终汇成强大的基础框架。它的上下文也就是请求对象和响应对象：req 和 res。有一点区别的是，由于Node异步的原因，我们需要提供一种机制，在当前中间件处理完成后，通知下一个中间件执行。")]),t._v(" "),a("p",[t._v("采用Connect的设计，通过"),a("strong",[t._v("尾触发")]),t._v("的方式实现。一个基本的中间件会是如下的形式：")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("middleware")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("req"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" res"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" next")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// TODO")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("next")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("h2",{attrs:{id:"单元测试"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#单元测试"}},[t._v("#")]),t._v(" 单元测试")]),t._v(" "),a("p",[t._v("单元测试的意义在于每个测试用例的覆盖都是一种可能的承诺。如果API升级时，测试用例可以很好地检查是否向下兼容。对于各种可能的输入，一旦测试覆盖，都能明确它的输出。代码改动后，可以通过测试结果判断代码的改动是否影响已确定的结果。")]),t._v(" "),a("p",[t._v("对于开发者而言，不仅要编写单元测试，还应当编写可测试代码。简单而言，编写"),a("strong",[t._v("可测试代码")]),t._v("有以下几个原则可以遵循:")]),t._v(" "),a("p",[t._v("『 单一职责 』: 如果一段代码承担的职责越多，为其编写单元测试的时候就要构造更多的输入数据，然后推测它的输出。比如，一段代码中既包含数据库的连接，也包含查询，那么为它编写测试用例就要同时关注数据库连接和数据库查询。较好的方式是将这两种职责进行解耦分离，变成两个单一职责的方法，分别测试数据库连接和数据库查询。")]),t._v(" "),a("p",[t._v("『 接口抽象 』: 通过对程序代码进行接口抽象后，我们可以针对接口进行测试，而具体代码实现的变化不影响为接口编写的单元测试。")]),t._v(" "),a("p",[t._v("『 层次分离 』: 层次分离实际上是单一职责的一种实现。在MVC结构的应用中，就是典型的层次分离模型，如果不分离各个层次，无法想象这个代码该如何切入测试。通过分层之后，可以逐层测试，逐层保证。")]),t._v(" "),a("h3",{attrs:{id:"单元测试介绍"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#单元测试介绍"}},[t._v("#")]),t._v(" 单元测试介绍")]),t._v(" "),a("p",[t._v("单元测试主要包含断言、测试框架、测试用例、测试覆盖率、mock、持续集成等几个方面，由于Node的特殊性，它还会加入异步代码测试和私有方法的测试这两个部分。")]),t._v(" "),a("p",[t._v("『 "),a("strong",[t._v("断言")]),t._v(" 』: 断言（assertion）是一种放在程序中的一阶逻辑（如一个结果为真或是假的逻辑判断式），目的是为了标示程序开发者预期的结果——当程序运行到断言的位置时，对应的断言应该为真。若断言不为真，程序会中止运行，并出现错误信息。")]),t._v(" "),a("p",[t._v("一句话来说: "),a("strong",[t._v("断言用于检查程序在运行时是否满足期望")])]),t._v(" "),a("p",[t._v("断言就是单元测试中用来保证"),a("strong",[t._v("最小单元")]),t._v("是否正常的检测方法。")]),t._v(" "),a("p",[t._v("JavaScript的断言规范最早来自于 CommonJS 的单元测试规范.  Node实现了规范中的断言部分。")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" assert "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("require")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'assert'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nassert"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("equal")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("Math"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("max")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("100")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("100")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("一旦assert.equal()不满足期望，将会抛出 AssertionError 异常，整个程序将会停止执行。"),a("strong",[t._v("没有对输出结果做任何断言检查的代码，都不是测试代码。没有测试代码的代码，都是不可信赖的代码")]),t._v("。")]),t._v(" "),a("p",[t._v("在断言规范中，我们定义了以下几种检测方法。")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("ok()")]),t._v("：判断结果是否为真。")]),t._v(" "),a("li",[a("code",[t._v("equal()")]),t._v("：判断实际值与期望值是否相等。")]),t._v(" "),a("li",[a("code",[t._v("notEqual()")]),t._v("：判断实际值与期望值是否不相等。")]),t._v(" "),a("li",[a("code",[t._v("deepEqual()")]),t._v("：判断实际值与期望值是否深度相等（对象或数组的元素是否相等）。")]),t._v(" "),a("li",[a("code",[t._v("notDeepEqual()")]),t._v("：判断实际值与期望值是否不深度相等。")]),t._v(" "),a("li",[a("code",[t._v("strictEqual()")]),t._v("：判断实际值与期望值是否严格相等（相当于===）。")]),t._v(" "),a("li",[a("code",[t._v("notStrictEqual()")]),t._v("：判断实际值与期望值是否不严格相等（相当于!==）。")]),t._v(" "),a("li",[a("code",[t._v("throws()")]),t._v("：判断代码块是否抛出异常。")])]),t._v(" "),a("p",[t._v("除此之外，Node的assert模块还扩充了如下两个断言方法。")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("doesNotThrow()")]),t._v("：判断代码块是否没有抛出异常。")]),t._v(" "),a("li",[a("code",[t._v("ifError()")]),t._v("：判断实际值是否为一个假值（null、undefined、0、''、false），如果实际值为真值，将会抛出异常。")])]),t._v(" "),a("h3",{attrs:{id:"测试框架"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#测试框架"}},[t._v("#")]),t._v(" 测试框架")]),t._v(" "),a("p",[t._v("前面提到断言一旦检查失败，将会抛出异常停止整个应用，这对于做大规模断言检查时并不友好。更通用的做法是，"),a("strong",[t._v("记录下抛出的异常并继续执行，最后生成测试报告")]),t._v("。 这些任务的承担者就是测试框架。")]),t._v(" "),a("p",[t._v("这里我们要介绍的优秀单元测试框架是 "),a("strong",[t._v("mocha")])]),t._v(" "),a("h4",{attrs:{id:"测试风格"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#测试风格"}},[t._v("#")]),t._v(" 测试风格")]),t._v(" "),a("p",[t._v("现今流行的单元测试风格主要有 "),a("strong",[t._v("TDD（测试驱动开发）")]),t._v(" 和 "),a("strong",[t._v("BDD（行为驱动开发）")]),t._v(" 两种，它们的差别如下所示。")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("关注点不同")]),t._v("。TDD关注所有功能是否被正确实现，每一个功能都具备对应的测试用例；BDD关注整体行为是否符合预期，适合自顶向下的设计方式。")]),t._v(" "),a("li",[a("strong",[t._v("表达方式不同")]),t._v("。TDD的表述方式偏向于功能说明书的风格；BDD的表述方式更接近于自然语言的习惯。")])]),t._v(" "),a("p",[t._v("mocha对于两种测试风格都有支持。")]),t._v(" "),a("p",[t._v("BDD 对测试用例的组织主要采用 describe 和 it 进行组织。")]),t._v(" "),a("ul",[a("li",[t._v("describe 可以描述多层级的结构，具体到测试用例时，用it。")]),t._v(" "),a("li",[t._v("另外，它还提供 before、after、beforeEach 和 afterEach 这4个钩子方法，用于协助describe 中测试用例的准备、安装、卸载和回收等工作。")]),t._v(" "),a("li",[t._v("before 和 after 分别在进入和退出 describe 时触发执行，beforeEach 和 afterEach 则分别在 describe 中每一个测试用例（it）执行前和执行后触发执行。")])]),t._v(" "),a("p",[a("img",{attrs:{src:"http://www.ituring.com.cn/figures/2013/Node.js/14.d10z.01.png",alt:"img"}})]),t._v(" "),a("p",[t._v("TDD 对测试用例的组织主要采用 suite 和 test 完成。suite 也可以实现多层级描述，测试用例用test。它提供的钩子函数仅包含 setup 和 teardown，对应 BDD 的 before 和 after。TDD风格的组织示意图如图10-2所示。")]),t._v(" "),a("p",[a("img",{attrs:{src:"http://www.ituring.com.cn/figures/2013/Node.js/14.d10z.02.png",alt:"img"}})]),t._v(" "),a("h3",{attrs:{id:"测试用例"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#测试用例"}},[t._v("#")]),t._v(" 测试用例")]),t._v(" "),a("p",[t._v("简单来讲，一个行为或者功能需要有完善的、多方面的测试用例，一个测试用例中包含至少一个断言。")]),t._v(" "),a("p",[t._v("测试用例最少需要通过正向测试和反向测试来保证测试对功能的覆盖，这是最基本的测试用例。")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[t._v("describe")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'#indexOf()'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 反向")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("it")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'should return -1 when not present'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("indexOf")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("should"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("equal")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 正向")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("it")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'should return index when present'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("indexOf")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("should"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("equal")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("indexOf")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("should"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("equal")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("indexOf")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("should"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("equal")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("对于Node而言，不仅有这样简单的方法调用，还有异步代码和超时设置需要关注。")]),t._v(" "),a("h4",{attrs:{id:"异步测试"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#异步测试"}},[t._v("#")]),t._v(" 异步测试")]),t._v(" "),a("p",[t._v("在Node中，检查方法的返回值毫无意义，并且不知道回调函数具体何时调用结束，这将导致我们在对异步调用进行测试时，无法调度后续测试用例的执行。")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[t._v("it")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'fs.readFile should be ok'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("done")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  fs"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("readFile")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'file_path'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'utf-8'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("err"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" data")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    should"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("not"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("exist")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("err"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("done")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("测试用例方法it()接受两个参数；用例标题（title）和回调函数（fn）。通过检查这个回调函数的形参长度（fn.length）来判断这个用例是否是异步调用，如果是异步调用，在执行测试用例时，会将一个函数done() 注入为实参，测试代码需要"),a("strong",[t._v("主动调用")]),t._v("这个函数通知测试框架当前测试用例执行完成，然后测试框架才进行下一个测试用例的执行，")]),t._v(" "),a("h4",{attrs:{id:"超时设置"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#超时设置"}},[t._v("#")]),t._v(" 超时设置")]),t._v(" "),a("p",[t._v("异步方法给测试带来的问题主要在于"),a("strong",[t._v("回调函数执行的时间无从预期")]),t._v("。通过上面的例子，我们无法知道done()具体在什么时间执行。如果代码偶然出错，导致done()一直没有执行，将会造成所有的测试用例处于暂停状态，这显然不是框架所期望的。")]),t._v(" "),a("p",[t._v("mocha给所有涉及异步的测试用例添加了超时限制，如果一个用例的执行时间超过了预期时间，将会记录下一个超时错误，然后执行下一个测试用例。")]),t._v(" "),a("p",[t._v("mocha 的默认超时时间为 2000 毫秒。通过"),a("code",[t._v("mocha -t <ms>")]),t._v("设置所有用例的超时时间。若需更细粒度地设置超时时间，可以在测试用例it中调用"),a("code",[t._v("this.timeout(ms)")]),t._v("实现对单个用例的特殊设置，")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[t._v("it")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'should take less than 500ms'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("done")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("timeout")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("500")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("setTimeout")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("done"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("300")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("也可以在描述 describe 中调用 this.timeout(ms) 设置描述下当前层级的所有用例：")]),t._v(" "),a("h3",{attrs:{id:"测试覆盖率"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#测试覆盖率"}},[t._v("#")]),t._v(" 测试覆盖率")]),t._v(" "),a("p",[t._v("通过不停地给代码添加测试用例，将会不断地覆盖代码的分支和不同的情况。但是如何判断单元测试对代码的覆盖情况，我们需要直观的工具来体现。测试覆盖率是单元测试中的一个重要指标，它能够概括性地给出整体的覆盖度，也能明确地给出统计到行的覆盖情况。")]),t._v(" "),a("p",[t._v("若要探知这个测试用例对源代码的覆盖率，需要一种工具来统计每一行代码是否执行，这里要介绍的相关工具是 jscover 模块。")]),t._v(" "),a("h3",{attrs:{id:"mock"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mock"}},[t._v("#")]),t._v(" mock")]),t._v(" "),a("p",[t._v("在测试领域里，模拟异常其实是一个不小的科目，它有着一个特殊的名词：mock。")])])}),[],!1,null,null,null);s.default=e.exports}}]);