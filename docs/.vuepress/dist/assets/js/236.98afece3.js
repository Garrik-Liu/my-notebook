(window.webpackJsonp=window.webpackJsonp||[]).push([[236],{450:function(t,s,a){"use strict";a.r(s);var e=a(0),i=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"数组"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数组"}},[t._v("#")]),t._v(" 数组")]),t._v(" "),a("p",[a("strong",[t._v('『 数组 Array 』是一种 "线性表" 结构。它用一组连续的内存空间，来存储一组具有相同类型的数据')]),t._v("。")]),t._v(" "),a("p",[t._v("这个定义里有几个关键词，下面分别解释一下：")]),t._v(" "),a("h2",{attrs:{id:"线性表"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#线性表"}},[t._v("#")]),t._v(" 线性表")]),t._v(" "),a("p",[t._v("『 "),a("strong",[t._v("线性表")]),t._v(" 』就是数据排成像一条线一样的结构。"),a("strong",[t._v("每个线性表上的数据最多只有前和后两个方向")]),t._v("。其实除了数组，链表、队列、栈等也是线性表结构。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-1-13-12-20-38.png",alt:"2020-1-13-12-20-38.png"}})]),t._v(" "),a("p",[t._v("它相对立的概念是『 "),a("strong",[t._v("非线性表")]),t._v(" 』，比如二叉树、堆、图等。之所以叫非线性，是因为，在非线性表中，数据之间并不是简单的前后关系。")]),t._v(" "),a("h2",{attrs:{id:"连续的内存空间和相同类型的数据"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#连续的内存空间和相同类型的数据"}},[t._v("#")]),t._v(" 连续的内存空间和相同类型的数据")]),t._v(" "),a("p",[t._v("『 "),a("strong",[t._v("连续的内存空间和相同类型的数据")]),t._v(" 』")]),t._v(" "),a("p",[t._v("举例来说，声明一个长度为 10 的 int 类型数组。计算机给数组分配了一块连续内存空间 1000 ～ 1039，其中，内存块的首地址为 base_address = 1000。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-1-13-12-34-14.png",alt:"2020-1-13-12-34-14.png"}})]),t._v(" "),a("p",[t._v("计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。因为数组中每个元素在内存中都是连续的，所以这支持计算机对数组元素进行 『 "),a("strong",[t._v("随机访问")]),t._v(" 』，也就是直接访问任何位置的任何元素。")]),t._v(" "),a("p",[t._v("当计算机需要随机访问数组中的某个元素时，它会首先通过下面的寻址公式，计算出该元素存储的内存地址。然后通过地址去访问数据。"),a("strong",[t._v("在数组中，根据下标随机访问的时间复杂度为 O(1)")]),t._v("。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("Address = base_address + i * data_type_size\n")])])]),a("p",[t._v("其中 "),a("code",[t._v("data_type_size")]),t._v(" 表示数组中每个元素的大小。在这个例子里，数组中存储的是 int 类型数据，每个元素占 4 个字节。")]),t._v(" "),a("h2",{attrs:{id:"低效的-“插入”-和-“删除”"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#低效的-“插入”-和-“删除”"}},[t._v("#")]),t._v(" 低效的 “插入” 和 “删除”")]),t._v(" "),a("p",[t._v("但在数组中删除，或插入数据的操作是低效的。因为数组内的元素在内存中是连续的。插入，和删除一个元素会打破这种连续。所以就需要做很多数据搬移的工作。")]),t._v(" "),a("details",{staticClass:"custom-block details",attrs:{open:"open"}},[a("summary",[t._v("🌰 例子：")]),t._v(" "),a("p",[t._v("假设数组的长度为 n，现在，如果我们需要将一个数据插入到数组中的第 k 个位置。为了把第 k 个位置腾出来，给新来的数据，我们需要将第 k ～ n 这部分的元素都顺序地往后挪一位。那插入操作的时间复杂度是多少呢？")]),t._v(" "),a("p",[t._v("如果在数组的末尾插入元素，那就不需要移动数据了，这时的时间复杂度为 "),a("eq",[a("span",{staticClass:"katex"},[a("span",{staticClass:"katex-mathml"},[a("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[a("semantics",[a("mrow",[a("mi",[t._v("O")]),a("mo",{attrs:{stretchy:"false"}},[t._v("(")]),a("mn",[t._v("1")]),a("mo",{attrs:{stretchy:"false"}},[t._v(")")])],1),a("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("O(1)")])],1)],1)],1),a("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[a("span",{staticClass:"base"},[a("span",{staticClass:"strut",staticStyle:{height:"1em","vertical-align":"-0.25em"}}),a("span",{staticClass:"mord mathdefault",staticStyle:{"margin-right":"0.02778em"}},[t._v("O")]),a("span",{staticClass:"mopen"},[t._v("(")]),a("span",{staticClass:"mord"},[t._v("1")]),a("span",{staticClass:"mclose"},[t._v(")")])])])])]),t._v("。但如果在数组的开头插入元素，那所有的数据都需要依次往后移动一位，所以最坏时间复杂度是 "),a("eq",[a("span",{staticClass:"katex"},[a("span",{staticClass:"katex-mathml"},[a("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[a("semantics",[a("mrow",[a("mi",[t._v("O")]),a("mo",{attrs:{stretchy:"false"}},[t._v("(")]),a("mi",[t._v("n")]),a("mo",{attrs:{stretchy:"false"}},[t._v(")")])],1),a("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("O(n)")])],1)],1)],1),a("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[a("span",{staticClass:"base"},[a("span",{staticClass:"strut",staticStyle:{height:"1em","vertical-align":"-0.25em"}}),a("span",{staticClass:"mord mathdefault",staticStyle:{"margin-right":"0.02778em"}},[t._v("O")]),a("span",{staticClass:"mopen"},[t._v("(")]),a("span",{staticClass:"mord mathdefault"},[t._v("n")]),a("span",{staticClass:"mclose"},[t._v(")")])])])])]),t._v("。 因为我们在每个位置插入元素的概率是一样的，所以平均情况时间复杂度为：")],1),t._v(" "),a("section",[a("eqn",[a("span",{staticClass:"katex-display"},[a("span",{staticClass:"katex"},[a("span",{staticClass:"katex-mathml"},[a("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[a("semantics",[a("mrow",[a("mo",{attrs:{stretchy:"false"}},[t._v("(")]),a("mn",[t._v("1")]),a("mo",[t._v("+")]),a("mn",[t._v("2")]),a("mo",[t._v("+")]),a("mo",[t._v("…")]),a("mi",[t._v("n")]),a("mo",{attrs:{stretchy:"false"}},[t._v(")")]),a("mi",{attrs:{mathvariant:"normal"}},[t._v("/")]),a("mi",[t._v("n")]),a("mo",[t._v("=")]),a("mi",[t._v("O")]),a("mo",{attrs:{stretchy:"false"}},[t._v("(")]),a("mi",[t._v("n")]),a("mo",{attrs:{stretchy:"false"}},[t._v(")")])],1),a("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("(1+2+…n)/n=O(n)")])],1)],1)],1),a("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[a("span",{staticClass:"base"},[a("span",{staticClass:"strut",staticStyle:{height:"1em","vertical-align":"-0.25em"}}),a("span",{staticClass:"mopen"},[t._v("(")]),a("span",{staticClass:"mord"},[t._v("1")]),a("span",{staticClass:"mspace",staticStyle:{"margin-right":"0.2222222222222222em"}}),a("span",{staticClass:"mbin"},[t._v("+")]),a("span",{staticClass:"mspace",staticStyle:{"margin-right":"0.2222222222222222em"}})]),a("span",{staticClass:"base"},[a("span",{staticClass:"strut",staticStyle:{height:"0.72777em","vertical-align":"-0.08333em"}}),a("span",{staticClass:"mord"},[t._v("2")]),a("span",{staticClass:"mspace",staticStyle:{"margin-right":"0.2222222222222222em"}}),a("span",{staticClass:"mbin"},[t._v("+")]),a("span",{staticClass:"mspace",staticStyle:{"margin-right":"0.2222222222222222em"}})]),a("span",{staticClass:"base"},[a("span",{staticClass:"strut",staticStyle:{height:"1em","vertical-align":"-0.25em"}}),a("span",{staticClass:"minner"},[t._v("…")]),a("span",{staticClass:"mspace",staticStyle:{"margin-right":"0.16666666666666666em"}}),a("span",{staticClass:"mord mathdefault"},[t._v("n")]),a("span",{staticClass:"mclose"},[t._v(")")]),a("span",{staticClass:"mord"},[t._v("/")]),a("span",{staticClass:"mord mathdefault"},[t._v("n")]),a("span",{staticClass:"mspace",staticStyle:{"margin-right":"0.2777777777777778em"}}),a("span",{staticClass:"mrel"},[t._v("=")]),a("span",{staticClass:"mspace",staticStyle:{"margin-right":"0.2777777777777778em"}})]),a("span",{staticClass:"base"},[a("span",{staticClass:"strut",staticStyle:{height:"1em","vertical-align":"-0.25em"}}),a("span",{staticClass:"mord mathdefault",staticStyle:{"margin-right":"0.02778em"}},[t._v("O")]),a("span",{staticClass:"mopen"},[t._v("(")]),a("span",{staticClass:"mord mathdefault"},[t._v("n")]),a("span",{staticClass:"mclose"},[t._v(")")])])])])])])],1)]),t._v(" "),a("h2",{attrs:{id:"为什么数组的下标以-0-开始"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么数组的下标以-0-开始"}},[t._v("#")]),t._v(" 为什么数组的下标以 0 开始")]),t._v(" "),a("p",[t._v("从数组存储的内存模型上来看，"),a("strong",[t._v("“下标” 最确切的定义应该是 “偏移（offset）”")]),t._v("。前面也讲到，如果用 a 来表示数组的首地址，"),a("code",[t._v("a[0]")]),t._v(" 就是偏移为 0 的位置，也就是首地址，"),a("code",[t._v("a[k]")]),t._v(" 就表示偏移 k 个 "),a("code",[t._v("type_size")]),t._v(" 的位置")])])}),[],!1,null,null,null);s.default=i.exports}}]);