(window.webpackJsonp=window.webpackJsonp||[]).push([[237],{605:function(t,a,s){"use strict";s.r(a);var e=s(2),n=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"数组"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数组"}},[t._v("#")]),t._v(" 数组")]),t._v(" "),s("p",[s("strong",[t._v("『 数组 』（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据")]),t._v("。")]),t._v(" "),s("p",[t._v("这个定义里有几个关键词，下面分别解释一下：")]),t._v(" "),s("h2",{attrs:{id:"线性表"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#线性表"}},[t._v("#")]),t._v(" 线性表")]),t._v(" "),s("p",[t._v("『 "),s("strong",[t._v("线性表")]),t._v(" 』就是数据排成像一条线一样的结构。"),s("strong",[t._v("每个线性表上的数据最多只有前和后两个方向")]),t._v("。其实除了数组，链表、队列、栈等也是线性表结构。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-1-13-12-20-38.png",alt:"2020-1-13-12-20-38.png"}})]),t._v(" "),s("p",[t._v("它相对立的概念是『 "),s("strong",[t._v("非线性表")]),t._v(" 』，比如二叉树、堆、图等。之所以叫非线性，是因为，在非线性表中，数据之间并不是简单的前后关系。")]),t._v(" "),s("h2",{attrs:{id:"连续的内存空间和相同类型的数据"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#连续的内存空间和相同类型的数据"}},[t._v("#")]),t._v(" 连续的内存空间和相同类型的数据")]),t._v(" "),s("p",[t._v("『 "),s("strong",[t._v("连续的内存空间和相同类型的数据")]),t._v(" 』")]),t._v(" "),s("p",[t._v("举例来说，声明一个长度为 10 的 int 类型数组。计算机给数组分配了一块连续内存空间 1000 ～ 1039，其中，内存块的首地址为 base_address = 1000。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-1-13-12-34-14.png",alt:"2020-1-13-12-34-14.png"}})]),t._v(" "),s("p",[t._v("计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。因为数组中每个元素在内存中都是连续的，所以这支持计算机对数组元素进行 『 "),s("strong",[t._v("随机访问")]),t._v(" 』，也就是直接访问任何位置的任何元素。")]),t._v(" "),s("p",[t._v("当计算机需要随机访问数组中的某个元素时，它会首先通过下面的寻址公式，计算出该元素存储的内存地址。然后通过地址去访问数据。"),s("strong",[t._v("在数组中，根据下标随机访问的时间复杂度为 O(1)")]),t._v("。")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("Address = base_address + i * data_type_size\n")])])]),s("p",[t._v("其中 "),s("code",[t._v("data_type_size")]),t._v(" 表示数组中每个元素的大小。在这个例子里，数组中存储的是 int 类型数据，每个元素占 4 个字节。")]),t._v(" "),s("h2",{attrs:{id:"低效的-“插入”-和-“删除”"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#低效的-“插入”-和-“删除”"}},[t._v("#")]),t._v(" 低效的 “插入” 和 “删除”")]),t._v(" "),s("p",[t._v("但在数组中删除，或插入数据的操作是低效的。因为数组内的元素在内存中是连续的。插入，和删除一个元素会打破这种连续。所以就需要做很多数据搬移的工作。")]),t._v(" "),s("p",[t._v("\b::: details-open 例子：\n假设数组的长度为 n，现在，如果我们需要将一个数据插入到数组中的第 k 个位置。为了把第 k 个位置腾出来，给新来的数据，我们需要将第 k ～ n 这部分的元素都顺序地往后挪一位。那插入操作的时间复杂度是多少呢？")]),t._v(" "),s("p",[t._v("如果在数组的末尾插入元素，那就不需要移动数据了，这时的时间复杂度为 "),s("span",{staticClass:"katex"},[s("span",{staticClass:"katex-mathml"},[s("math",[s("semantics",[s("mrow",[s("mi",[t._v("O")]),s("mo",[t._v("(")]),s("mn",[t._v("1")]),s("mo",[t._v(")")])],1),s("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("O(1)")])],1)],1)],1),s("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[s("span",{staticClass:"strut",staticStyle:{height:"0.75em"}}),s("span",{staticClass:"strut bottom",staticStyle:{height:"1em","vertical-align":"-0.25em"}}),s("span",{staticClass:"base textstyle uncramped"},[s("span",{staticClass:"mord mathit",staticStyle:{"margin-right":"0.02778em"}},[t._v("O")]),s("span",{staticClass:"mopen"},[t._v("(")]),s("span",{staticClass:"mord mathrm"},[t._v("1")]),s("span",{staticClass:"mclose"},[t._v(")")])])])]),t._v("。但如果在数组的开头插入元素，那所有的数据都需要依次往后移动一位，所以最坏时间复杂度是 "),s("span",{staticClass:"katex"},[s("span",{staticClass:"katex-mathml"},[s("math",[s("semantics",[s("mrow",[s("mi",[t._v("O")]),s("mo",[t._v("(")]),s("mi",[t._v("n")]),s("mo",[t._v(")")])],1),s("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("O(n)")])],1)],1)],1),s("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[s("span",{staticClass:"strut",staticStyle:{height:"0.75em"}}),s("span",{staticClass:"strut bottom",staticStyle:{height:"1em","vertical-align":"-0.25em"}}),s("span",{staticClass:"base textstyle uncramped"},[s("span",{staticClass:"mord mathit",staticStyle:{"margin-right":"0.02778em"}},[t._v("O")]),s("span",{staticClass:"mopen"},[t._v("(")]),s("span",{staticClass:"mord mathit"},[t._v("n")]),s("span",{staticClass:"mclose"},[t._v(")")])])])]),t._v("。 因为我们在每个位置插入元素的概率是一样的，所以平均情况时间复杂度为 (1+2+…n)/n=O(n)。\n:::")]),t._v(" "),s("h2",{attrs:{id:"为什么数组的下标以-0-开始"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么数组的下标以-0-开始"}},[t._v("#")]),t._v(" 为什么数组的下标以 0 开始")]),t._v(" "),s("p",[t._v("从数组存储的内存模型上来看，"),s("strong",[t._v("“下标” 最确切的定义应该是 “偏移（offset）”")]),t._v("。前面也讲到，如果用 a 来表示数组的首地址，"),s("code",[t._v("a[0]")]),t._v(" 就是偏移为 0 的位置，也就是首地址，"),s("code",[t._v("a[k]")]),t._v(" 就表示偏移 k 个 "),s("code",[t._v("type_size")]),t._v(" 的位置")])])}),[],!1,null,null,null);a.default=n.exports}}]);