(window.webpackJsonp=window.webpackJsonp||[]).push([[86],{184:function(t,s,a){"use strict";a.r(s);var n=a(0),o=Object(n.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("div",{staticClass:"content"},[a("h1",{attrs:{id:"异步编程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#异步编程","aria-hidden":"true"}},[t._v("#")]),t._v(" 异步编程")]),a("h2",{attrs:{id:"为什么要用异步"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么要用异步","aria-hidden":"true"}},[t._v("#")]),t._v(" 为什么要用异步?")]),a("p",[t._v("在编程的时候, 一个很重要的问题是: "),a("strong",[t._v("如何表达和控制持续一段时间的程序行为")]),t._v('。换句话说, 就是一段代码 "现在" 运行, 另一部分 "将来" 运行.   "将来" 运行的代码无法在 "现在" 运行的代码执行完之后立刻执行.  "现在" 和 "将来" 之间有一段间隙.')]),a("p",[t._v("这个间隙可能是在等待用户输入信息、从数据库或文件系统中请求数据、或通过网络发送数据并等待响应.")]),a("p",[t._v('处理好 "现在" 的代码和 "将来" 的代码之间的关系, 就是异步编程的核心.')]),a("h2",{attrs:{id:"异步的解决方案"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#异步的解决方案","aria-hidden":"true"}},[t._v("#")]),t._v(" 异步的解决方案")]),a("h3",{attrs:{id:"回调函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#回调函数","aria-hidden":"true"}},[t._v("#")]),t._v(" 回调函数")]),a("p",[t._v('"回调" 的意思就是 "回头调用的函数".  函数中的代码是在 "将来" 的操作.  当相对应的 "事件" 被触发了, 函数会被执行.')]),a("p",[t._v("回调是编写和处理 JavaScript 异步逻辑的最常用方式.")]),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{attrs:{class:"token comment"}},[t._v("// 代码 A ")]),t._v("\n\n"),a("span",{attrs:{class:"token function"}},[t._v("setTimeout")]),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{attrs:{class:"token keyword"}},[t._v("function")]),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{attrs:{class:"token comment"}},[t._v("// 代码 B")]),t._v("\n"),a("span",{attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{attrs:{class:"token number"}},[t._v("1000")]),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),a("span",{attrs:{class:"token comment"}},[t._v("// 代码 C")]),t._v("\n")])])]),a("p",[t._v('上面的代码中使用了回调函数.  如果用日常口语去描述这段代码的运行方式, 大概是 "代码 A 先执行; 然后设定一个 1000 毫秒的延时事件; 代码 C 执行; 延时事件被触发, 代码 B 得到执行."')]),a("h4",{attrs:{id:"回调地狱"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#回调地狱","aria-hidden":"true"}},[t._v("#")]),t._v(" 回调地狱")]),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{attrs:{class:"token function"}},[t._v("setTimeout")]),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{attrs:{class:"token keyword"}},[t._v("function")]),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    console"),a("span",{attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{attrs:{class:"token function"}},[t._v("log")]),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{attrs:{class:"token string"}},[t._v("'1'")]),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{attrs:{class:"token function"}},[t._v("setTimeout")]),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{attrs:{class:"token keyword"}},[t._v("function")]),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        console"),a("span",{attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{attrs:{class:"token function"}},[t._v("log")]),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{attrs:{class:"token string"}},[t._v("'2'")]),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{attrs:{class:"token function"}},[t._v("setTimeout")]),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{attrs:{class:"token keyword"}},[t._v("function")]),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            console"),a("span",{attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{attrs:{class:"token function"}},[t._v("log")]),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{attrs:{class:"token string"}},[t._v("'3'")]),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{attrs:{class:"token number"}},[t._v("1000")]),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),a("span",{attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{attrs:{class:"token number"}},[t._v("1000")]),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{attrs:{class:"token number"}},[t._v("1000")]),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),a("p",[t._v('这种多个回调函数嵌套在一起的代码, 被称作 "回调地狱".')]),a("p",[t._v('被称为 "地狱" 的主要原因除了层层嵌套的代码难于阅读, 更主要的原因是: '),a("strong",[t._v('回调函数的使用让代码执行顺序缺少 "顺序性"')]),t._v('.  "非顺序(线性)" 的代码执行方式与我们大脑的顺序地思考方式不符.')]),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{attrs:{class:"token function"}},[t._v("doA")]),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{attrs:{class:"token keyword"}},[t._v("function")]),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" \n    "),a("span",{attrs:{class:"token function"}},[t._v("doC")]),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),a("span",{attrs:{class:"token function"}},[t._v("doD")]),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{attrs:{class:"token keyword"}},[t._v("function")]),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" \n        "),a("span",{attrs:{class:"token function"}},[t._v("doF")]),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n    "),a("span",{attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),a("span",{attrs:{class:"token function"}},[t._v("doE")]),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n"),a("span",{attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{attrs:{class:"token function"}},[t._v("doB")]),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("如果 "),a("code",[t._v("doA")]),t._v(" 和 "),a("code",[t._v("doD")]),t._v(" 接收两个\b回调函数, 会被异步调用.  那么上面代码的执行顺序为 A -> B -> C -> D -> E -> F.  当我们在线性（顺序）地追踪这段代码的执行顺序时，我们不得不从一个函数跳到下一个，再跳到下一个.  可以想象当异步代码更复杂时, \b这种追踪的难度会成倍增加。")]),a("p",[t._v('这种 "非顺序的" 执行步骤并不符合我们的大脑思考方式.  我们的大脑类似于单线程运行的事件循环队列, 它喜欢以顺序地, 同步地方式去理解, 思考事情.')]),a("p",[t._v('在回调函数上, 我们大脑的工作方式和代码的执行方式发生了 "分歧".  回调函数的滥用会让'),a("strong",[t._v("代码变得更加难以理解、追踪、调试和维护")]),t._v("。这是回调函数的主要问题所在.")]),a("p",[t._v("除此之外, "),a("strong",[t._v("嵌套的回调函数把\b异步代码的执行顺序\b写死了")]),t._v(".  上面代码中, "),a("code",[t._v("doD")]),t._v(" 的回调函数必须等 "),a("code",[t._v("doA")]),t._v(" 的回调函数得到执行之后才能被执行. 假如它们两个之间没有顺序关系, 这种写死的顺序会增加代码的脆弱性.  类比来说, \b假如你计划五点钟去吃饭, \b六点钟去看电影.  它们之间没有绝对的顺序关系, 哪怕你五点钟没有\b去吃饭, 也不会影响你六点去看电影.")]),a("h4",{attrs:{id:"信任问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#信任问题","aria-hidden":"true"}},[t._v("#")]),t._v(" 信任问题")]),a("p",[t._v("当我们在第三方提供的\b工具中使用回调函数的时候, 实际上我们就"),a("strong",[t._v('把代码一部分的操控权交给了第三方.  这被称为 "控制反转"')]),t._v(".  这加大了代码不确定性.")]),a("p",[t._v("假如你使用了一个\b第三方提供的用来验证账号登录状态的函数.  并在传入的回调函数中进行支付操作.")]),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("\b"),a("span",{attrs:{class:"token function"}},[t._v("checkLogin")]),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v("accountInfo"),a("span",{attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{attrs:{class:"token keyword"}},[t._v("function")]),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{attrs:{class:"token function"}},[t._v("payMoney")]),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),a("p",[t._v("看似一切都完美, 但是我们在这段代码中, 把支付操作的控制权交给了一个第三方.  \b这会导致很多可能出现的错误情况:")]),a("ul",[a("li",[t._v("调用回调过早;")]),a("li",[t._v("调用回调过晚（或没有调用）;")]),a("li",[t._v("调用回调的次数太少或太多;")]),a("li",[t._v("没有把所需的环境 / 参数成功传给你的回调函数;")]),a("li",[t._v("吞掉可能出现的错误或异常;")]),a("li",[t._v("等等;")])]),a("p",[t._v("\b\b为了确保安全性, 常用的解决方案是对传入的参数, \b回调函数的调用情况设定相应的安全机制.  但这也加大了代码的复杂度.")]),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{attrs:{class:"token function"}},[t._v("addNumbers")]),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v("x"),a("span",{attrs:{class:"token punctuation"}},[t._v(",")]),t._v("y"),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{attrs:{class:"token comment"}},[t._v("// 确保输入为数字 ")]),t._v("\n    "),a("span",{attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{attrs:{class:"token keyword"}},[t._v("typeof")]),t._v(" x "),a("span",{attrs:{class:"token operator"}},[t._v("!=")]),t._v(" "),a("span",{attrs:{class:"token string"}},[t._v('"number"')]),t._v(" "),a("span",{attrs:{class:"token operator"}},[t._v("||")]),t._v(" "),a("span",{attrs:{class:"token keyword"}},[t._v("typeof")]),t._v(" y "),a("span",{attrs:{class:"token operator"}},[t._v("!=")]),t._v(" "),a("span",{attrs:{class:"token string"}},[t._v('"number"')]),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" \n        "),a("span",{attrs:{class:"token keyword"}},[t._v("throw")]),t._v(" "),a("span",{attrs:{class:"token function"}},[t._v("Error")]),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" "),a("span",{attrs:{class:"token string"}},[t._v('"Bad parameters"')]),t._v(" "),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n    "),a("span",{attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n    "),a("span",{attrs:{class:"token comment"}},[t._v("// 如果到达这里，可以通过+安全的进行数字相加 ")]),t._v("\n    "),a("span",{attrs:{class:"token keyword"}},[t._v("return")]),t._v(" x "),a("span",{attrs:{class:"token operator"}},[t._v("+")]),t._v(" y"),a("span",{attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{attrs:{class:"token function"}},[t._v("addNumbers")]),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" "),a("span",{attrs:{class:"token number"}},[t._v("21")]),a("span",{attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{attrs:{class:"token number"}},[t._v("21")]),t._v(" "),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{attrs:{class:"token comment"}},[t._v("// 42 ")]),t._v("\n"),a("span",{attrs:{class:"token function"}},[t._v("addNumbers")]),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" "),a("span",{attrs:{class:"token number"}},[t._v("21")]),a("span",{attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{attrs:{class:"token string"}},[t._v('"21"')]),t._v(" "),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{attrs:{class:"token comment"}},[t._v('// Error: "Bad parameters"')]),t._v("\n")])])]),a("p",[t._v("如果你还没有应用某种逻辑来解决所有这些控制反转导致的信任问题，那"),a("strong",[t._v("你的代码现在已经有了 bug，即使它们还没有给你造成损害。隐藏的 bug 也是 bug")]),t._v("。")]),a("h3",{attrs:{id:"promise"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#promise","aria-hidden":"true"}},[t._v("#")]),t._v(" Promise")]),a("p",[a("strong",[t._v("Promise 是一种封装和组合未来值的易于复用的机制")]),t._v("。这套机制可以用来处理异步操作.  ES6 使用这套机制实现了 Promise 对象.")]),a("h4",{attrs:{id:"未来值-承诺值"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#未来值-承诺值","aria-hidden":"true"}},[t._v("#")]),t._v(" 未来值, 承诺值")]),a("p",[t._v('再来讨论一下什么是 "未来值", "承诺值".')]),a("p",[t._v('中午你去麦当劳买汉堡, 你点餐的时候服务员不能马上给你汉堡, 于是服务员给你一张带订单号的收据作为凭证.  这张收据就是 "Promise (承诺)".  服务员用它来向你承诺, 汉堡做好后会给你.  这个时候, 收据代表了你的汉堡.  当汉堡做好, 服务员叫你的订单号的时候, 这张收据 (承诺) 就可以用来换取你真正想要得到的汉堡.  当然还会有另一种结果.  就是后厨发现汉堡用的肉卖完了, 服务员遗憾地告诉你汉堡做不了了.')]),a("p",[t._v('拿这个例子类比 Promise 机制.  汉堡就是 "未来值", 收据就是 "承诺值".  当 "未来值" 准备好时, 可以用 "承诺值" 换取 "未来值".  同时, "未来值" 会有两种情况: 成功, 或者失败.')]),a("h3",{attrs:{id:"generator"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#generator","aria-hidden":"true"}},[t._v("#")]),t._v(" Generator")]),a("h3",{attrs:{id:"async-await"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#async-await","aria-hidden":"true"}},[t._v("#")]),t._v(" async/await")])])}],!1,null,null,null);s.default=o.exports}}]);