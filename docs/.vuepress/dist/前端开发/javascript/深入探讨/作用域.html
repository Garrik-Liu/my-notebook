<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>作用域 | Garrik 的笔记</title>
    <meta name="description" content="这里是 Garrik 的前端笔记本">
    
    
    <link rel="preload" href="/front-end-notebook/assets/css/132.styles.fbd8f7d1.css" as="style"><link rel="preload" href="/front-end-notebook/assets/js/app.18fe53fa.js" as="script"><link rel="preload" href="/front-end-notebook/assets/js/90.f3686cbc.js" as="script"><link rel="prefetch" href="/front-end-notebook/assets/js/67.306d290f.js"><link rel="prefetch" href="/front-end-notebook/assets/js/1.91f94162.js"><link rel="prefetch" href="/front-end-notebook/assets/js/2.bf2f184f.js"><link rel="prefetch" href="/front-end-notebook/assets/js/3.258831e3.js"><link rel="prefetch" href="/front-end-notebook/assets/js/4.8472e96b.js"><link rel="prefetch" href="/front-end-notebook/assets/js/5.2ca75bc5.js"><link rel="prefetch" href="/front-end-notebook/assets/js/6.5a2ab0bd.js"><link rel="prefetch" href="/front-end-notebook/assets/js/7.1d3ba66e.js"><link rel="prefetch" href="/front-end-notebook/assets/js/8.6bce2a5e.js"><link rel="prefetch" href="/front-end-notebook/assets/js/9.863803bc.js"><link rel="prefetch" href="/front-end-notebook/assets/js/10.331bdaa4.js"><link rel="prefetch" href="/front-end-notebook/assets/js/11.e32eb035.js"><link rel="prefetch" href="/front-end-notebook/assets/js/12.072b159e.js"><link rel="prefetch" href="/front-end-notebook/assets/js/13.6a9b4bb1.js"><link rel="prefetch" href="/front-end-notebook/assets/js/14.1c36d209.js"><link rel="prefetch" href="/front-end-notebook/assets/js/15.a18af4b4.js"><link rel="prefetch" href="/front-end-notebook/assets/js/16.1ce49ff8.js"><link rel="prefetch" href="/front-end-notebook/assets/js/17.1007369a.js"><link rel="prefetch" href="/front-end-notebook/assets/js/18.a2bda79d.js"><link rel="prefetch" href="/front-end-notebook/assets/js/19.f636e12c.js"><link rel="prefetch" href="/front-end-notebook/assets/js/20.a22f1654.js"><link rel="prefetch" href="/front-end-notebook/assets/js/21.45284ef6.js"><link rel="prefetch" href="/front-end-notebook/assets/js/22.88123ebb.js"><link rel="prefetch" href="/front-end-notebook/assets/js/23.16361435.js"><link rel="prefetch" href="/front-end-notebook/assets/js/24.248abcce.js"><link rel="prefetch" href="/front-end-notebook/assets/js/25.c7f9dad2.js"><link rel="prefetch" href="/front-end-notebook/assets/js/26.fd6904dd.js"><link rel="prefetch" href="/front-end-notebook/assets/js/27.3555bd73.js"><link rel="prefetch" href="/front-end-notebook/assets/js/28.ba1a4556.js"><link rel="prefetch" href="/front-end-notebook/assets/js/29.0b79ff41.js"><link rel="prefetch" href="/front-end-notebook/assets/js/30.d578bfe2.js"><link rel="prefetch" href="/front-end-notebook/assets/js/31.0a330979.js"><link rel="prefetch" href="/front-end-notebook/assets/js/32.07bed2e2.js"><link rel="prefetch" href="/front-end-notebook/assets/js/33.badde425.js"><link rel="prefetch" href="/front-end-notebook/assets/js/34.7cf9cc4a.js"><link rel="prefetch" href="/front-end-notebook/assets/js/35.3efe7dc0.js"><link rel="prefetch" href="/front-end-notebook/assets/js/36.89e0a1de.js"><link rel="prefetch" href="/front-end-notebook/assets/js/37.a3852ab4.js"><link rel="prefetch" href="/front-end-notebook/assets/js/38.21a53612.js"><link rel="prefetch" href="/front-end-notebook/assets/js/39.bc306e8d.js"><link rel="prefetch" href="/front-end-notebook/assets/js/40.aa52254e.js"><link rel="prefetch" href="/front-end-notebook/assets/js/41.d4f76858.js"><link rel="prefetch" href="/front-end-notebook/assets/js/42.44fa986b.js"><link rel="prefetch" href="/front-end-notebook/assets/js/43.2ff3a645.js"><link rel="prefetch" href="/front-end-notebook/assets/js/44.649b9463.js"><link rel="prefetch" href="/front-end-notebook/assets/js/45.2ffa007f.js"><link rel="prefetch" href="/front-end-notebook/assets/js/46.b015a4c1.js"><link rel="prefetch" href="/front-end-notebook/assets/js/47.b3fd7323.js"><link rel="prefetch" href="/front-end-notebook/assets/js/48.2e38876d.js"><link rel="prefetch" href="/front-end-notebook/assets/js/49.276abcad.js"><link rel="prefetch" href="/front-end-notebook/assets/js/50.088e0ef2.js"><link rel="prefetch" href="/front-end-notebook/assets/js/51.e3f56b26.js"><link rel="prefetch" href="/front-end-notebook/assets/js/52.55ce2634.js"><link rel="prefetch" href="/front-end-notebook/assets/js/53.ebd5a2e3.js"><link rel="prefetch" href="/front-end-notebook/assets/js/54.80a9c3fd.js"><link rel="prefetch" href="/front-end-notebook/assets/js/55.eef7ffe8.js"><link rel="prefetch" href="/front-end-notebook/assets/js/56.6d9c4714.js"><link rel="prefetch" href="/front-end-notebook/assets/js/57.03dbec19.js"><link rel="prefetch" href="/front-end-notebook/assets/js/58.57ccfeed.js"><link rel="prefetch" href="/front-end-notebook/assets/js/59.1c7f3c98.js"><link rel="prefetch" href="/front-end-notebook/assets/js/60.a623eee4.js"><link rel="prefetch" href="/front-end-notebook/assets/js/61.15476a2d.js"><link rel="prefetch" href="/front-end-notebook/assets/js/62.1a757309.js"><link rel="prefetch" href="/front-end-notebook/assets/js/63.da41ed83.js"><link rel="prefetch" href="/front-end-notebook/assets/js/64.dcdfdec0.js"><link rel="prefetch" href="/front-end-notebook/assets/js/65.b52bcac2.js"><link rel="prefetch" href="/front-end-notebook/assets/js/66.f62c8593.js"><link rel="prefetch" href="/front-end-notebook/assets/js/0.29014ee9.js"><link rel="prefetch" href="/front-end-notebook/assets/js/68.54cf8ca5.js"><link rel="prefetch" href="/front-end-notebook/assets/js/69.d6283727.js"><link rel="prefetch" href="/front-end-notebook/assets/js/70.f8b2c9e6.js"><link rel="prefetch" href="/front-end-notebook/assets/js/71.d6b3f4b3.js"><link rel="prefetch" href="/front-end-notebook/assets/js/72.6d6e06bd.js"><link rel="prefetch" href="/front-end-notebook/assets/js/73.154dae47.js"><link rel="prefetch" href="/front-end-notebook/assets/js/74.7455fffc.js"><link rel="prefetch" href="/front-end-notebook/assets/js/75.f44b5aaf.js"><link rel="prefetch" href="/front-end-notebook/assets/js/76.8578202f.js"><link rel="prefetch" href="/front-end-notebook/assets/js/77.494adfd9.js"><link rel="prefetch" href="/front-end-notebook/assets/js/78.068478f0.js"><link rel="prefetch" href="/front-end-notebook/assets/js/79.1ef9fc22.js"><link rel="prefetch" href="/front-end-notebook/assets/js/80.2b9d7b16.js"><link rel="prefetch" href="/front-end-notebook/assets/js/81.53e23e1f.js"><link rel="prefetch" href="/front-end-notebook/assets/js/82.cbf5ddf4.js"><link rel="prefetch" href="/front-end-notebook/assets/js/83.08ed56cc.js"><link rel="prefetch" href="/front-end-notebook/assets/js/84.c70d397d.js"><link rel="prefetch" href="/front-end-notebook/assets/js/85.b7a27a6a.js"><link rel="prefetch" href="/front-end-notebook/assets/js/86.d5893eaa.js"><link rel="prefetch" href="/front-end-notebook/assets/js/87.9fb2d8bc.js"><link rel="prefetch" href="/front-end-notebook/assets/js/88.e98425da.js"><link rel="prefetch" href="/front-end-notebook/assets/js/89.f33fee26.js"><link rel="prefetch" href="/front-end-notebook/assets/js/91.97a7a8e7.js"><link rel="prefetch" href="/front-end-notebook/assets/js/92.5668df8c.js"><link rel="prefetch" href="/front-end-notebook/assets/js/93.7af12094.js"><link rel="prefetch" href="/front-end-notebook/assets/js/94.795f8de3.js"><link rel="prefetch" href="/front-end-notebook/assets/js/95.6553203e.js"><link rel="prefetch" href="/front-end-notebook/assets/js/96.729deb3f.js"><link rel="prefetch" href="/front-end-notebook/assets/js/97.dd9274d4.js"><link rel="prefetch" href="/front-end-notebook/assets/js/98.3dfdfcef.js"><link rel="prefetch" href="/front-end-notebook/assets/js/99.755584ee.js"><link rel="prefetch" href="/front-end-notebook/assets/js/100.aa58155a.js"><link rel="prefetch" href="/front-end-notebook/assets/js/101.889d687a.js"><link rel="prefetch" href="/front-end-notebook/assets/js/102.5cb8ce37.js"><link rel="prefetch" href="/front-end-notebook/assets/js/103.4dc74080.js"><link rel="prefetch" href="/front-end-notebook/assets/js/104.9744faf2.js"><link rel="prefetch" href="/front-end-notebook/assets/js/105.470931ca.js"><link rel="prefetch" href="/front-end-notebook/assets/js/106.c4a3b4e5.js"><link rel="prefetch" href="/front-end-notebook/assets/js/107.d8b60ab8.js"><link rel="prefetch" href="/front-end-notebook/assets/js/108.0c212f93.js"><link rel="prefetch" href="/front-end-notebook/assets/js/109.23d78e83.js"><link rel="prefetch" href="/front-end-notebook/assets/js/110.aae413d6.js"><link rel="prefetch" href="/front-end-notebook/assets/js/111.e782a63e.js"><link rel="prefetch" href="/front-end-notebook/assets/js/112.13491f7c.js"><link rel="prefetch" href="/front-end-notebook/assets/js/113.a8166df8.js"><link rel="prefetch" href="/front-end-notebook/assets/js/114.97c61817.js"><link rel="prefetch" href="/front-end-notebook/assets/js/115.b63a7845.js"><link rel="prefetch" href="/front-end-notebook/assets/js/116.5a3a597d.js"><link rel="prefetch" href="/front-end-notebook/assets/js/117.d02866e2.js"><link rel="prefetch" href="/front-end-notebook/assets/js/118.6b496f02.js"><link rel="prefetch" href="/front-end-notebook/assets/js/119.50ca8d77.js"><link rel="prefetch" href="/front-end-notebook/assets/js/120.9301b6a0.js"><link rel="prefetch" href="/front-end-notebook/assets/js/121.21c40da2.js"><link rel="prefetch" href="/front-end-notebook/assets/js/122.4b77c6a2.js"><link rel="prefetch" href="/front-end-notebook/assets/js/123.846c680d.js"><link rel="prefetch" href="/front-end-notebook/assets/js/124.39631397.js"><link rel="prefetch" href="/front-end-notebook/assets/js/125.d0c28949.js"><link rel="prefetch" href="/front-end-notebook/assets/js/126.16f0028f.js"><link rel="prefetch" href="/front-end-notebook/assets/js/127.a3edca74.js"><link rel="prefetch" href="/front-end-notebook/assets/js/128.dea5f331.js"><link rel="prefetch" href="/front-end-notebook/assets/js/129.a25b7324.js"><link rel="prefetch" href="/front-end-notebook/assets/js/130.d4494c60.js"><link rel="prefetch" href="/front-end-notebook/assets/js/131.f7cdb1cf.js">
    <link rel="stylesheet" href="/front-end-notebook/assets/css/132.styles.fbd8f7d1.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div><a href="/front-end-notebook/" class="home-link router-link-active"><!----><span class="site-name">
      Garrik 的笔记
    </span></a><div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""><!----></div><nav class="nav-links can-hide"><div class="nav-item"><a href="/front-end-notebook/" class="nav-link">主页</a></div><!----></nav></div></header><div class="sidebar-mask"></div><div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/front-end-notebook/" class="nav-link">主页</a></div><!----></nav><ul class="sidebar-links"><li><div class="sidebar-group first"><p class="sidebar-heading open"><span>作用域</span><!----></p><ul class="sidebar-group-items"><li><a href="/front-end-notebook/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/javascript/%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8/%E4%BD%9C%E7%94%A8%E5%9F%9F.html#什么是作用域" class="sidebar-link">什么是作用域</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front-end-notebook/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/javascript/%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8/%E4%BD%9C%E7%94%A8%E5%9F%9F.html#传统编译原理" class="sidebar-link">传统编译原理</a></li><li class="sidebar-sub-header"><a href="/front-end-notebook/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/javascript/%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8/%E4%BD%9C%E7%94%A8%E5%9F%9F.html#初步理解作用域" class="sidebar-link">初步理解作用域</a></li><li class="sidebar-sub-header"><a href="/front-end-notebook/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/javascript/%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8/%E4%BD%9C%E7%94%A8%E5%9F%9F.html#作用域嵌套" class="sidebar-link">作用域嵌套</a></li></ul></li><li><a href="/front-end-notebook/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/javascript/%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8/%E4%BD%9C%E7%94%A8%E5%9F%9F.html#词法作用域" class="sidebar-link">词法作用域</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front-end-notebook/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/javascript/%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8/%E4%BD%9C%E7%94%A8%E5%9F%9F.html#词法阶段" class="sidebar-link">词法阶段</a></li><li class="sidebar-sub-header"><a href="/front-end-notebook/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/javascript/%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8/%E4%BD%9C%E7%94%A8%E5%9F%9F.html#欺骗词法" class="sidebar-link">欺骗词法</a></li></ul></li><li><a href="/front-end-notebook/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/javascript/%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8/%E4%BD%9C%E7%94%A8%E5%9F%9F.html#函数作用域-块作用域" class="sidebar-link">函数作用域 &amp; 块作用域</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front-end-notebook/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/javascript/%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8/%E4%BD%9C%E7%94%A8%E5%9F%9F.html#为什么要-隐藏" class="sidebar-link">为什么要 &quot;隐藏&quot;?</a></li><li class="sidebar-sub-header"><a href="/front-end-notebook/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/javascript/%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8/%E4%BD%9C%E7%94%A8%E5%9F%9F.html#函数作用域" class="sidebar-link">函数作用域</a></li><li class="sidebar-sub-header"><a href="/front-end-notebook/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/javascript/%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8/%E4%BD%9C%E7%94%A8%E5%9F%9F.html#块作用域" class="sidebar-link">块作用域</a></li></ul></li><li><a href="/front-end-notebook/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/javascript/%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8/%E4%BD%9C%E7%94%A8%E5%9F%9F.html#提升" class="sidebar-link">提升</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front-end-notebook/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/javascript/%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8/%E4%BD%9C%E7%94%A8%E5%9F%9F.html#函数优先" class="sidebar-link">函数优先</a></li></ul></li><li><a href="/front-end-notebook/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/javascript/%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8/%E4%BD%9C%E7%94%A8%E5%9F%9F.html#作用域闭包-closure" class="sidebar-link">作用域闭包 (Closure)</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front-end-notebook/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/javascript/%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8/%E4%BD%9C%E7%94%A8%E5%9F%9F.html#循环和闭包" class="sidebar-link">循环和闭包</a></li></ul></li></ul></div></li></ul></div><div class="page"><div class="content"><h1 id="作用域"><a href="#作用域" aria-hidden="true" class="header-anchor">#</a> 作用域</h1><h2 id="什么是作用域"><a href="#什么是作用域" aria-hidden="true" class="header-anchor">#</a> 什么是作用域</h2><p>简单来说, 『 作用域 』就是一套用来储存变量, 操纵变量的<strong>规则</strong>.</p><h3 id="传统编译原理"><a href="#传统编译原理" aria-hidden="true" class="header-anchor">#</a> 传统编译原理</h3><p>尽管我们通常将 JavaScript 归类为“动态”或“解释执行”语言，但事实上它是一门编译语言。但与传统的编译语言不同，它不是提前编译的，JavaScript 的编译过程不是发生在构建之前的。简单地说，任何 JavaScript 代码片段在执行前都要进行编译（通常 就在 执行前）。</p><p>在<strong>传统编译语言</strong>的流程中，程序中的一段源代码在执行之前会经历三个步骤，统称为“编译”。</p><ul><li><p><strong>分词/词法分析</strong>（Tokenizing/Lexing）
将由字符组成的 字符串 分解成（对编程语言来说）有意义的 代码块，这些 代码块 被称为 『 词法单元（token） 』。例如，<code>var a = 2;</code> 这段程序通常会被分解成为下面这些词法单元： <code>var</code>, <code>a</code>, <code>=</code>, <code>2</code>, <code>;</code>.</p></li><li><p><strong>解析/语法分析</strong>（Parsing）
将 『 词法单元流（数组） 』转换成一个由元素逐级嵌套所组成的代表了程序语法
结构的树, 被称为 『 抽象语法树 』（Abstract Syntax Tree，AST）。<code>var a = 2;</code> 的抽象语法树中可能会有一个叫作 <code>VariableDeclaration</code> 的顶级节点，接下来是一个叫作 <code>Identifier</code> （它的值是 <code>a</code> ）的子节点，以及一个叫作 <code>AssignmentExpression</code> 的子节点。 <code>AssignmentExpression</code> 节点有一个叫作 <code>NumericLiteral</code> （它的值是 <code>2</code> ）的子节点。</p></li><li><p><strong>代码生成</strong>
将 抽象语法树 (AST) 转换为 可执行代码的过程 称被称为代码生成。这个过程与语言、目标平台等相关。简单来说就是有某种方法可以将 <code>var a = 2;</code> 的 抽象语法树 (AST) 转化为一组『 机器指令 』，用来创建一个叫作 <code>a</code> 的变量（包括分配内存等），并将一个值储存在 <code>a</code> 中。</p></li></ul><h3 id="初步理解作用域"><a href="#初步理解作用域" aria-hidden="true" class="header-anchor">#</a> 初步理解作用域</h3><p>下面用拟人对话的形式, 模拟 <code>var a = 2;</code> 这段代码的处理过程.</p><p>参与到的角色有:</p><ul><li><p>引擎
从头到尾负责整个 JavaScript 程序的编译及执行过程。</p></li><li><p>编译器
引擎的好朋友之一，负责语法分析及代码生成等</p></li><li><p>作用域
引擎的另一位好朋友， 负责收集并维护所有声明的标识符（变量），并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。</p></li></ul><p>编译器首先会将这段程序分解成词法单元，然后将词法单元解析成一个树结构。当编译器开始进行代码生成时，它会进行如下处理:</p><ul><li><p>遇到 <code>var a</code> ，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为 <code>a</code></p></li><li><p>接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理 <code>a = 2</code> 这个赋值操作。 引擎运行时会首先询问作用域， 在当前的作用域集合中是否存在一个叫作 <code>a</code> 的变量。 如果是，引擎就会使用这个变量；如果否，引擎会继续查找该变量.如果引擎最终找到了 <code>a</code> 变量， 就会将 <code>2</code> 赋值给它。 否则引擎就会抛出异常.</p></li></ul><h3 id="作用域嵌套"><a href="#作用域嵌套" aria-hidden="true" class="header-anchor">#</a> 作用域嵌套</h3><p>实际情况中，通常需要同时顾及几个作用域。当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域（也就是全局作用域）为止。</p><h2 id="词法作用域"><a href="#词法作用域" aria-hidden="true" class="header-anchor">#</a> 词法作用域</h2><p>在第1章中，我们将“作用域”定义为一套规则，这套规则用来管理引擎如何在当前作用域以及嵌套的子作用域中根据标识符名称进行变量查找。</p><p>作用域共有两种主要的工作模型。第一种是最为普遍的，被大多数编程语言所采用的 <strong>词法作用域</strong>，另外一种叫作 <strong>动态作用域</strong></p><h3 id="词法阶段"><a href="#词法阶段" aria-hidden="true" class="header-anchor">#</a> 词法阶段</h3><p>大部分标准语言编译器的第一个工作阶段叫作<strong>词法化</strong>（单词化）</p><p>简单地说，<strong>词法作用域就是定义在词法阶段的作用域</strong>。</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> b <span class="token operator">=</span> a <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">bar</span><span class="token punctuation">(</span> b <span class="token operator">*</span> <span class="token number">3</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">foo</span><span class="token punctuation">(</span> <span class="token number">2</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2, 4, 12</span>
</code></pre></div><p>在这个例子中有三个逐级嵌套的作用域。</p><p>作用域的结构和互相之间的位置关系给引擎提供了足够的位置信息，引擎用这些信息来查找标识符的位置。</p><p>作用域查找始终从运行时所处的最内部作用域开始，逐级向外或者说向上进行，直到遇见第一个匹配的标识符为止。<strong>作用域查找会在找到第一个匹配的标识符时停止。</strong></p><p>引擎执行<code>console.log(..)</code>声明，并查找<code>a</code>、<code>b</code> 和 <code>c</code> 三个变量的引用。它首先从最内部的作用域，也就是<code>bar(..)</code>函数的作用域气泡开始查找。引擎无法在这里找到<code>a</code>，因此会去上一级到所嵌套的<code>foo(..)</code>的作用域中继续查找。在这里找到了<code>a</code>，因此引擎使用了这个引用。对<code>b</code>来讲也是一样的。而对<code>c</code>来说，引擎在<code>bar(..)</code>中就找到了它。</p><h3 id="欺骗词法"><a href="#欺骗词法" aria-hidden="true" class="header-anchor">#</a> 欺骗词法</h3><p>无论函数在哪里被调用，也无论它如何被调用，<strong>函数的词法作用域都只由函数被声明时所处的位置决定</strong>。</p><p>如果词法作用域完全由写代码期间函数所声明的位置来定义，怎样才能在运行时来“修改”（也可以说欺骗）词法作用域呢？</p><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>欺骗词法作用域会导致性能下降。</p></div><p>JavaScript 中有两种机制来实现这个目的:</p><ul><li><code>eval</code></li><li><code>with</code></li></ul><h4 id="eval"><a href="#eval" aria-hidden="true" class="header-anchor">#</a><code>eval</code></h4><p><code>eval(..)</code> 函数可以接受一个字符串为参数，并将其中的内容视为好像在书写时就存在于程序中这个位置的代码, 换句话说，可以在你写的代码中用程序生成代码并运行，就好像（词法期）代码就在那。</p><p>在执行· 之后的代码时，引擎并不“在意”前面的代码是以动态形式插入进来，并对词法作用域的环境进行修改的。引擎只会如往常地进行词法作用域查找。</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">eval</span><span class="token punctuation">(</span> str <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 欺骗！</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a<span class="token punctuation">,</span> b <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token function">foo</span><span class="token punctuation">(</span> <span class="token string">&quot;var b = 3;&quot;</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1, 3</span>
</code></pre></div><p><code>var b = 3;</code> 声明了一个新的变量 <code>b</code>。 因此它对已经存在的<code>foo(..)</code> 的词法作用域进行了修改。也就是这段代码实际上在<code>foo(..)</code>内部创建了一个变量<code>b</code>，并遮蔽了外部（全局）作用域中的同名变量。</p><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>在严格模式的程序中，<code>eval(..)</code> 在运行时有其自己的词法作用域，意味着其中的声明无法修改所在的作用域。</p></div><h4 id="with"><a href="#with" aria-hidden="true" class="header-anchor">#</a><code>with</code></h4><p><code>with</code> 通常被当作重复引用同一个对象中的多个属性的快捷方式</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
    a<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
    b<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
    c<span class="token punctuation">:</span> <span class="token number">3</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 单调乏味的重复&quot;obj&quot;</span>
obj<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
obj<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
obj<span class="token punctuation">.</span>c <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>

<span class="token comment">// 简单的快捷方式</span>
<span class="token keyword">with</span> <span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
    b <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
    c <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>再看另外一个例子：</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">with</span> <span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> o1 <span class="token operator">=</span> <span class="token punctuation">{</span>
    a<span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> o2 <span class="token operator">=</span> <span class="token punctuation">{</span>
    b<span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">foo</span><span class="token punctuation">(</span> o1 <span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> o1<span class="token punctuation">.</span>a <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>

<span class="token function">foo</span><span class="token punctuation">(</span> o2 <span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> o2<span class="token punctuation">.</span>a <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2, a 被泄漏到全局作用域上了！</span>
</code></pre></div><p>这个例子中创建了 <code>o1</code> 和 <code>o2</code> 两个对象。其中一个具有<code>a</code>属性，另外一个没有。<code>foo(..)</code> 函数接受一个 <code>obj</code> 参数，该参数是一个对象引用，并对这个对象引用执行了<code>with(obj) {..}</code>。</p><p>在 <code>with</code> 块内部，我们写的代码看起来只是对变量 <code>a</code> 进行简单的词法引用，实际上就是一个
LHS 引用，并将2 赋值给它。</p><p>当我们将 <code>o1</code> 传递进去，<code>a ＝ 2</code> 赋值操作找到了<code>o1.a</code> 并将<code>2</code> 赋值给它.  而当 <code>o2</code> 传递进去，<code>o2</code> 并没有<code>a</code> 属性，因此不会创建这个属性，<code>o2.a</code> 保持 <code>undefined</code>。但是可以注意到一个奇怪的副作用，实际上<code>a = 2</code> 赋值操作创建了一个全局的变量<code>a</code>。</p><p><code>with</code> 可以<strong>将一个没有或有多个属性的对象处理为一个 完全隔离 的词法作用域</strong>，因此这个对象的属性也会被处理为定义在这个作用域中的词法标识符。</p><p>也就是， <code>o2</code> 的作用域、<code>foo(..)</code> 的作用域和全局作用域中都没有找到标识符<code>a</code>，因此当<code>a＝2</code> 执行
时，自动创建了一个全局变量（因为是非严格模式）。</p><h4 id="性能问题"><a href="#性能问题" aria-hidden="true" class="header-anchor">#</a> 性能问题</h4><p><code>eval(..)</code> 和 <code>with</code> 会在运行时修改或创建新的作用域，以此来欺骗其他在书写时定义的词
法作用域。</p><p>但那又怎样呢？如果它们能实现更复杂的功能，并且代码更具有扩展性，难道不是非常好的功能吗？<strong>答案是否定的</strong>。</p><p>JavaScript 引擎会在编译阶段进行数项的性能优化。其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。</p><p>但如果引擎在代码中发现了<code>eval(..)</code> 或<code>with</code>，它只能简单地假设关于标识符位置的判断都是无效的，因为无法在词法分析阶段明确知道<code>eval(..)</code> 会接收到什么代码，这些代码会如何对作用域进行修改，也无法知道传递给<code>with</code> 用来创建新词法作用域的对象的内容到底是什么。可能所有的优化可能都是无意义的，因此最简
单的做法就是完全不做任何优化。<strong>如果没有这些优化，代码会运行得更慢</strong></p><p>另外一个不推荐使用 <code>eval(..)</code> 和 <code>with</code> 的原因是会被 <strong>严格模式</strong> 所限制。</p><h2 id="函数作用域-块作用域"><a href="#函数作用域-块作用域" aria-hidden="true" class="header-anchor">#</a> 函数作用域 &amp; 块作用域</h2><p>很多人认为 JavaScript 具有基于函数的作用域，意味着每声明一个函数都会为其自身创建一个作用域，而其他结构都不会创建作用域。但事实上这并不完全正确.</p><p>函数作用域的含义是指，<strong>属于这个函数的全部变量都可以在整个函数的范围内使用及复用</strong></p><p>对函数的传统认知就是先声明一个函数，然后再向里面添加代码。但反过来想也可以带来 一些启示：从所写的代码中挑选出一个任意的片段，然后用函数声明对它进行包装，实际 上就是把这些代码“隐藏”起来了。实际的结果就是<strong>在这个代码片段的周围创建了一个作用域</strong>, 也就是说这段代码中的任 何声明（变量或函数）都将绑定在这个新创建的包装函数的作用域中.</p><h3 id="为什么要-隐藏"><a href="#为什么要-隐藏" aria-hidden="true" class="header-anchor">#</a> 为什么要 &quot;隐藏&quot;?</h3><h4 id="最小暴露原则"><a href="#最小暴露原则" aria-hidden="true" class="header-anchor">#</a> 最小暴露原则</h4><p>有很多原因促成了这种基于作用域的隐藏方法。 它们大都是从 &quot;最小特权原则&quot; 中引申出来 的，也叫 &quot;最小授权&quot; 或 &quot;最小暴露原则&quot;。</p><p>这个原则是指在软件设计中，应该<strong>最小限度地暴露必要内容</strong>，而将其他内容都“隐藏”起来.</p><p>如果所有的变量和函数都在全局作用域中可以访问, 这可能会暴漏过多的变量或函数，而这些变量或函数本应该是私有的.  正确的代码应该是可以阻止对这些变量或函数进行访问的。</p><h4 id="避免冲突"><a href="#避免冲突" aria-hidden="true" class="header-anchor">#</a> 避免冲突</h4><p>“隐藏”作用域中的变量和函数所带来的另一个好处，是可以避免同名标识符之间的冲突.</p><p>变量冲突的一个典型例子存在于全局作用域中。当程序中加载了多个第三方库时，如果它 们没有妥善地将内部私有的函数或变量隐藏起来，就会很容易引发冲突。</p><h3 id="函数作用域"><a href="#函数作用域" aria-hidden="true" class="header-anchor">#</a> 函数作用域</h3><p>我们已经知道， 在任意代码片段外部添加包装函数， 可以将内部的变量和函数定义“隐 藏”起来，外部作用域无法访问包装函数内部的任何内容。</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> 

<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> 
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3</span>
<span class="token punctuation">}</span> 

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
</code></pre></div><p>上面这段代码中, 声明一个具名函数 <code>foo()</code> ，意味着 <code>foo</code> 这个名称本身“<strong>污染</strong>”了所在作用域（在这个 例子中是全局作用域）。其次，必须显式地通过函数名调用这个函数才能运行其中的代码。</p><p>如果函数不需要函数名（或者至少函数名可以不污染所在作用域），并且能够自动运行， 这将会更加理想。</p><p>JavaScript 提供了能够同时解决这两个问题的方案:</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> 

<span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> 
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
</code></pre></div><p>上面代码中, 函数会被<strong>当作函数表达式</strong>而不是一个标准的函数声明来处理。</p><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>区分函数声明和表达式最简单的方法是看 <code>function</code> 关键字出现在声明中的位置.  如果 <code>function</code> 是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。</p></div><p>函数声明和函数表达式之间最重要的区别是它们的<strong>名称标识符将会绑定在何处</strong>。</p><ul><li>函数声明, 变量名绑定在所在作用域</li><li>函数表达式, 变量名绑定在其自身的函数中. <strong>变量名被隐藏在自身中</strong>意味着不会非必要地污染外部作用域。</li></ul><h4 id="匿名-具名"><a href="#匿名-具名" aria-hidden="true" class="header-anchor">#</a> 匿名 &amp; 具名</h4><p>函数表达式可以是匿名的，而函数声明则不可以省略函数名.</p><p>匿名函数表达式书写起来简单快捷，很多库和工具也倾向鼓励使用这种风格的代码。但是 它也有几个<strong>缺点</strong>需要考虑:</p><ul><li>匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难。</li><li>如果没有函数名，当函数需要引用自身时只能使用已经过期的 <code>arguments.callee</code> 引用， 比如在递归中。另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑自身。</li><li>匿名函数省略了对于代码可读性 / 可理解性很重要的函数名。</li></ul><p><strong>给函数表达式指定一个函数名</strong>可以有效解决以上问题。始终给函数表达式命名是一个最佳实践：</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token function">setTimeout</span><span class="token punctuation">(</span> <span class="token keyword">function</span> <span class="token function">timeoutHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// &lt;-- 快看，我有名字了！</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token string">&quot;I waited 1 second!&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="立即执行函数表达式"><a href="#立即执行函数表达式" aria-hidden="true" class="header-anchor">#</a> 立即执行函数表达式</h4><p>由于函数被包含在一对 <code>( )</code> 括号内部，因此成为了一个表达式，通过在末尾加上另外一个 <code>( )</code> 可以立即执行这个函数，比如 <code>(function foo(){ .. })()</code> 。第一个 <code>( )</code> 将函数变成表达式，第二个 <code>( )</code> 执行了这个函数。</p><p>这种模式很常见，术语叫做 &quot;IIFE&quot;，<strong>立即执行函数表达式</strong>（Immediately Invoked Function Expression）</p><p>相较于传统的 IIFE 形式，很多人都更喜欢另一个改进的形式：<code>(function(){ .. }())</code>, 第二种形式中用来调用的 <code>()</code> 括号被移进了用来包装的 <code>( )</code> 括号中。</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 1</span>
<span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 2</span>
<span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p><strong>这两种形式在功能上是一致的。选择哪个全凭个人喜好</strong>。</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>global<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>global<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>可以从外部作用域传递任何你需要的东西，并将变量命名为任何你觉得合适的名字。这对于改进代码风格是非常有帮助的。在代码风格上对全局对象的引用变得比引用一个没有 “全局” 字样的变量更加清晰。</p><h3 id="块作用域"><a href="#块作用域" aria-hidden="true" class="header-anchor">#</a> 块作用域</h3><p>在 JavaScript 中 <code>{ }</code> 并不会创建一个块作用域.</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> i <span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
</code></pre></div><p>我们在 <code>for</code> 循环的头部直接定义了变量 <code>i</code> ，通常是因为只想在 <code>for</code> 循环内部的上下文中使 用 <code>i</code> ，而忽略了 <code>i</code> 会被绑定在外部作用域（函数或全局）中的事实。</p><p>可以通过下面几种方法实现块作用域:</p><h4 id="with-2"><a href="#with-2" aria-hidden="true" class="header-anchor">#</a> with</h4><p>用 <code>with</code> 从对象中创建出的作用域仅在 <code>with</code> 声明中而非外 部作用域中有效。</p><h4 id="try-catch"><a href="#try-catch" aria-hidden="true" class="header-anchor">#</a> try/catch</h4><p>JavaScript 的 ES3 规范中规定 <code>try / catch</code> 的 <code>catch</code> 分句会创建一个块作用域，其中声明的变量仅在 <code>catch</code> 内部有效。</p><h4 id="let"><a href="#let" aria-hidden="true" class="header-anchor">#</a> let</h4><p><code>let</code> 关键字可以将变量绑定到所在的任意作用域中（通常是 <code>{ .. }</code> 内部）。换句话说， <code>let</code> 为其声明的变量隐式地了所在的块作用域。<code>let</code> 进行的声明不会在块作用域中进行提升。声明的代码被运行之前，声明并不 “存在”。</p><h4 id="const"><a href="#const" aria-hidden="true" class="header-anchor">#</a> const</h4><p><code>const</code>，同样可以用来创建块作用域变量， 但其值是固定的 （常量）。之后任何试图修改值的操作都会引起错误。</p><h2 id="提升"><a href="#提升" aria-hidden="true" class="header-anchor">#</a> 提升</h2><p>直觉上会认为 JavaScript 代码在执行时是由上到下一行一行执行的。但实际上这并不完全 正确，有一种特殊情况会导致这个假设是错误的。</p><div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">// underfined</span>

<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
</code></pre></div><p>前面说, 引擎会在解释 JavaScript 代码之前首先对其进行编译. 编译阶段中的一部分工作就是找到所有的声明，并用合适的作用域将它们关联起来, 也正是词法作用域 的核心内容。</p><p>因此，<strong>包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理</strong>。</p><p><code>var a = 2;</code> 会被看作两个声明, <code>var a;</code> 和 <code>a = 2;</code> 第一个定义声明是在 &quot;编译阶段&quot; 进行的。第二个赋值声明会被留在原地等待 &quot;执行阶段&quot;。</p><p>前面的代码实际是按照以下流程处理的:</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> a<span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">// underfined</span>

a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
</code></pre></div><p>这个过程就好像变量和函数声明从它们在代码中出现的位置被 “移动” 到了最上面。这个过程就叫作 &quot;<strong>提升</strong>&quot; 。<strong>只有声明本身会被提升，而赋值或其他运行逻辑会留在原地</strong> 。</p><h3 id="函数优先"><a href="#函数优先" aria-hidden="true" class="header-anchor">#</a> 函数优先</h3><p>函数声明和变量声明都会被提升。但是<strong>函数会首先被提升，然后才是变量。</strong></p><p>一个普通块内部的函数声明通常会被提升到所在作用域的顶部，这个过程不会像下面的代码预想的那样可以被条件判断所控制.  因此, 应该尽可能<strong>避免在块内部声明函数</strong>。</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot; b &quot; </span>

<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> 

<span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token punctuation">}</span> 
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;b&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token punctuation">}</span> 
<span class="token punctuation">}</span>
</code></pre></div><h2 id="作用域闭包-closure"><a href="#作用域闭包-closure" aria-hidden="true" class="header-anchor">#</a> 作用域闭包 (Closure)</h2><p>当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
     
    <span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> bar<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> baz <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">baz</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
</code></pre></div><p>函数 <code>bar()</code> 的词法作用域能够访问 <code>foo()</code> 的内部作用域。将 <code>bar()</code> 函数本身 当作 一个值类型进行传递。在 <code>foo()</code> 执行后，其返回值赋值给变量 <code>baz</code> 并调用 <code>baz()</code>. 实际上只是通过<strong>不同的标识符</strong>引用调用了内部的函数 <code>bar()</code> 。<code>baz()</code> 也就有了对 <code>foo()</code> 作用域的引用，而这个<strong>引用就叫作 &quot;闭包&quot;</strong>。</p><p>再看一个例子:</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">wait</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token function">setTimeout</span><span class="token punctuation">(</span> <span class="token keyword">function</span> <span class="token function">timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> message <span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span> 

<span class="token function">wait</span><span class="token punctuation">(</span> <span class="token string">&quot;Hello, closure!&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>将一个内部函数（名为 <code>timer</code> ）传递给 <code>setTimeout(..)</code> 。 <code>timer</code> 具有涵盖 <code>wait(..)</code> 作用域的闭包, 因此还保有对变量 <code>message</code> 的引用。内置的工具函数 <code>setTimeout(..)</code> 持有对一个参数的引用，这个参数也许叫作 <code>fn</code> 或者 <code>func</code> ，或者其他类似的名字。引擎会调用这个函数，在例子中就是内部的 <code>timer</code> 函数，而词法作用域在这个过程中保持完整。</p><h3 id="循环和闭包"><a href="#循环和闭包" aria-hidden="true" class="header-anchor">#</a> 循环和闭包</h3><p>要说明闭包，<code>for</code> 循环是最常见的例子</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> i <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>正常情况下，我们对这段代码行为的预期是分别输出数字 1~5， 每秒一次，每次一个。<strong>但实际上，这段代码在运行时会以每秒一次的频率输出五次 6</strong>。</p><p>延迟函数的回调(异步)会在循环结束时才执行。因此会每次输出一个 6 出来。</p><p>我们总是想预期&quot;假设&quot;循环中的每个迭代在运行时都会给自己“捕获”一个 <code>i</code> 的副本。实际情况是尽管循环中的五个函数是在各个迭代中分别定义的，但是它们都被<strong>封闭在一个共享的全局作用域中</strong> ，因此实际上只有一个 <code>i</code> 。</p><p>前面说过, &quot;立即执行函数&quot; 会通过声明并立即执行一个函数来创建作用域。</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> j <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>也可以用 <code>let</code> 声明, 来将一个块转换成一个可以被关闭的作用域.</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> j <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>
</code></pre></div><p>前面还说过, <code>for</code> 循环头部的 <code>let</code> 声明还会有一个特殊的行为。这个行为指出变量在循环过程中不止被声明一次， 每次迭代都会声明。随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量。</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> i <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>
</code></pre></div></div><div class="page-edit"><!----><!----></div><!----></div></div></div>
    <script src="/front-end-notebook/assets/js/90.f3686cbc.js" defer></script><script src="/front-end-notebook/assets/js/app.18fe53fa.js" defer></script>
  </body>
</html>
