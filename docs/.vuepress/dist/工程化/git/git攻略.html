<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Git 攻略 | Garrik 的笔记</title>
    <meta name="description" content="这里是 Garrik 的前端笔记本">
    
    
    <link rel="preload" href="/front-end-notebook/assets/css/132.styles.fbd8f7d1.css" as="style"><link rel="preload" href="/front-end-notebook/assets/js/app.bd1d7c3a.js" as="script"><link rel="preload" href="/front-end-notebook/assets/js/42.015eb55a.js" as="script"><link rel="prefetch" href="/front-end-notebook/assets/js/67.306d290f.js"><link rel="prefetch" href="/front-end-notebook/assets/js/1.91f94162.js"><link rel="prefetch" href="/front-end-notebook/assets/js/2.bf2f184f.js"><link rel="prefetch" href="/front-end-notebook/assets/js/3.258831e3.js"><link rel="prefetch" href="/front-end-notebook/assets/js/4.8472e96b.js"><link rel="prefetch" href="/front-end-notebook/assets/js/5.2ca75bc5.js"><link rel="prefetch" href="/front-end-notebook/assets/js/6.5a2ab0bd.js"><link rel="prefetch" href="/front-end-notebook/assets/js/7.1d3ba66e.js"><link rel="prefetch" href="/front-end-notebook/assets/js/8.6bce2a5e.js"><link rel="prefetch" href="/front-end-notebook/assets/js/9.863803bc.js"><link rel="prefetch" href="/front-end-notebook/assets/js/10.331bdaa4.js"><link rel="prefetch" href="/front-end-notebook/assets/js/11.e32eb035.js"><link rel="prefetch" href="/front-end-notebook/assets/js/12.072b159e.js"><link rel="prefetch" href="/front-end-notebook/assets/js/13.6a9b4bb1.js"><link rel="prefetch" href="/front-end-notebook/assets/js/14.1c36d209.js"><link rel="prefetch" href="/front-end-notebook/assets/js/15.a18af4b4.js"><link rel="prefetch" href="/front-end-notebook/assets/js/16.1ce49ff8.js"><link rel="prefetch" href="/front-end-notebook/assets/js/17.1007369a.js"><link rel="prefetch" href="/front-end-notebook/assets/js/18.a2bda79d.js"><link rel="prefetch" href="/front-end-notebook/assets/js/19.f636e12c.js"><link rel="prefetch" href="/front-end-notebook/assets/js/20.a22f1654.js"><link rel="prefetch" href="/front-end-notebook/assets/js/21.45284ef6.js"><link rel="prefetch" href="/front-end-notebook/assets/js/22.88123ebb.js"><link rel="prefetch" href="/front-end-notebook/assets/js/23.16361435.js"><link rel="prefetch" href="/front-end-notebook/assets/js/24.248abcce.js"><link rel="prefetch" href="/front-end-notebook/assets/js/25.c7f9dad2.js"><link rel="prefetch" href="/front-end-notebook/assets/js/26.fd6904dd.js"><link rel="prefetch" href="/front-end-notebook/assets/js/27.3555bd73.js"><link rel="prefetch" href="/front-end-notebook/assets/js/28.ba1a4556.js"><link rel="prefetch" href="/front-end-notebook/assets/js/29.0b79ff41.js"><link rel="prefetch" href="/front-end-notebook/assets/js/30.d578bfe2.js"><link rel="prefetch" href="/front-end-notebook/assets/js/31.0a330979.js"><link rel="prefetch" href="/front-end-notebook/assets/js/32.07bed2e2.js"><link rel="prefetch" href="/front-end-notebook/assets/js/33.badde425.js"><link rel="prefetch" href="/front-end-notebook/assets/js/34.7cf9cc4a.js"><link rel="prefetch" href="/front-end-notebook/assets/js/35.3efe7dc0.js"><link rel="prefetch" href="/front-end-notebook/assets/js/36.89e0a1de.js"><link rel="prefetch" href="/front-end-notebook/assets/js/37.a3852ab4.js"><link rel="prefetch" href="/front-end-notebook/assets/js/38.21a53612.js"><link rel="prefetch" href="/front-end-notebook/assets/js/39.bc306e8d.js"><link rel="prefetch" href="/front-end-notebook/assets/js/40.aa52254e.js"><link rel="prefetch" href="/front-end-notebook/assets/js/41.d4f76858.js"><link rel="prefetch" href="/front-end-notebook/assets/js/43.2ff3a645.js"><link rel="prefetch" href="/front-end-notebook/assets/js/44.649b9463.js"><link rel="prefetch" href="/front-end-notebook/assets/js/45.2ffa007f.js"><link rel="prefetch" href="/front-end-notebook/assets/js/46.b015a4c1.js"><link rel="prefetch" href="/front-end-notebook/assets/js/47.b3fd7323.js"><link rel="prefetch" href="/front-end-notebook/assets/js/48.2e38876d.js"><link rel="prefetch" href="/front-end-notebook/assets/js/49.276abcad.js"><link rel="prefetch" href="/front-end-notebook/assets/js/50.088e0ef2.js"><link rel="prefetch" href="/front-end-notebook/assets/js/51.e3f56b26.js"><link rel="prefetch" href="/front-end-notebook/assets/js/52.55ce2634.js"><link rel="prefetch" href="/front-end-notebook/assets/js/53.ebd5a2e3.js"><link rel="prefetch" href="/front-end-notebook/assets/js/54.80a9c3fd.js"><link rel="prefetch" href="/front-end-notebook/assets/js/55.eef7ffe8.js"><link rel="prefetch" href="/front-end-notebook/assets/js/56.6d9c4714.js"><link rel="prefetch" href="/front-end-notebook/assets/js/57.03dbec19.js"><link rel="prefetch" href="/front-end-notebook/assets/js/58.57ccfeed.js"><link rel="prefetch" href="/front-end-notebook/assets/js/59.1c7f3c98.js"><link rel="prefetch" href="/front-end-notebook/assets/js/60.a623eee4.js"><link rel="prefetch" href="/front-end-notebook/assets/js/61.15476a2d.js"><link rel="prefetch" href="/front-end-notebook/assets/js/62.1a757309.js"><link rel="prefetch" href="/front-end-notebook/assets/js/63.da41ed83.js"><link rel="prefetch" href="/front-end-notebook/assets/js/64.dcdfdec0.js"><link rel="prefetch" href="/front-end-notebook/assets/js/65.b52bcac2.js"><link rel="prefetch" href="/front-end-notebook/assets/js/66.f62c8593.js"><link rel="prefetch" href="/front-end-notebook/assets/js/0.29014ee9.js"><link rel="prefetch" href="/front-end-notebook/assets/js/68.54cf8ca5.js"><link rel="prefetch" href="/front-end-notebook/assets/js/69.d6283727.js"><link rel="prefetch" href="/front-end-notebook/assets/js/70.f8b2c9e6.js"><link rel="prefetch" href="/front-end-notebook/assets/js/71.d6b3f4b3.js"><link rel="prefetch" href="/front-end-notebook/assets/js/72.6d6e06bd.js"><link rel="prefetch" href="/front-end-notebook/assets/js/73.154dae47.js"><link rel="prefetch" href="/front-end-notebook/assets/js/74.7455fffc.js"><link rel="prefetch" href="/front-end-notebook/assets/js/75.f44b5aaf.js"><link rel="prefetch" href="/front-end-notebook/assets/js/76.8578202f.js"><link rel="prefetch" href="/front-end-notebook/assets/js/77.494adfd9.js"><link rel="prefetch" href="/front-end-notebook/assets/js/78.068478f0.js"><link rel="prefetch" href="/front-end-notebook/assets/js/79.1ef9fc22.js"><link rel="prefetch" href="/front-end-notebook/assets/js/80.2b9d7b16.js"><link rel="prefetch" href="/front-end-notebook/assets/js/81.53e23e1f.js"><link rel="prefetch" href="/front-end-notebook/assets/js/82.cbf5ddf4.js"><link rel="prefetch" href="/front-end-notebook/assets/js/83.08ed56cc.js"><link rel="prefetch" href="/front-end-notebook/assets/js/84.c70d397d.js"><link rel="prefetch" href="/front-end-notebook/assets/js/85.b7a27a6a.js"><link rel="prefetch" href="/front-end-notebook/assets/js/86.d5893eaa.js"><link rel="prefetch" href="/front-end-notebook/assets/js/87.9fb2d8bc.js"><link rel="prefetch" href="/front-end-notebook/assets/js/88.e98425da.js"><link rel="prefetch" href="/front-end-notebook/assets/js/89.f33fee26.js"><link rel="prefetch" href="/front-end-notebook/assets/js/90.f3686cbc.js"><link rel="prefetch" href="/front-end-notebook/assets/js/91.97a7a8e7.js"><link rel="prefetch" href="/front-end-notebook/assets/js/92.5668df8c.js"><link rel="prefetch" href="/front-end-notebook/assets/js/93.7af12094.js"><link rel="prefetch" href="/front-end-notebook/assets/js/94.795f8de3.js"><link rel="prefetch" href="/front-end-notebook/assets/js/95.6553203e.js"><link rel="prefetch" href="/front-end-notebook/assets/js/96.729deb3f.js"><link rel="prefetch" href="/front-end-notebook/assets/js/97.dd9274d4.js"><link rel="prefetch" href="/front-end-notebook/assets/js/98.3dfdfcef.js"><link rel="prefetch" href="/front-end-notebook/assets/js/99.755584ee.js"><link rel="prefetch" href="/front-end-notebook/assets/js/100.aa58155a.js"><link rel="prefetch" href="/front-end-notebook/assets/js/101.889d687a.js"><link rel="prefetch" href="/front-end-notebook/assets/js/102.5cb8ce37.js"><link rel="prefetch" href="/front-end-notebook/assets/js/103.4dc74080.js"><link rel="prefetch" href="/front-end-notebook/assets/js/104.9744faf2.js"><link rel="prefetch" href="/front-end-notebook/assets/js/105.470931ca.js"><link rel="prefetch" href="/front-end-notebook/assets/js/106.c4a3b4e5.js"><link rel="prefetch" href="/front-end-notebook/assets/js/107.d8b60ab8.js"><link rel="prefetch" href="/front-end-notebook/assets/js/108.0c212f93.js"><link rel="prefetch" href="/front-end-notebook/assets/js/109.23d78e83.js"><link rel="prefetch" href="/front-end-notebook/assets/js/110.aae413d6.js"><link rel="prefetch" href="/front-end-notebook/assets/js/111.e782a63e.js"><link rel="prefetch" href="/front-end-notebook/assets/js/112.13491f7c.js"><link rel="prefetch" href="/front-end-notebook/assets/js/113.a8166df8.js"><link rel="prefetch" href="/front-end-notebook/assets/js/114.97c61817.js"><link rel="prefetch" href="/front-end-notebook/assets/js/115.b63a7845.js"><link rel="prefetch" href="/front-end-notebook/assets/js/116.5a3a597d.js"><link rel="prefetch" href="/front-end-notebook/assets/js/117.d02866e2.js"><link rel="prefetch" href="/front-end-notebook/assets/js/118.6b496f02.js"><link rel="prefetch" href="/front-end-notebook/assets/js/119.50ca8d77.js"><link rel="prefetch" href="/front-end-notebook/assets/js/120.9301b6a0.js"><link rel="prefetch" href="/front-end-notebook/assets/js/121.21c40da2.js"><link rel="prefetch" href="/front-end-notebook/assets/js/122.4b77c6a2.js"><link rel="prefetch" href="/front-end-notebook/assets/js/123.846c680d.js"><link rel="prefetch" href="/front-end-notebook/assets/js/124.39631397.js"><link rel="prefetch" href="/front-end-notebook/assets/js/125.d0c28949.js"><link rel="prefetch" href="/front-end-notebook/assets/js/126.16f0028f.js"><link rel="prefetch" href="/front-end-notebook/assets/js/127.a3edca74.js"><link rel="prefetch" href="/front-end-notebook/assets/js/128.dea5f331.js"><link rel="prefetch" href="/front-end-notebook/assets/js/129.a25b7324.js"><link rel="prefetch" href="/front-end-notebook/assets/js/130.d4494c60.js"><link rel="prefetch" href="/front-end-notebook/assets/js/131.f7cdb1cf.js">
    <link rel="stylesheet" href="/front-end-notebook/assets/css/132.styles.fbd8f7d1.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div><a href="/front-end-notebook/" class="home-link router-link-active"><!----><span class="site-name">
      Garrik 的笔记
    </span></a><div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""><!----></div><nav class="nav-links can-hide"><div class="nav-item"><a href="/front-end-notebook/" class="nav-link">主页</a></div><!----></nav></div></header><div class="sidebar-mask"></div><div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/front-end-notebook/" class="nav-link">主页</a></div><!----></nav><ul class="sidebar-links"><li><div class="sidebar-group first"><p class="sidebar-heading open"><span>Git 攻略</span><!----></p><ul class="sidebar-group-items"><li><a href="/front-end-notebook/%E5%B7%A5%E7%A8%8B%E5%8C%96/git/git%E6%94%BB%E7%95%A5.html#git-干什么的" class="sidebar-link">Git 干什么的?</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/front-end-notebook/%E5%B7%A5%E7%A8%8B%E5%8C%96/git/git%E6%94%BB%E7%95%A5.html#git-基础" class="sidebar-link">Git 基础</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front-end-notebook/%E5%B7%A5%E7%A8%8B%E5%8C%96/git/git%E6%94%BB%E7%95%A5.html#初始化仓库" class="sidebar-link">初始化仓库</a></li><li class="sidebar-sub-header"><a href="/front-end-notebook/%E5%B7%A5%E7%A8%8B%E5%8C%96/git/git%E6%94%BB%E7%95%A5.html#记录每次更新到仓库" class="sidebar-link">记录每次更新到仓库</a></li><li class="sidebar-sub-header"><a href="/front-end-notebook/%E5%B7%A5%E7%A8%8B%E5%8C%96/git/git%E6%94%BB%E7%95%A5.html#校验和" class="sidebar-link">校验和</a></li><li class="sidebar-sub-header"><a href="/front-end-notebook/%E5%B7%A5%E7%A8%8B%E5%8C%96/git/git%E6%94%BB%E7%95%A5.html#文件状态-工作区域" class="sidebar-link">文件状态 &amp; 工作区域</a></li><li class="sidebar-sub-header"><a href="/front-end-notebook/%E5%B7%A5%E7%A8%8B%E5%8C%96/git/git%E6%94%BB%E7%95%A5.html#查看提交历史" class="sidebar-link">查看提交历史</a></li><li class="sidebar-sub-header"><a href="/front-end-notebook/%E5%B7%A5%E7%A8%8B%E5%8C%96/git/git%E6%94%BB%E7%95%A5.html#打标签" class="sidebar-link">打标签</a></li></ul></li><li><a href="/front-end-notebook/%E5%B7%A5%E7%A8%8B%E5%8C%96/git/git%E6%94%BB%E7%95%A5.html#使用分支" class="sidebar-link">使用分支</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front-end-notebook/%E5%B7%A5%E7%A8%8B%E5%8C%96/git/git%E6%94%BB%E7%95%A5.html#分支简介" class="sidebar-link">分支简介</a></li><li class="sidebar-sub-header"><a href="/front-end-notebook/%E5%B7%A5%E7%A8%8B%E5%8C%96/git/git%E6%94%BB%E7%95%A5.html#新建分支" class="sidebar-link">新建分支</a></li><li class="sidebar-sub-header"><a href="/front-end-notebook/%E5%B7%A5%E7%A8%8B%E5%8C%96/git/git%E6%94%BB%E7%95%A5.html#分支管理" class="sidebar-link">分支管理</a></li><li class="sidebar-sub-header"><a href="/front-end-notebook/%E5%B7%A5%E7%A8%8B%E5%8C%96/git/git%E6%94%BB%E7%95%A5.html#变基" class="sidebar-link">变基</a></li></ul></li><li><a href="/front-end-notebook/%E5%B7%A5%E7%A8%8B%E5%8C%96/git/git%E6%94%BB%E7%95%A5.html#远程仓库" class="sidebar-link">远程仓库</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front-end-notebook/%E5%B7%A5%E7%A8%8B%E5%8C%96/git/git%E6%94%BB%E7%95%A5.html#查看远程仓库" class="sidebar-link">查看远程仓库</a></li><li class="sidebar-sub-header"><a href="/front-end-notebook/%E5%B7%A5%E7%A8%8B%E5%8C%96/git/git%E6%94%BB%E7%95%A5.html#添加远程仓库" class="sidebar-link">添加远程仓库</a></li><li class="sidebar-sub-header"><a href="/front-end-notebook/%E5%B7%A5%E7%A8%8B%E5%8C%96/git/git%E6%94%BB%E7%95%A5.html#抓取-pull-拉取-fetch" class="sidebar-link">抓取(pull) &amp; 拉取(fetch)</a></li><li class="sidebar-sub-header"><a href="/front-end-notebook/%E5%B7%A5%E7%A8%8B%E5%8C%96/git/git%E6%94%BB%E7%95%A5.html#推送到远程仓库" class="sidebar-link">推送到远程仓库</a></li><li class="sidebar-sub-header"><a href="/front-end-notebook/%E5%B7%A5%E7%A8%8B%E5%8C%96/git/git%E6%94%BB%E7%95%A5.html#查看远程仓库-2" class="sidebar-link">查看远程仓库</a></li><li class="sidebar-sub-header"><a href="/front-end-notebook/%E5%B7%A5%E7%A8%8B%E5%8C%96/git/git%E6%94%BB%E7%95%A5.html#远程仓库的移除与重命名" class="sidebar-link">远程仓库的移除与重命名</a></li></ul></li></ul></div></li></ul></div><div class="page"><div class="content"><h1 id="git-攻略"><a href="#git-攻略" aria-hidden="true" class="header-anchor">#</a> Git 攻略</h1><blockquote><p><strong>摘要</strong>: 本文讲解 Git 是什么, 有什么用, 如何用 Git 进行版本控制, 以及大厂的版本管理策略.</p></blockquote><h2 id="git-干什么的"><a href="#git-干什么的" aria-hidden="true" class="header-anchor">#</a> Git 干什么的?</h2><p><a href="https://git-scm.com/" target="_blank" rel="noopener noreferrer">Git 官网<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><p><strong>Git 是一个开源的分布式版本控制系统。</strong></p><p>版本控制是一种用来 &quot;记录文件内容变化，并且允许将来查阅特定版本修订情况的系统&quot;.  当编写文件时使用「版本控制系統」可以清楚的記錄每個檔案是誰在什麼時候加進來、什麼時候被修改或刪除。Git 是目前业界最流行的版本控制系統.</p><p>Git 是分布式的, 相比于集中式的最大区别在于每一个客户端都是一个独立的节点，在各自的节点上都有独立的一份完整的版本库。一个人修改了文件，这时只要把修改过的文件发送给别人，别人就也都能看的到了。这样做不但提高了效率，而且即使一个人的电脑出问题了，也可以直接从其他人那里克隆一份。分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活.</p><h2 id="git-基础"><a href="#git-基础" aria-hidden="true" class="header-anchor">#</a> Git 基础</h2><h3 id="初始化仓库"><a href="#初始化仓库" aria-hidden="true" class="header-anchor">#</a> 初始化仓库</h3><p>在一个目录下使用 <code>git init</code> 指令初始化這個目錄，主要目的是要讓 Git 開始對這個目錄進行版本控制。這個指令會在這個目錄裡建立了一個 <code>.git</code> 隐藏目录.  目录是 Git 来跟踪管理版本库的, 它将默认记录项目目录中任何文件的改动。如果把这个子目录删除了，这里面记录的文件版本就都没有了.</p><h3 id="记录每次更新到仓库"><a href="#记录每次更新到仓库" aria-hidden="true" class="header-anchor">#</a> 记录每次更新到仓库</h3><h4 id="检查当前文件状态"><a href="#检查当前文件状态" aria-hidden="true" class="header-anchor">#</a> 检查当前文件状态</h4><p>在一个空目录下执行 <code>git init</code>.  之后使用命令 <code>git status</code> 来查看这个目录的状态.</p><div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">git</span> status
On branch master

Initial commit

nothing to commit <span class="token punctuation">(</span>create/copy files and use <span class="token string">&quot;git add&quot;</span> to track<span class="token punctuation">)</span>
</code></pre></div><p>表示目录中没有东西可以提交.</p><h4 id="跟踪新文件"><a href="#跟踪新文件" aria-hidden="true" class="header-anchor">#</a> 跟踪新文件</h4><p>在项目下创建一个新的 README 文件。 如果之前并不存在这个文件，使用 <code>git status</code> 命令，你将看到一个新的未跟踪文件：</p><div class="language-bash extra-class"><pre class="language-bash"><code>On branch master
Untracked files:
  <span class="token punctuation">(</span>use <span class="token string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="token keyword">in</span> what will be committed<span class="token punctuation">)</span>

    readme.md

nothing added to commit but untracked files present <span class="token punctuation">(</span>use <span class="token string">&quot;git add&quot;</span> to track<span class="token punctuation">)</span>
</code></pre></div><p>在状态报告中可以看到新建的 README 文件出现在 Untracked files 下面。 未跟踪的文件意味着 Git 在之前的快照（提交）中没有这些文件.</p><p>现在用 <code>git add</code> 跟踪 <code>readme.md</code> 文件.</p><div class="language-bash extra-class"><pre class="language-bash"><code>On branch master

No commits yet

Changes to be committed:
  <span class="token punctuation">(</span>use <span class="token string">&quot;git rm --cached &lt;file&gt;...&quot;</span> to unstage<span class="token punctuation">)</span>

	new file:   readme.md
</code></pre></div><p>只要在 Changes to be committed 这行下面的，就说明是已暂存状态。 如果此时提交，那么该文件此时此刻的版本将被留存在历史记录中。</p><h4 id="暂存已修改文件"><a href="#暂存已修改文件" aria-hidden="true" class="header-anchor">#</a> 暂存已修改文件</h4><p>现在修改一下之前被跟踪的 <code>readme.md</code> 文件.  然后再执行 <code>git status</code></p><div class="language-bash extra-class"><pre class="language-bash"><code>On branch master

No commits yet

Changes to be committed:
  <span class="token punctuation">(</span>use <span class="token string">&quot;git rm --cached &lt;file&gt;...&quot;</span> to unstage<span class="token punctuation">)</span>

	new file:   readme.md

Changes not staged <span class="token keyword">for</span> commit:
  <span class="token punctuation">(</span>use <span class="token string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed<span class="token punctuation">)</span>
  <span class="token punctuation">(</span>use <span class="token string">&quot;git checkout -- &lt;file&gt;...&quot;</span> to discard changes <span class="token keyword">in</span> working directory<span class="token punctuation">)</span>

	modified:   readme.md
</code></pre></div><p><code>readme.md</code> 出现在 Changes not staged for commit 这行下面，说明已跟踪文件的内容发生了变化，但还没有放到暂存区。要暂存这次更新，需要运行 <code>git add</code> 命令。这个命令将可以理解为 “<strong>添加内容到下一次提交中</strong>” 而不是 “将一个文件添加到项目中” 要更加合适。</p><p>添加完后, 在执行 <code>git status</code></p><div class="language-bash extra-class"><pre class="language-bash"><code>On branch master

No commits yet

Changes to be committed:
  <span class="token punctuation">(</span>use <span class="token string">&quot;git rm --cached &lt;file&gt;...&quot;</span> to unstage<span class="token punctuation">)</span>

	new file:   readme.md
</code></pre></div><p>表示已暂存，下次提交时就会一并记录到仓库。</p><h4 id="提交更新"><a href="#提交更新" aria-hidden="true" class="header-anchor">#</a> 提交更新</h4><p>使用 <code>git commit</code> 命令将已暂存的文件进行提交.  这种方式会启动文本编辑器以便输入本次提交的说明。(默认会启用 shell 的环境变量 <code>$EDITOR</code> 所指定的软件，一般都是 vim 或 emacs。)</p><p>也可以在 <code>commit</code> 命令后添加 <code>-m</code> 选项，将提交信息与命令放在同一行</p><div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">git</span> commit -m <span class="token string">&quot;Story 182: Fix benchmarks for speed&quot;</span>
<span class="token punctuation">[</span>master 463dc4f<span class="token punctuation">]</span> Story 182: Fix benchmarks <span class="token keyword">for</span> speed
 2 files changed, 2 insertions<span class="token punctuation">(</span>+<span class="token punctuation">)</span>
 create mode 100644 README
</code></pre></div><p>提交后它会告诉你，当前是在哪个分支（<code>master</code>）提交的，本次提交的完整 SHA-1 校验和是什么（<code>463dc4f</code>），以及在本次提交中，有多少文件修订过，多少行添加和删改过。</p><p><code>commit</code> 命令加上 <code>-a</code> 选项，Git 就会自动把所有<strong>已经跟踪过</strong>的文件暂存起来一并提交，从而跳过 <code>git add</code> 步骤</p><p>如果此次提交暂存区没有任何变动, 想要提交需要加上<code>--allow-empty</code>参数.</p><div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">git</span> commit --allow-empty -m <span class="token string">&quot;空的&quot;</span>
<span class="token punctuation">[</span>master 76a5b84<span class="token punctuation">]</span> 空的
</code></pre></div><h4 id="状态简览"><a href="#状态简览" aria-hidden="true" class="header-anchor">#</a> 状态简览</h4><p><code>git status</code> 命令的输出十分详细，但其用语有些繁琐。 如果你使用 <code>git status -s</code> 命令或 <code>git status --short</code> 命令，你将得到一种更为紧凑的格式输出。</p><div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">git</span> status -s
 M README
MM Rakefile
A  lib/git.rb
M  lib/simplegit.rb
?? LICENSE.txt
</code></pre></div><ul><li>新添加的未跟踪文件前面有 <code>??</code> 标记，</li><li>新添加到暂存区中的文件前面有 <code>A</code> 标记，</li><li>修改过的文件前面有 <code>M</code> 标记
<ul><li>出现在右边的 <code>M</code> 表示该文件被修改了但是还没放入暂存区</li><li>出现在靠左边的 <code>M</code> 表示该文件被修改了并放入了暂存区。</li></ul></li></ul><p>向 <code>Rakefile</code> 文件前面有两个 <code>MM</code>, 表示在工作区被修改并提交到暂存区后又在工作区中被修改了，所以在暂存区和工作区都有该文件被修改了的记录。</p><h4 id="移除文件"><a href="#移除文件" aria-hidden="true" class="header-anchor">#</a> 移除文件</h4><p>如果想<strong>移除某个文件的已跟踪状态</strong>（确切地说，是从暂存区域移除）.  可以使用 <code>git rm</code> 命令.  此命令还会连带从工作目录中把指定的文件删除</p><p>如果只是简单地从工作目录中手工删除文件，运行 <code>git status</code> 时就会在 “Changes not staged for commit” 部分（也就是 未暂存清单）看到</p><p>如果<strong>文件删除之前修改过并且已经放到暂存区域</strong>的话，则必须要用强制删除选项 <code>-f</code>. 这是一种安全特性，用于防止误删还没有添加到快照的数据.</p><p>另外一种情况是，我们想<strong>把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中</strong>。换句话说，你想让文件保留在磁盘，但是并不想让 Git 继续跟踪。 当你忘记添加 .gitignore 文件，不小心把一大堆文件添加到暂存区时，这一做法尤其有用。使用 <code>--cached</code> 选项可以做到.</p><h4 id="忽略文件"><a href="#忽略文件" aria-hidden="true" class="header-anchor">#</a> 忽略文件</h4><p>有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。我们可以创建一个名为 <code>.gitignore</code> 的文件，列出要忽略的文件模式。</p><p>比如:</p><div class="language-bash extra-class"><pre class="language-bash"><code>*.<span class="token punctuation">[</span>oa<span class="token punctuation">]</span>
*~
</code></pre></div><p>第一行告诉 Git 忽略所有以 .o 或 .a 结尾的文件。第二行告诉 Git 忽略所有以波浪符（~）结尾的文件.</p><p>要养成一开始就设置好 <code>.gitignore</code> 文件的习惯，以免将来误提交无用的文件.</p><p><code>.gitignore</code> 的格式规范如下：</p><ul><li>所有空行或者以 <code>＃</code> 开头的行都会被 Git 忽略。</li><li>可以使用标准的 <code>glob</code> 模式匹配。</li><li>匹配模式可以以（<code>/</code>）开头防止递归。</li><li>匹配模式可以以（<code>/</code>）结尾指定目录。</li><li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（<code>!</code>）取反。</li></ul><p><code>glob</code> 模式是指 shell 所使用的简化了的正则表达式:</p><ul><li>星号（<code>*</code>）匹配零个或多个任意字符;</li><li><code>[abc]</code> 匹配任何一个列在方括号中的字符;</li><li>问号（<code>?</code>）只匹配一个任意字符;</li><li>如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 <code>[0-9]</code> 表示匹配所有 0 到 9 的数字）;</li><li>使用两个星号（<code>*</code>) 表示匹配任意中间目录，比如<code>a/**/z</code> 可以匹配 a/z, a/b/z 或 <code>a/b/c/z</code>等。</li></ul><p>下面有些例子:</p><div class="language-bash extra-class"><pre class="language-bash"><code><span class="token comment"># no .a files</span>
*.a

<span class="token comment"># but do track lib.a, even though you're ignoring .a files above</span>
<span class="token operator">!</span>lib.a

<span class="token comment"># only ignore the TODO file in the current directory, not subdir/TODO</span>
/TODO

<span class="token comment"># ignore all files in the build/ directory</span>
build/

<span class="token comment"># ignore doc/notes.txt, but not doc/server/arch.txt</span>
doc/*.txt

<span class="token comment"># ignore all .pdf files in the doc/ directory</span>
doc/**/*.pdf
</code></pre></div><h3 id="校验和"><a href="#校验和" aria-hidden="true" class="header-anchor">#</a> 校验和</h3><p>Git 中所有数据在存储前都计算校验和，然后以校验和来引用。 这意味着不可能在 Git 不知情时更改任何文件内容或目录内容。</p><p>Git 用以计算校验和的机制叫做 SHA-1 散列（hash，哈希）。 这是一个由 40 个十六进制字符（0-9 和 a-f）组成字符串，基于 Git 中文件的内容或目录结构计算出来。 SHA-1 哈希看起来是这样：</p><div class="language-bash extra-class"><pre class="language-bash"><code>24b9da6552252987aa493b52f8696cd6d3b00373
</code></pre></div><p>Git 数据库中保存的信息都是以文件内容的哈希值来索引.</p><h3 id="文件状态-工作区域"><a href="#文件状态-工作区域" aria-hidden="true" class="header-anchor">#</a> 文件状态 &amp; 工作区域</h3><p>在 Git 中文件有两种状态：<strong>已跟踪（tracked）</strong> 和 <strong>未跟踪（untracked）</strong></p><p>**已跟踪（tracked）**又分为：<strong>已提交（committed）</strong>、**已修改（modified）**和 <strong>已暂存（staged）</strong></p><p>被 Git 管理的项目有三个工作区域：<strong>版本库（Repository）</strong>、<strong>工作区（Working Directory）</strong> 和 <strong>暂存区（Staging Area）</strong>。</p><ul><li>工作区: 就是你在电脑里能看到的目录。</li><li>暂存区：英文叫 stage, 或 index。一般存放在<code>.git</code>目录下的 <code>index</code> 文件（<code>.git/index</code>）中，所以我们把暂存区有时也叫作索引（index）。</li><li>版本库：<code>.git</code> 目录不算工作区，而是 Git 的版本库。</li></ul><p><img src="https://i.imgur.com/qmzpPGu.jpg" alt="1352126739_7909"></p><p>当对工作区修改（或新增）的文件执行 &quot;<code>git add</code>&quot; 命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的 ID 被记录在暂存区的文件索引中。</p><p>当执行提交操作（<code>git commit</code>）时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。</p><h3 id="查看提交历史"><a href="#查看提交历史" aria-hidden="true" class="header-anchor">#</a> 查看提交历史</h3><p>想回顾提交历史需要使用 <code>git log</code> 命令</p><div class="language-bash extra-class"><pre class="language-bash"><code>garrikliu:a xiangliu$ <span class="token function">git</span> log
commit fb3afcd7ad8151207cec0ace9a6550c3e1589f81 <span class="token punctuation">(</span>HEAD<span class="token punctuation">)</span>
Author: Garrik-Liu <span class="token operator">&lt;</span>garrikliu@Gmail.com<span class="token operator">&gt;</span>
Date:   Mon Feb 4 16:55:48 2019 +0800

    deleted readme

commit 022abc8b56edac279d3aa28981913e378bca136b
Author: Garrik-Liu <span class="token operator">&lt;</span>garrikliu@Gmail.com<span class="token operator">&gt;</span>
Date:   Sun Feb 3 09:56:44 2019 +0800

    add readme.md
</code></pre></div><p>默认不用任何参数的话，<code>git log</code> 会按提交时间列出所有的更新，最近的更新排在最上面。这个命令会列出每个提交的 SHA-1 校验和、作者的名字和电子邮件地址、提交时间以及提交说明。</p><p>通过使用不同的选项参数可以帮助我们找到要找的提交.</p><p>一个常用的选项是 <code>-p</code>，用来显示每次提交的内容差异。 你也可以加上 <code>-2</code> 来仅显示最近两次提交(同理 <code>-3</code> 就是最近的三次提交)</p><p>如果你想看到每次提交的简略的统计信息，你可以使用 <code>--stat</code> 选项.  <code>--stat</code> 选项在每次提交的下面列出所有被修改过的文件、有多少文件被修改了以及被修改过的文件的哪些行被移除或是添加了。 在每次提交的最后还有一个总结。</p><div class="language-bash extra-class"><pre class="language-bash"><code>commit a11bef06a3f659402fe7563abf99ad00de2209e6
Author: Scott Chacon <span class="token operator">&lt;</span>schacon@gee-mail.com<span class="token operator">&gt;</span>
Date:   Sat Mar 15 10:31:28 2008 -0700

    first commit

 README           <span class="token operator">|</span>  6 ++++++
 Rakefile         <span class="token operator">|</span> 23 +++++++++++++++++++++++
 lib/simplegit.rb <span class="token operator">|</span> 25 +++++++++++++++++++++++++
 3 files changed, 54 insertions<span class="token punctuation">(</span>+<span class="token punctuation">)</span>
</code></pre></div><p>另外一个常用的选项是 <code>--pretty</code>。 这个选项可以指定使用不同于默认格式的方式展示提交历史。这个选项有一些内建的子选项供你使用。 比如用 <code>oneline</code> 将每个提交放在一行显示，查看的提交数很大时非常有用。 另外还有 <code>short</code>，<code>full</code> 和 <code>fuller</code> 可以用.  <code>format</code> 选项可以定制要显示的记录格式。 这样的输出对后期提取分析格外有用.  具体文档参考-<a href="https://git-scm.com/docs/pretty-formats" target="_blank" rel="noopener noreferrer">链接<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">git</span> log --pretty<span class="token operator">=</span>oneline
ca82a6dff817ec66f44342007202690a93763949 changed the version number
085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 removed unnecessary <span class="token function">test</span>
a11bef06a3f659402fe7563abf99ad00de2209e6 first commit
</code></pre></div><h3 id="打标签"><a href="#打标签" aria-hidden="true" class="header-anchor">#</a> 打标签</h3><p>Git 可以给历史中的某一个提交打上标签，以示重要。 比较有代表性的是人们会使用这个功能来标记发布结点（v1.0 等等）。</p><h4 id="列出标签"><a href="#列出标签" aria-hidden="true" class="header-anchor">#</a> 列出标签</h4><p><code>git tag</code> 列出已有标签</p><div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">git</span> tag
v0.1
v1.3
</code></pre></div><p><code>-l</code> 参数可以查号特定标签</p><div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">git</span> tag -l <span class="token string">'v1.8.5*'</span>
v1.8.5
v1.8.5-rc0
v1.8.5-rc1
v1.8.5-rc2
</code></pre></div><h4 id="创建标签"><a href="#创建标签" aria-hidden="true" class="header-anchor">#</a> 创建标签</h4><p>Git 使用两种主要类型的标签：<strong>轻量标签</strong>（lightweight）与<strong>附注标签</strong>（annotated）</p><p>一个轻量标签很像一个不会改变的分支 - 它只是一个特定提交的引用。</p><p>然而，附注标签是存储在 Git 数据库中的一个完整对象。 它们是可以被校验的；其中包含打标签者的名字、电子邮件地址、日期时间；还有一个标签信息；并且可以使用 GNU Privacy Guard （GPG）签名与验证。 通常建议创建附注标签，这样你可以拥有以上所有信息</p><p>创建<strong>轻量标签</strong>只需要提供标签名字:</p><div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">git</span> tag v1.4-lw
$ <span class="token function">git</span> tag
v0.1
v1.3
v1.4
v1.4-lw
v1.5
</code></pre></div><p>在标签上运行 <code>git show</code>，你不会看到额外的标签信息。 命令只会显示出提交信息：</p><div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">git</span> show v1.4-lw
commit ca82a6dff817ec66f44342007202690a93763949
Author: Scott Chacon <span class="token operator">&lt;</span>schacon@gee-mail.com<span class="token operator">&gt;</span>
Date:   Mon Mar 17 21:52:11 2008 -0700

    changed the version number
</code></pre></div><p>创建一个<strong>附注标签</strong>, 最简单的方式是当你在运行 <code>tag</code> 命令时指定 <code>-a</code> 选项：</p><div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">git</span> tag -a v1.4 -m <span class="token string">'my version 1.4'</span>
$ <span class="token function">git</span> tag
v0.1
v1.3
v1.4
</code></pre></div><p><code>-m</code> 选项指定了一条将会存储在标签中的信息。 如果没有为附注标签指定一条信息，Git 会运行编辑器要求你输入信息。</p><p>使用 <code>git show</code> 命令可以看到标签信息与对应的提交信息：</p><div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">git</span> show v1.4
tag v1.4
Tagger: Ben Straub <span class="token operator">&lt;</span>ben@straub.cc<span class="token operator">&gt;</span>
Date:   Sat May 3 20:19:12 2014 -0700

my version 1.4

commit ca82a6dff817ec66f44342007202690a93763949
Author: Scott Chacon <span class="token operator">&lt;</span>schacon@gee-mail.com<span class="token operator">&gt;</span>
Date:   Mon Mar 17 21:52:11 2008 -0700

    changed the version number
</code></pre></div><p>如果要给<strong>过去的提交</strong>打标签, 需要在命令的末尾指定提交的校验和</p><div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">git</span> tag -a v1.2 9fceb02
</code></pre></div><h4 id="删除标签"><a href="#删除标签" aria-hidden="true" class="header-anchor">#</a> 删除标签</h4><p>命令 <code>git tag -d &lt;tagname&gt;</code> 可以删除指定标签:</p><div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">git</span> tag -d v1.4-lw
Deleted tag <span class="token string">'v1.4-lw'</span> <span class="token punctuation">(</span>was e7d5add<span class="token punctuation">)</span>
</code></pre></div><h2 id="使用分支"><a href="#使用分支" aria-hidden="true" class="header-anchor">#</a> 使用分支</h2><h3 id="分支简介"><a href="#分支简介" aria-hidden="true" class="header-anchor">#</a> 分支简介</h3><p>分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。</p><p>再强调, **Git 保存的不是文件的变化或者差异，而是一系列不同时刻的文件快照。**在进行提交操作时，Git 会保存一个提交对象（commit object）, 该提交对象会包含一个指向暂存内容快照的指针, 还包含了作者的姓名和邮箱、提交时输入的信息以及指向它的父对象的指针。首次提交产生的提交对象没有父对象，普通提交操作产生的提交对象有一个父对象，而由多个分支合并产生的提交对象有多个父对象.</p><p>假设现在有一个工作目录，里面包含了三个将要被暂存和提交的文件。 暂存操作会为每一个文件计算 &quot;校验和&quot;，然后会把当前版本的文件快照保存到 Git 仓库中（Git 使用 blob 对象来保存它们），最终将校验和加入到暂存区域等待提交.  当使用 <code>git commit</code> 进行提交操作时，Git 会先计算每一个子目录（本例中只有项目根目录）的校验和，然后在 Git 仓库中这些校验和保存为 &quot;树对象&quot;。随后，Git 便会创建一个提交对象，它除了包含上面提到的那些信息外，还包含指向那个树对象（项目根目录）的指针。如此一来，Git 就可以在需要的时候重现此次保存的快照。</p><p><img src="/assets/commit-and-tree.png" alt="commit-and-tree"></p><p>Git 仓库中有五个对象：三个 blob 对象（保存着文件快照）、一个树对象（记录着目录结构和 blob 对象索引）以及一个提交对象（包含着指向前述树对象的指针和所有提交信息）。</p><p><strong>Git 的分支，其实本质上仅仅是指向提交对象的可变指针。</strong></p><p><img src="/assets/branch-and-history.png" alt="branch-and-history"></p><p>由于 Git 的分支实质上仅是包含所指对象校验和（长度为 40 的 SHA-1 值字符串）的文件，所以它的创建和销毁都异常高效。 创建一个新分支就相当于往一个文件中写入 41 个字节（40 个字符和 1 个换行符）</p><h3 id="新建分支"><a href="#新建分支" aria-hidden="true" class="header-anchor">#</a> 新建分支</h3><h4 id="分支创建"><a href="#分支创建" aria-hidden="true" class="header-anchor">#</a> 分支创建</h4><p>使用 <code>git branch</code> 命令创建新分支, 会在当前所在的提交对象上创建一个指针.</p><div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">git</span> branch testing
</code></pre></div><p>当有两个指向相同提交对象的分支存在时, Git 又是怎么知道当前在哪一个分支上呢？ 也很简单，它有一个名为 HEAD 的特殊指针。在 Git 中，它是一个指针，指向当前所在的本地分支（译注：将 HEAD 想象为当前分支的别名）。</p><p><img src="/assets/head-to-master.png" alt="head-to-master"></p><p>使用 <code>git log</code> 命令的 <code>--decorate</code> 参数, 可以查看各个分支当前所指的对象。</p><div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">git</span> log --oneline --decorate
f30ab <span class="token punctuation">(</span>HEAD, master, testing<span class="token punctuation">)</span> add feature <span class="token comment">#32 - ability to add new</span>
34ac2 fixed bug <span class="token comment">#1328 - stack overflow under certain conditions</span>
98ca9 initial commit of my project
</code></pre></div><h4 id="分支切换"><a href="#分支切换" aria-hidden="true" class="header-anchor">#</a> 分支切换</h4><p>要切换到一个已存在的分支，你需要使用 <code>git checkout</code> 命令。</p><div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">git</span> checkout testing
</code></pre></div><p>如果想新建一个分支, 同时切换到这个分支上可以使用 <code>git checkout</code> 的 <code>-b</code> 参数.</p><div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">git</span> checkout -b testing
</code></pre></div><p>这样 HEAD 就指向 testing 分支了。HEAD 分支随着提交操作自动向前移动.</p><p>在刚刚的例子中, 把分支切换回 master.  HEAD 指回 master 分支，同时工作目录恢复成 master 分支所指向的快照内容。 也就是说，你现在做修改的话，项目将始于一个较旧的版本。 本质上来讲，这就是忽略 testing 分支所做的修改，以便于向另一个方向进行开发。</p><p><img src="/assets/checkout-master.png" alt="checkout-master"></p><p>如果在 master 分支上, 做一些内容修改, 并且提交, 则项目出现分支分叉情况.</p><p><img src="/assets/advance-master.png" alt="advance-master"></p><p>使用 <code>git log</code> 命令查看分叉历史。 运行 <code>git log --oneline --decorate --graph --all</code> ，它会输出你的提交历史、各个分支的指向以及项目的分支分叉情况。</p><div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">git</span> log --oneline --decorate --graph --all
* c2b9e <span class="token punctuation">(</span>HEAD, master<span class="token punctuation">)</span> made other changes
<span class="token operator">|</span> * 87ab2 <span class="token punctuation">(</span>testing<span class="token punctuation">)</span> made a change
<span class="token operator">|</span>/
* f30ab add feature <span class="token comment">#32 - ability to add new formats to the</span>
* 34ac2 fixed bug <span class="token comment">#1328 - stack overflow under certain conditions</span>
* 98ca9 initial commit of my project
</code></pre></div><h4 id="合并分支"><a href="#合并分支" aria-hidden="true" class="header-anchor">#</a> 合并分支</h4><p>使用 <code>git merge</code> 命令可以合并分支.</p><div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">git</span> checkout master
$ <span class="token function">git</span> merge hotfix
Updating f42c576<span class="token punctuation">..</span>3a0874c
Fast-forward
 index.html <span class="token operator">|</span> 2 ++
 1 <span class="token function">file</span> changed, 2 insertions<span class="token punctuation">(</span>+<span class="token punctuation">)</span>
</code></pre></div><p>上面命令里, 切换到 master 分支, 然后把 hotfix 分支合并进来.</p><p><img src="/assets/basic-branching-4.png" alt="basic-branching-4"></p><p>你应该注意到了 &quot;快进&quot;（fast-forward）这个词。 在这个例子中, 由于当前 master 分支所指向的提交是你要合并进来的分支所指向的提交（有关 hotfix 的提交）的直接上游，所以 Git 只是简单的将指针向前移动。</p><p>换句话说，当你试图合并两个分支时，<strong>如果顺着一个分支走下去能够到达另一个分支，那么 Git 在合并两者的时候，只会简单的将指针向前推进（指针右移），因为这种情况下的合并操作没有需要解决的分歧——这就叫做 “快进（fast-forward）”</strong>。</p><p>在合并完之后, 你可以用 <code>git branch -d</code> 来删除掉分支.</p><p>如果要合并两个之间存在分叉的分支.  Git 会使用两个分支的末端所指的快照, 以及这两个分支的工作祖先，做一个简单的三方合并。</p><p><img src="/assets/basic-merging-1.png" alt="basic-merging-1"></p><p>和之前将分支指针向前推进所不同的是，Git 将此次三方合并的结果做了一个新的快照并且自动创建一个新的提交指向它。这个被称作一次 &quot;合并提交&quot;，它的特别之处在于他有不止一个父提交。</p><p><img src="/assets/basic-merging-2.png" alt="basic-merging-2"></p><p>如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，冲突就会出现.  合并时 Git 会等待你去解决合并产生的冲突。 你可以在合并冲突后的任意时刻使用 git status 命令来查看那些因包含合并冲突而处于未合并（unmerged）状态的文件：</p><div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">git</span> status
On branch master
You have unmerged paths.
  <span class="token punctuation">(</span>fix conflicts and run <span class="token string">&quot;git commit&quot;</span><span class="token punctuation">)</span>

Unmerged paths:
  <span class="token punctuation">(</span>use <span class="token string">&quot;git add &lt;file&gt;...&quot;</span> to mark resolution<span class="token punctuation">)</span>

    both modified:      index.html

no changes added to commit <span class="token punctuation">(</span>use <span class="token string">&quot;git add&quot;</span> and/or <span class="token string">&quot;git commit -a&quot;</span><span class="token punctuation">)</span>
</code></pre></div><p>在你解决了所有文件里的冲突之后，对每个文件使用 <code>git add</code> 命令来将其标记为冲突已解决。 一旦暂存这些原本有冲突的文件，Git 就会将它们标记为冲突已解决。之后输入 <code>git commit</code> 来完成合并提交</p><h3 id="分支管理"><a href="#分支管理" aria-hidden="true" class="header-anchor">#</a> 分支管理</h3><h4 id="查看分支列表"><a href="#查看分支列表" aria-hidden="true" class="header-anchor">#</a> 查看分支列表</h4><p><code>git branch</code> 命令如果不加任何参数运行它，会得到当前所有分支的一个列表</p><div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">git</span> branch
  iss53
* master
  testing
</code></pre></div><p><code>*</code> 表示当前 HEAD 指针所指向的分支.  这意味着如果在这时候提交，master 分支将会随着新的工作向前移动。</p><h4 id="查看分支最后提交"><a href="#查看分支最后提交" aria-hidden="true" class="header-anchor">#</a> 查看分支最后提交</h4><p>如果需要查看每一个分支的最后一次提交，可以运行 <code>git branch -v</code> 命令：</p><div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">git</span> branch -v
  iss53   93b412c fix javascript issue
* master  7a98805 Merge branch <span class="token string">'iss53'</span>
  testing 782fd34 add scott to the author list <span class="token keyword">in</span> the readmes
</code></pre></div><h4 id="查看-已合并-未合并-分支"><a href="#查看-已合并-未合并-分支" aria-hidden="true" class="header-anchor">#</a> 查看 已合并/未合并 分支</h4><p><code>--merged</code> 与 <code>--no-merged</code> 这两个有用的选项可以过滤这个列表中已经合并或尚未合并到当前分支的分支。 在这个列表中分支名字前没有 <code>*</code> 号的分支通常可以使用 <code>git branch -d</code> 删除掉；你已经将它们的工作整合到了另一个分支，所以并不会失去任何东西。</p><div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">git</span> branch --merged
  iss53
* master
</code></pre></div><h3 id="变基"><a href="#变基" aria-hidden="true" class="header-anchor">#</a> 变基</h3><p>之前介绍过，整合分支最容易的方法是 <code>merge</code> 命令。 它会把两个分支的最新快照, 以及二者最近的共同祖先进行三方合并，合并的结果是生成一个新的快照, 并提交。</p><p>另一种方法是, 你可以使用 <code>rebase</code> 命令将提交到某一分支上的所有修改都移至另一分支上，就好像“重新播放”一样。 变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。</p><p><img src="/assets/basic-rebase-3.png" alt="basic-rebase-3"></p><div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">git</span> checkout experiment
$ <span class="token function">git</span> rebase master
First, rewinding <span class="token function">head</span> to replay your work on <span class="token function">top</span> of it<span class="token punctuation">..</span>.
Applying: added staged <span class="token function">command</span>
</code></pre></div><p>它的原理是首先找到这两个分支（即当前分支 experiment、变基操作的目标基底分支 master）的最近共同祖先 C2，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件，然后将当前分支指向目标基底 C3, 最后以此将之前另存为临时文件的修改依序应用。</p><p>但是变基使得提交历史更加整洁。 你在查看一个经过变基的分支的历史记录时会发现，尽管实际的开发工作是并行的，但它们看上去就像是串行的一样，提交历史是一条直线没有分叉。</p><p>一般我们这样做的目的是为了确保在向远程分支推送时能保持提交历史的整洁——例如向某个其他人维护的项目贡献代码时。 在这种情况下，你首先在自己的分支里进行开发，当开发完成时你需要先将你的代码变基到 origin/master 上，然后再向主项目提交修改。 这样的话，该项目的维护者就不再需要进行整合工作，只需要快进合并便可。</p><h4 id="截取分支上的另一个分支，再变基到其他分支"><a href="#截取分支上的另一个分支，再变基到其他分支" aria-hidden="true" class="header-anchor">#</a> 截取分支上的另一个分支，再变基到其他分支</h4><p>在对两个分支进行变基时，所生成的“重放”并不一定要在目标分支上应用，你也可以指定另外的一个分支进行应用。</p><p><img src="/assets/interesting-rebase-2.png" alt="interesting-rebase-2"></p><p>上图中, 假设你希望将 client 中的修改合并到主分支并发布，但暂时并不想合并 server 中的修改，因为它们还需要经过更全面的测试。 这时，你就可以使用 <code>git rebase</code> 命令的 <code>--onto</code> 选项，选中在 client 分支里但不在 server 分支里的修改（即 C8 和 C9），将它们在 master 分支上重放</p><div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">git</span> rebase --onto master server client
</code></pre></div><p>以上命令的意思是：“取出 client 分支，找出处于 client 分支和 server 分支的共同祖先之后的修改，然后把它们在 master 分支上重放一遍”。</p><p>之后你可以快进合并 master 分支了.  如果你决定将 server 分支中的修改也整合进来。 使用 <code>git rebase [basebranch] [topicbranch]</code> 命令可以直接将特性分支（即本例中的 server）变基到目标分支（即 master）上。这样做能省去你先切换到 server 分支，再对其执行变基命令的多个步骤。</p><h4 id="变基的风险"><a href="#变基的风险" aria-hidden="true" class="header-anchor">#</a> 变基的风险</h4><p>变基有一条准则：</p><p><strong>不要对在你的仓库外有副本的分支执行变基。</strong></p><p>变基操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。 如果你已经将提交推送至某个仓库，而其他人也已经从该仓库拉取提交并进行了后续工作，此时，如果你用 <code>git rebase</code> 命令重新整理了提交并再次推送，你的同伴因此将不得不再次将他们手头的工作与你的提交进行整合，如果接下来你还要拉取并整合他们修改过的提交，事情就会变得一团糟。</p><p>看个例子:</p><p>假设你从一个中央服务器克隆然后在它的基础上进行了一些开发。 你的提交历史如图所示：</p><p><img src="/assets/perils-of-rebasing-1.png" alt="perils-of-rebasing-1"></p><p>然后，某人又向中央服务器提交了一些修改，其中还包括一次合并。 你抓取了这些在远程分支上的修改，并将其合并到你本地的开发分支，然后你的提交历史就会变成这样：</p><p><img src="/assets/perils-of-rebasing-2.png" alt="perils-of-rebasing-2"></p><p>接下来，这个人又决定把合并操作回滚，改用变基；继而又用 <code>git push --force</code> 命令覆盖了服务器上的提交历史。 之后你从服务器抓取更新，会发现多出来一些新的提交。</p><p><img src="/assets/perils-of-rebasing-3.png" alt="perils-of-rebasing-3"></p><p>结果就是你们两人的处境都十分尴尬。 如果你执行 <code>git pull</code> 命令，你将合并来自两条提交历史的内容，生成一个新的合并提交，最终仓库会如图所示：</p><p><img src="/assets/perils-of-rebasing-4.png" alt="perils-of-rebasing-4"></p><p>此时如果你执行 <code>git log</code> 命令，你会发现有两个提交的作者、日期、日志居然是一样的，这会令人感到混乱。 此外，如果你将这一堆又推送到服务器上，你实际上是将那些已经被变基抛弃的提交又找了回来，这会令人感到更加混乱。 很明显对方并不想在提交历史中看到 C4 和 C6，因为之前就是他把这两个提交通过变基丢弃的。</p><h4 id="用变基解决变基"><a href="#用变基解决变基" aria-hidden="true" class="header-anchor">#</a> 用变基解决变基</h4><p>如果遇到前面提到的 有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交 那种情境，如果我们不是执行合并，而是执行 <code>git rebase teamone/master</code>, Git 将会：</p><ul><li><p>检查哪些提交是我们的分支上独有的（C2，C3，C4，C6，C7）</p></li><li><p>检查其中哪些提交不是合并操作的结果（C2，C3，C4）</p></li><li><p>检查哪些提交在对方覆盖更新时并没有被纳入目标分支（只有 C2 和 C3，因为 C4 其实就是 C4'）</p></li><li><p>把查到的这些提交应用在 teamone/master 上面</p></li></ul><p><img src="/assets/perils-of-rebasing-5.png" alt="perils-of-rebasing-5"></p><p>本例中使用 <code>git pull --rebase</code> 命令可以完成上述操作. 它的意思是先 <code>git fetch</code>，再 <code>git rebase teamone/master</code>。</p><p>最好做法是把变基命令当作是在推送前清理提交使之整洁的工具，并且<strong>只在从未推送至共用仓库的提交上执行变基命令</strong>，就不会有事。 假如在那些已经被推送至共用仓库的提交上执行变基命令，并因此丢弃了一些别人的开发所基于的提交，那你就有大麻烦了</p><h4 id="变基-vs-合并"><a href="#变基-vs-合并" aria-hidden="true" class="header-anchor">#</a> 变基 vs 合并</h4><p>如果想问哪个更好, 先思考提交历史到底意味着什么?</p><p>有一种观点认为，仓库的提交历史即是 <strong>记录实际发生过什么</strong>。 它是针对历史的文档，本身就有价值，不能乱改。 哪怕提交历史是一团糟, 那么这些痕迹也应该被保留下来，让后人能够查阅。</p><p>另一种观点则正好相反，他们认为提交历史是 <strong>项目过程中发生的事</strong>。无意义的修改, 和被舍弃的内容不需要被后来人看到.</p><p>到底合并还是变基好？这并没有一个简单的答案。 Git 是一个非常强大的工具，它允许你对提交历史做许多事情，但每个团队、每个项目对此的需求并不相同。 既然你已经分别学习了两者的用法，相信你能够根据实际情况作出明智的选择。</p><p><strong>总的原则是，只对尚未推送或分享给别人的本地修改执行变基操作清理历史</strong>，<strong>从不对已推送至别处的提交执行变基操作</strong>，这样，你才能享受到两种方式带来的便利。</p><h2 id="远程仓库"><a href="#远程仓库" aria-hidden="true" class="header-anchor">#</a> 远程仓库</h2><p>远程仓库是指托管在因特网或其他网络中的你的项目的版本库.  与他人协作时, 可以在这个远程仓库上根据需要 &quot;推送&quot; 或 &quot;拉取&quot; 数据。</p><h3 id="查看远程仓库"><a href="#查看远程仓库" aria-hidden="true" class="header-anchor">#</a> 查看远程仓库</h3><p>如果想查看你已经配置的远程仓库服务器，可以运行 <code>git remote</code> 命令。 它会列出你指定的每一个远程服务器的简写。</p><p>如果你已经克隆了自己的仓库，那么至少应该能看到 <code>origin</code>. 这是 Git 给你克隆的仓库服务器的默认名字</p><div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">git</span> clone https://github.com/schacon/ticgit
Cloning into <span class="token string">'ticgit'</span><span class="token punctuation">..</span>.
remote: Reusing existing pack: 1857, done.
remote: Total 1857 <span class="token punctuation">(</span>delta 0<span class="token punctuation">)</span>, reused 0 <span class="token punctuation">(</span>delta 0<span class="token punctuation">)</span>
Receiving objects: 100% <span class="token punctuation">(</span>1857/1857<span class="token punctuation">)</span>, 374.35 KiB <span class="token operator">|</span> 268.00 KiB/s, done.
Resolving deltas: 100% <span class="token punctuation">(</span>772/772<span class="token punctuation">)</span>, done.
Checking connectivity<span class="token punctuation">..</span>. done.
$ <span class="token function">cd</span> ticgit
$ <span class="token function">git</span> remote
origin
</code></pre></div><p>指定选项 <code>-v</code>，会显示需要读写远程仓库使用的 Git 保存的仓库服务器的名字, 以及其对应的 URL。</p><div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">git</span> remote -v
origin	https://github.com/schacon/ticgit <span class="token punctuation">(</span>fetch<span class="token punctuation">)</span>
origin	https://github.com/schacon/ticgit <span class="token punctuation">(</span>push<span class="token punctuation">)</span>
</code></pre></div><h3 id="添加远程仓库"><a href="#添加远程仓库" aria-hidden="true" class="header-anchor">#</a> 添加远程仓库</h3><p>运行 <code>git remote add &lt;shortname&gt; &lt;url&gt;</code> 添加一个新的远程 Git 仓库, 同时可以为仓库指定一个名字.</p><div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">git</span> remote
origin
$ <span class="token function">git</span> remote add pb https://github.com/paulboone/ticgit
$ <span class="token function">git</span> remote -v
origin	https://github.com/schacon/ticgit <span class="token punctuation">(</span>fetch<span class="token punctuation">)</span>
origin	https://github.com/schacon/ticgit <span class="token punctuation">(</span>push<span class="token punctuation">)</span>
pb	https://github.com/paulboone/ticgit <span class="token punctuation">(</span>fetch<span class="token punctuation">)</span>
pb	https://github.com/paulboone/ticgit <span class="token punctuation">(</span>push<span class="token punctuation">)</span>
</code></pre></div><p>如果你使用 <code>clone</code> 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为名称简写。</p><h3 id="抓取-pull-拉取-fetch"><a href="#抓取-pull-拉取-fetch" aria-hidden="true" class="header-anchor">#</a> 抓取(pull) &amp; 拉取(fetch)</h3><h4 id="拉取-fetch"><a href="#拉取-fetch" aria-hidden="true" class="header-anchor">#</a> 拉取(fetch)</h4><p>从远程仓库中获得数据，可以执行 <code>git fetch [remote-name]</code>.  这个命令会访问远程仓库，从中<strong>拉取</strong>所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。</p><p>必须注意 <code>git fetch</code> 命令会将数据<strong>拉取</strong>到你的本地仓库 - 它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作。</p><h4 id="抓取-pull"><a href="#抓取-pull" aria-hidden="true" class="header-anchor">#</a> 抓取(pull)</h4><blockquote><p>git pull = git fetch + git merge</p></blockquote><h3 id="推送到远程仓库"><a href="#推送到远程仓库" aria-hidden="true" class="header-anchor">#</a> 推送到远程仓库</h3><p>使用命令 <code>git push [remote-name] [branch-name]</code> 将你本地的内容推送到远端服务器.</p><p>這個簡單的 Push 指令其實做了幾件事：</p><ul><li>把 <code>master</code> 這個分支的內容，推向 <code>origin</code> 這個位置。</li><li>在 <code>origin</code> 那個遠端 Server 上，如果 <code>master</code> 不存在，就建立一個叫做 <code>master</code> 的同名分支。</li><li>但如果本來 Server 上就存在 <code>master</code> 分支，便會移動 Server 上 <code>master</code> 分支的位置，使它指到目前最新的進度上。</li></ul><p>只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。 当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。</p><p>你必须先将他们的工作拉取下来并将其合并进你的工作后才能推送。</p><h4 id="设定-upstream-上游"><a href="#设定-upstream-上游" aria-hidden="true" class="header-anchor">#</a> 设定 upstream (上游)</h4><p>upstream，中文翻譯成「上游」.  在 Git 裡，每個分支可以設定一個「上游」（但每個分支最多只能設定一個 upstream）.  它會指向並追蹤（track）某個分支。通常 upstream 會是远端 Server 上的某個分支，但其實要設定在本地端的其它分支也可以。</p><p>如果有設定，當下次執行 <code>git push</code> 指令的時候，它就會用來當預設值。</p><div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">git</span> push -u origin master
</code></pre></div><p>就會把 <code>origin/master</code> 設定為本地 <code>master</code> 分支的 upstream，當下回執行 <code>git push</code> 指令而不加任何參數的時候，它就會猜你是要推往 <code>origin</code> 這個遠端節點，並且把 <code>master</code> 這個分支推上去。</p><h4 id="不想要同名的分支"><a href="#不想要同名的分支" aria-hidden="true" class="header-anchor">#</a> 不想要同名的分支</h4><div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">git</span> push origin master
</code></pre></div><p>其實上面這個指令跟下面這個指令是一樣的效果：</p><div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">git</span> push origin master:master
</code></pre></div><p>意思是「把本地的 master 分支推上去後，在 Server 上更新 master 分支的進度，或是如果不存在該分支的話，就建立一個 master 分支」。</p><p>但如果你想推上去之後不要叫這個名字的話，可以把後面的那個名字改掉：</p><div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">git</span> push origin master:cat
</code></pre></div><p>這樣當把本地端的 master 分支推上去之後，就不會在線上建立 master 分支，而是建立（或更新進度）一個叫做 cat 的分支了。</p><h3 id="查看远程仓库-2"><a href="#查看远程仓库-2" aria-hidden="true" class="header-anchor">#</a> 查看远程仓库</h3><p>如果想要查看某一个远程仓库的更多信息，可以使用 <code>git remote show [remote-name]</code> 命令</p><div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">git</span> remote show origin
* remote origin
  Fetch URL: https://github.com/schacon/ticgit
  Push  URL: https://github.com/schacon/ticgit
  HEAD branch: master
  Remote branches:
    master                               tracked
    dev-branch                           tracked
  Local branch configured <span class="token keyword">for</span> <span class="token string">'git pull'</span><span class="token keyword">:</span>
    master merges with remote master
  Local ref configured <span class="token keyword">for</span> <span class="token string">'git push'</span><span class="token keyword">:</span>
    master pushes to master <span class="token punctuation">(</span>up to date<span class="token punctuation">)</span>
</code></pre></div><p>它同样会列出远程仓库的 URL 与跟踪分支的信息。 这些信息非常有用，它告诉你正处于 master 分支，并且如果运行 <code>git pull</code>，就会抓取所有的远程引用，然后将远程 master 分支合并到本地 master 分支。 它也会列出拉取到的所有远程引用。</p><h3 id="远程仓库的移除与重命名"><a href="#远程仓库的移除与重命名" aria-hidden="true" class="header-anchor">#</a> 远程仓库的移除与重命名</h3><p>运行 <code>git remote rename</code> 去修改一个远程仓库的简写名</p><div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">git</span> remote <span class="token function">rename</span> pb paul
$ <span class="token function">git</span> remote
origin
paul
</code></pre></div><p>使用 <code>git remote rm</code> 移除一个远程仓库</p><div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">git</span> remote <span class="token function">rm</span> paul
$ <span class="token function">git</span> remote
origin
</code></pre></div></div><div class="page-edit"><!----><!----></div><!----></div></div></div>
    <script src="/front-end-notebook/assets/js/42.015eb55a.js" defer></script><script src="/front-end-notebook/assets/js/app.bd1d7c3a.js" defer></script>
  </body>
</html>
