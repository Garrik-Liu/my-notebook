# 树

树是一种非线性表数据结构。一个树结构包含一系列存在父子关系的节点。除了顶部的第一个节点，每个节点都有一个父节点以及零个或多个子节点。

![2020-1-14-14-12-5.png](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-1-14-14-12-5.png)

下面解释一些术语：

- **节点**：树中的每个元素都叫作节点；
  - **根节点**：树顶部的节点叫作根节点，它没有父节点。
  - **内部节点**：至少有一个子节点的节点称为内部节点；
  - **外部节点**（叶节点）：没有子元素的节点称为外部节点或叶节点；
- **子树**：子树由节点和它的后代构成。例如，节点 13、12 和 14 构成了上图中树的一棵子树；
- **深度**： 节点的深度取决于它的祖先节点的数量。例如，节点 8 有 3 个祖先节点（9、7 和 11），它的深度为 3；
- **高度**：树的高度取决于所有节点深度的最大值；
- **层**：根节点在第 0 层，它 的子节点在第 1 层，以此类推。

## 二叉树

二叉树，每个节点最多有两个两个子节点，分别是**左子节点**和**右子节点**。

![2020-1-14-14-21-51.png](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-1-14-14-21-51.png)

上图编号 2 的二叉树中，叶子节点全都在最底层，除了叶子节点之外，每个节点都有左右两个子节点，这种二叉树就叫作**满二叉树**。

编号 3 的二叉树中，叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大，这种二叉树叫作**完全二叉树**。

![2020-1-14-14-27-53.png](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-1-14-14-27-53.png)

### 储存二叉树

想要存储一棵二叉树，我们有两种方法，一种是基于指针或者引用的**二叉链式存储法**，一种是基于数组的**顺序存储法**。

#### 二叉链式存储法

**每个节点有三个属性，其中一个存储数据，另外两个是指向左右子节点的指针**。我们只要拎住根节点，就可以通过左右子节点的指针，把整棵树都串起来。这种存储方式我们比较常用。

![2020-1-14-15-54-41.png](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-1-14-15-54-41.png)

#### 顺序存储法

在数组中，**如果节点 $X$ 存储在数组中下标为 $i$ 的位置，下标为 $2 * i$ 的位置存储的就是左子节点，下标为 $2 * i + 1$ 的位置存储的就是右子节点。反过来，下标为 $i/2$ 的位置存储就是它的父节点**。

![2020-1-14-15-56-0.png](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-1-14-15-56-0.png)

把根节点存储在下标 $i = 1$ 的位置，那左子节点存储在下标 $2 * i = 2$ 的位置，右子节点存储在 $2 * i + 1 = 3$ 的位置。以此类推，B 节点的左子节点存储在 $2 * i = 2 * 2 = 4$ 的位置，右子节点存储在 $2 * i + 1 = 2 * 2 + 1 = 5$ 的位置。

上面的例子是一棵完全二叉树，所以仅仅“浪费”了一个下标为 0 的存储位置。如果是非完全二叉树，其实会浪费比较多的数组存储空间

![2020-1-14-15-59-43.png](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-1-14-15-59-43.png)

所以，**如果某棵二叉树是一棵完全二叉树，那用数组存储是最节省内存的一种方式**。因为数组的存储方式并不需要像链式存储法那样，要存储额外的左右子节点的指针。

可以是为什么要单独拎出来一个 “完全二叉树” 的原因，以及为什么完全二叉树要求最后一层的子节点都靠左的原因。

### 二叉树的遍历

如何将所有节点都遍历打印出来呢？经典的方法有三种，**前序遍历**、**中序遍历**和**后序遍历**。其中，前、中、后序，表示的是节点与它的左右节点遍历打印的先后顺序：

- **前序遍历**：对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树；
- **中序遍历**：对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树；
- **后序遍历**：对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身；

![2020-1-14-16-4-15.png](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-1-14-16-4-15.png)

二叉树的前、中、后序遍历就是一个递归的过程。下面是它们各自的实现代码：

```java

void preOrder(Node* root) {
  if (root == null) return;
  System.out.print(root->value);
  preOrder(root->left);
  preOrder(root->right);
}

void inOrder(Node* root) {
  if (root == null) return;
  inOrder(root->left);
  System.out.print(root->value);
  inOrder(root->right);
}

void postOrder(Node* root) {
  if (root == null) return;
  postOrder(root->left);
  postOrder(root->right);
  System.out.print(root->value);
}
```

从前、中、后序遍历的顺序图，可以看出来，每个节点最多会被访问两次，所以遍历操作的时间复杂度，跟节点的个数 n 成正比，也就是说**二叉树遍历的时间复杂度是 $O(n)$**。

## 二叉查找树

二叉查找树最大的特点就是，支持动态数据集合的快速插入、删除、查找操作。

**二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值**。

![2020-1-14-22-1-58.png](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-1-14-22-1-58.png)

可以发现，中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度是 $O(n)$，非常高效。因此，二叉查找树也叫作**二叉排序树**。

### 二叉查找树的查找操作

在二叉查找树中查找一个节点。我们先取根节点，如果它等于我们要查找的数据，那就返回。如果要查找的数据比根节点的值小，那就在左子树中递归查找；如果要查找的数据比根节点的值大，那就在右子树中递归查找。

```java
public class BinarySearchTree {
  private Node tree;

  public Node find(int data) {
    Node p = tree;
    while (p != null) {
      if (data < p.data) p = p.left;
      else if (data > p.data) p = p.right;
      else return p;
    }
    return null;
  }

  public static class Node {
    private int data;
    private Node left;
    private Node right;

    public Node(int data) {
      this.data = data;
    }
  }
}
```

### 二叉查找树的插入操作

新插入的数据一般都是在叶子节点上，所以我们只需要从根节点开始，依次比较要插入的数据和节点的大小关系。

如果要插入的数据比节点的数据大，并且节点的右子树为空，就将新数据直接插到右子节点的位置；如果不为空，就再递归遍历右子树，查找插入位置。同理，如果要插入的数据比节点数值小，并且节点的左子树为空，就将新数据插入到左子节点的位置；如果不为空，就再递归遍历左子树，查找插入位置。

```java
public void insert(int data) {
  if (tree == null) {
    tree = new Node(data);
    return;
  }

  Node p = tree;
  while (p != null) {
    if (data > p.data) {
      if (p.right == null) {
        p.right = new Node(data);
        return;
      }
      p = p.right;
    } else { // data < p.data
      if (p.left == null) {
        p.left = new Node(data);
        return;
      }
      p = p.left;
    }
  }
}
```

### 二叉查找树的删除操作

针对要删除节点的子节点个数的不同，我们需要分三种情况来处理。

- 如果要删除的节点没有子节点，我们只需要直接将父节点中，指向要删除节点的指针置为 `null`；
- 如果要删除的节点只有一个子节点（只有左子节点或者右子节点），我们只需要更新父节点中，指向要删除节点的指针，让它指向要删除节点的子节点就可以了；
- 如果要删除的节点有两个子节点。我们需要找到这个节点的右子树中的最小节点，把它替换到要删除的节点上。然后再删除掉这个最小节点；

![2020-1-14-22-10-39.png](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-1-14-22-10-39.png)

```java

public void delete(int data) {
  // p 指向要删除的节点，初始化指向根节点
  Node p = tree;
  // pp 记录的是 p 的父节点
  Node pp = null;
  while (p != null && p.data != data) {
    pp = p;
    if (data > p.data) p = p.right;
    else p = p.left;
  }
  // 没有找到
  if (p == null) return;

  // 要删除的节点有两个子节点
  if (p.left != null && p.right != null) { // 查找右子树中最小节点
    Node minP = p.right;
    // minPP表示minP的父节点
    Node minPP = p;
    while (minP.left != null) {
      minPP = minP;
      minP = minP.left;
    }
    // 将minP的数据替换到p中
    p.data = minP.data;
    // 下面就变成了删除minP了
    p = minP;
    pp = minPP;
  }

  // 删除节点是叶子节点或者仅有一个子节点
  Node child; // p的子节点
  if (p.left != null) child = p.left;
  else if (p.right != null) child = p.right;
  else child = null;

  // 删除的是根节点
  if (pp == null) tree = child;
  else if (pp.left == p) pp.left = child;
  else pp.right = child;
}
```

除此之外，关于二叉查找树的删除操作，还有个非常简单、取巧的方法，就是单纯将要删除的节点标记为“已删除”，但是并不真正从树中将这个节点去掉。这样原本删除的节点还需要存储在内存中，比较浪费内存空间，但是删除操作就变得简单了很多。

### 支持重复数据的二叉查找树

如果遇到了碰到一个节点的值，与要插入数据的值相同，我们就将这个要插入的数据放到这个节点的右子树，也就是说，把这个新插入的数据当作大于这个节点的值来处理。

![2020-1-14-22-18-3.png](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-1-14-22-18-3.png)

当要查找数据的时候，遇到值相同的节点，我们并不停止查找操作，而是继续在右子树中查找，直到遇到叶子节点，才停止。这样就可以把键值等于要查找值的所有节点都找出来。

![2020-1-14-22-18-10.png](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-1-14-22-18-10.png)

对于删除操作，我们也需要先查找到每个要删除的节点，然后再按前面讲的删除操作的方法，依次删除。

![2020-1-14-22-18-26.png](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-1-14-22-18-26.png)

### 二叉查找树的时间复杂度分析

![2020-1-14-22-19-26.png](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-1-14-22-19-26.png)

二叉查找树的形态各式各样。比如这个图中，对于同一组数据，我们构造了三种二叉查找树。它们的查找、插入、删除操作的执行效率都是不一样的。图中第一种二叉查找树，根节点的左右子树极度不平衡，已经退化成了链表，所以查找的时间复杂度就变成了 O(n)。

### 二叉查找树 vs 散列表

二叉查找树最大的特点就是，支持动态数据集合的快速插入、删除、查找操作。之前说过，散列表也是支持这些操作的，并且散列表的这些操作比二叉查找树更高效，时间复杂度是 $O(1)$。既然有了这么高效的散列表，使用二叉树的地方是不是都可以替换成散列表呢？有没有哪些地方是散列表做不了，必须要用二叉树来做的呢？

- 散列表的插入、删除、查找操作的时间复杂度可以做到常量级的 $O(1)$。
- 二叉查找树在比较平衡的情况下，插入、删除、查找操作时间复杂度是 $O(logn)$

之所以有些地方不去用散列表，而是用二叉查找树，原因主要有如下几点：

- **散列表中的数据是无序存储的**，如果要输出有序的数据，需要先进行排序。而对于二叉查找树来说，我们只需要中序遍历，就可以在 $O(n)$ 的时间复杂度内，输出有序的数据序列；
- **散列表扩容耗时很多，而且当遇到散列冲突时，性能不稳定**，尽管二叉查找树的性能不稳定，但是在工程中，我们最常用的平衡二叉查找树的性能非常稳定，时间复杂度稳定在 $O(logn)$；
- 尽管散列表的查找等操作的时间复杂度是常量级的，但**因为哈希冲突的存在，这个常量不一定比 $logn$ 小**。所以实际的查找速度可能不一定比 $O(logn)$ 快；
- **散列表的构造比二叉查找树要复杂，需要考虑的东西很多**。比如散列函数的设计、冲突解决办法、扩容、缩容等。平衡二叉查找树只需要考虑平衡性这一个问题，而且这个问题的解决方案比较成熟、固定；
- 为了避免过多的散列冲突，散列表装载因子不能太大，特别是基于开放寻址法解决冲突的散列表，不然这会**浪费一定的存储空间**。

## 红黑树

## 递归树
