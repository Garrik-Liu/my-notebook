# 排序

这一节介绍一些常用的排序算法。

![2020-1-19-17-26-59.png](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-1-19-17-26-59.png)

## 如何分析一个 “排序算法”

### 执行效率

对于排序算法执行效率的分析，我们一般会从这几个方面来衡量：

#### 最好情况、最坏情况、平均情况时间复杂度

在分析排序算法的时间复杂度时，要分别给出最好情况、最坏情况、平均情况下的时间复杂度。

除此之外，你还要说出最好、最坏时间复杂度对应的要排序的原始数据是什么样的。

#### 时间复杂度的系数、常数 、低阶

算法时间复杂度反应的是数据规模 n 增大的时候的一个增长趋势。当 n 很大的时候，我们会忽略系数、常数、低阶。

但是实际的软件开发中，我们排序的可能是 10 个、100 个、1000 个这样规模很小的数据，所以，在对同一阶时间复杂度的排序算法性能对比的时候，我们就要把系数、常数、低阶也考虑进来。

#### 比较次数和交换（或移动）次数

基于比较的排序算法的执行过程，会涉及两种操作，一种是元素比较大小，另一种是元素交换或移动。

所以，如果我们在分析排序算法的执行效率的时候，应该把比较次数和交换（或移动）次数也考虑进去。

### 内存消耗

针对排序算法的空间复杂度，我们引入了一个新的概念，**原地排序**（Sorted in place）。

原地排序算法，就是指在排序过程中不申请多余的存储空间，只在原来存储待排数据的存储空间，进行比较和交换的排序算法。其空间复杂度是 $O(1)$ 。

### 稳定性

针对排序算法，还有一个重要的度量指标，**稳定性**。

这个概念是说，**如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变**。

举例来讲，比如我们有一组数据 2，9，3，4，8，3，按照大小排序之后就是 2，3，3，4，8，9。这组数据里有两个 3。经过某种排序算法排序之后，如果两个 3 的前后顺序没有改变，那我们就把这种排序算法叫作**稳定的排序算法**；如果前后顺序发生变化，那对应的排序算法就叫作**不稳定的排序算法**。

🌰 通过一个例子来说明，为什么要判断一个算法是否稳定。

::: details-open 例子：
比如说，我们现在要给电商交易系统中的“订单”排序。订单有两个属性，一个是下单时间，另一个是订单金额。如果我们现在有 10 万条订单数据，我们希望按照金额从小到大对订单数据排序。对于金额相同的订单，我们希望按照下单时间从早到晚有序。对于这样一个排序需求，我们怎么来做呢？

借助稳定排序算法，这个问题可以非常简洁地解决。解决思路是这样的：我们先按照下单时间给订单排序，注意是按照下单时间，不是金额。排序完成之后，我们用稳定排序算法，按照订单金额重新排序。两遍排序之后，我们得到的订单数据就是按照金额从小到大排序，金额相同的订单按照下单时间从早到晚排序的。

![2020-1-19-17-38-13.png](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-1-19-17-38-13.png)
:::

## 冒泡排序

## 插入排序

## 选择排序

## 归并排序

## 快速排序

## 堆排序

## 桶排序

## 计数排序

## 基数排序
