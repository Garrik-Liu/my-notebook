# 算法简介 & 复杂度分析

## 什么是算法

我们会通过编程解决很多问题。例如，已知一串整数，求最大的一个；已知一个集合，列出其所有子集；给定一个整数集合，把这些整数从小到大排序；已知一个网络，找出两个顶点之间的最短路径等。遇到这样的问题时，首先要做的就是构造一个模型把问题转换为数学问题。

建立完模型后，还需要用模型去实际解决问题。我们需要找到一个过程，它能够遵循一系列步骤去找到所求的答案。这一系列步骤就称为一个算法。

**『 算法 』是用于进行一项计算或解决一个问题的 “准确指令” 的 “有限序列”**。

![2020-1-12-17-27-49.png](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-1-12-17-27-49.png)

::: details-open 例子：
描述在一个有限整数序列中寻求最大值的算法：

1. 设临时最大值等于序列中的第一个整数；
2. 将序列的下一个整数与临时最大值比较，如果大于临时最大值，则设临时最大值为这个整数；
3. 如果序列中还要其他的整数，重复前一个步骤；
4. 当序列中没有其他整数时停止。 此刻临时最大值的值就是序列中的最大整数；

用伪代码表达：

![2020-1-12-17-31-43.png](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-1-12-17-31-43.png)

上面的算法体现出了 “算法的性质”：

- 输入：输入是一个整数序列；
- 输出：输出是该序列的最大整数；
- 确定性：算法的每一步都是准确定义的；
- 正确性：初始 max 的值为序列第一项，随着不断的检查各项，如果有一项大于当前 max 最大值，max 的值就会被更新为该项的值，当检查完所有项后，max 的值为最大项的值；
- 有限性：该算法在检查完序列中所有的整数后就会停止；
- 有效性：能在有限的时间中完成，因为涉及到的操作只有赋值和比较；
- 通用性：该算法可以用于求任何有限整数序列的最大元素；

:::

## 函数的增长

 算法执行所需的资源可以分为两类：

- 内存，网络带宽，等...
- 时间

一般来说，**算法执行需要的资源与输入的规模同步增长**，所以**通常把一个 “算法运行所需的资源” 描述成 "关于其输入规模的函数"**。

$f(输入) = 所需资源$

分析算法就是分析算法执行所需的资源。通常我们更关注的是所需的 “运行时间”。

因为算法运行的实际时间受 “计算机硬件配置” 和 “输入规模” 的影响很大。我们不可能每次都去实际测量真实所需时间。所以需要一种不用具体输入，就能估算算法执行效率的方法。

**假定算法执行的每一步操作所需时间相同。一个算法在特定输入上的运行时间就等于执行的操作数 x 单位操作时间**。

那么通过估计 “当输入增长时一个算法所需操作数量的增长”。就能够判定当输入规模增大时用一个特定算法来求解该问题是否实际可行。并且可以比较多个算法以判断当输入规模增大时哪个算法更有效。

### 大 O 表示法

我们用 “大 O 表示法” 来估计当输入增长时一个算法所需时间的增长。下面给出它的数学定义：

::: theorem 定义：
![2020-1-12-18-44-11.png](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-1-12-18-44-11.png)
:::

![2020-1-12-18-46-34.png](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-1-12-18-46-34.png)

::: details-open 例子：
![2020-1-12-18-45-46.png](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-1-12-18-45-46.png)
:::

通过上面的定义和例子，可以看出：**大 O 表示法，表示出了 $g(x)$ 的『 增长率 』大于等于 $f(x)$**。也就是 $f(x)$ 是在以一个不快于 $g(x)$ 的速度增长。$g(x)$ 也被称为 $f(x)$ 的一个『 **上界** 』。

### 大 Ω 表示法

::: theorem 定义：
![2020-1-13-0-17-34.png](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-1-13-0-17-34.png)
:::

::: details-open 例子：
![2020-1-13-0-20-14.png](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-1-13-0-20-14.png)
:::

可以看出来 “大 Ω 表示法” 就是把 “大 O 表示法” 倒过来说。

**$g(x) = O(f(x))$ 当且仅当 $f(x) = Ω(g(x))$**

**大 Ω 表示法，表示出了 $g(x)$ 的『 增长率 』小于等于 $f(x)$**。也就是 $f(x)$ 是在以一个不慢于 $g(x)$ 的速度增长。$g(x)$ 也被称为 $f(x)$ 的一个『 **下界** 』。

### 大 Θ 表示法

::: theorem 定义：
![2020-1-13-0-35-19.png](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-1-13-0-35-19.png)
:::

 简单说：**$f(x) = Θ(g(x))$ 当且仅当 $f(x) = O(g(x))$ 并且 $f(x) = Ω(g(x))$**

也就是说，$f(x)$ 的增长率既不会比 $g(x)$ 快，也不会比 $g(x)$ 慢，而是以相同的速率增长。

注意，很多时候人们会误把 “大 O 表示法” 当成 “大 Θ 表示法” 用。请记清它们各自的定义。 🌰 举例，如果 $g(x) = 2x^2$ 那么 $g(x) = O(x^4)$，$g(x) = O(x^3)$，$g(x) = O(x^2)$。在分析算法时，我们肯定会选取增长率和 $g(x)$ 最接近的那个上界，也就是 $x^2$。因为基本上我们不会去分析算法的下界，所以就直接用 “大 O 表示法” 了。

**请记住，在 $f(x) = O(g(x))$ 中，大 O 表示法只指示出$g(x)$ 的增长率比 $f(x)$ 大而已，并不表示它们的增长率很贴近，只是我们默认选取增长率最贴近的那个函数而已**。

## 时间复杂度分析

在算法分析中，可以这样表示这个公式：

**$T(n) = O(f(n))$**

- $T(n)$ 表示代码执行的时间；
- $n$ 表示输入规模的大小；
- $f(n)$ 表示需要执行的操作次数的总和；

上面公式表示出：**随着输入规模的增长，算法执行所需时间 $T(n)$ 的增长率小于需执行的操作次数 $f(n)$ 的增长率**。

### 一些重要的定理

#### 多项式定理

 **如果 $T(n)$ 是个 $k$ 次多项式（最高次方为 $k$ 次）。那么 $T(n) = O(n^k)$**。

 先看它的数学证明：

::: theorem 定理：
![2020-1-13-10-12-8.png](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-1-13-10-12-8.png)
:::

应用到算法分析中：

**我们在分析一个算法、一段代码的时间复杂度的时候，也只关注循环执行次数最多的那一段代码就可以了**。

::: details-open 例子：

```java
int cal(int n) {
  int sum = 0;
  for (int i = 1; i <= n; ++i) {
    sum = sum + i;
  }
  return sum;
}
```

上面代码中有一个 for 循环，里面的代码被执行了 n 次。也就是说时间复杂度为 $O(n)$
:::

#### 加法定理

::: theorem 定义：
![2020-1-13-10-21-46.png](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-1-13-10-21-46.png)
:::

在算法分析中：

**一个算法的时间复杂度等于量级最大的那段代码的复杂度**。

::: details-open 例子：

```java

int cal(int n) {
  int sum_1 = 0;
  for (int p = 1;; p <= 100; ++p) {
    sum_1 = sum_1 + p;
  }

  int sum_2 = 0;
  for (int q = 1; q <= n; ++q) {
    sum_2 = sum_2 + q;
  }

  int sum_3 = 0;
  int i, j
  for (i = 1; i <= n; ++i) {
    for (j = 1;; j <= n; ++j) {
      sum_3 = sum_3 +  i * j;
    }
  }

  return sum_1 + sum_2 + sum_3;
}
```

 上面这段代码可以分成三个部分。分别是求 sum_1、sum_2、sum_3。我们可以分别分析每一部分的时间复杂度，然后把它们放到一块儿，再取一个量级最大的作为整段代码的复杂度。

- 第一段代码执行了 100 次，这是个常量执行时间，时间复杂度为 $O(1)$；
- 第二段代码执行了 n 次，时间复杂度为 $O(n)$；
- 第三段代码执行了 $n^2$ 次，时间复杂度为 $O(n^2)$；

那么整段代码的时间复杂度为：$max(O(1), O(n), O(n^2)) = O(n^2)$
:::

#### 乘法定理

::: theorem 定义：
![2020-1-13-11-7-0.png](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-1-13-11-7-0.png)
:::

一个算法中，**嵌套代码的复杂度等于嵌套内外代码复杂度的乘积**

::: details-open 例子：

```java
int cal(int n) {
  int ret = 0;
  for (int i = 1; i <= n; ++i) {
    ret = ret + f(i);
  }
}

int f(int n) {
  int sum = 0;
  for (int i = 1; i <= n; ++i) {
    sum = sum + i;
  }
  return sum;
}
```

上面代码中，cal 函数的 for 循环里面调用了 f 函数。f 函数里面也有一个 for 循环。两段循环的时间复杂度都是 $O(n)$ 那么 cal 函数的时间复杂度就是 $O(n * n) = O(n^2)$
:::

### 常见的复杂度量级

下面介绍算法中常见的复杂度量级：

**常数级别 $O(1)$**

例如：两个数相加

```
a = b + c
```

**对数级别 $O(logN)$**

例如：二分查找算法

**线性级别 $O(N)$**

 例如： 一个 for 循环

```js
for(int i = 0; i < N; i++) {
  ...
}
```

**线性对数级别 $O(NlogN)$**

例如：归并排序

**平方级别 $O(N^2)$**

例如：两个 for 循环嵌套

```js
for(int i = 0; i < N; i++) {
  for(int j = 0; j < N; j++) {
    ...
  }
}
```

**立方级别 $O(N^3)$**

例如：三个 for 循环嵌套

```js
for(int i = 0; i < N; i++) {
  for(int j = 0; j < N; j++) {
    for(int k = 0; k < N; k++) {
      ...
    }
  }
}
```

**指数级别 $O(2^N)$**
**阶乘级别 $O(N!)$**

下图显示了随着输入规模的增长， 各个复杂度所运行花费时间时间的增长：

![2020-1-13-11-33-39.png](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-1-13-11-33-39.png)

在实际开发中，我们总是希望可以找到线性对数级别，线性级别，或者对数级别的复杂度的算法实现。

### 最好/最坏情况时间复杂度

**『 最好情况时间复杂度 』，指该算法求解问题时，最少需要的运算次数**。
**『 最坏情况时间复杂度 』，指该算法求解问题时，最多需要的运算次数**。

::: details-open 例子：
举例来说：

```js
function findNum(arr, num) {
  var index = undefined;
  for (i = 0; i < arr.length; i++) {
    if (arr[i] === num) {
      index = i;
      break;
    }
  }
  return index;
}
```

 上面代码用于找到目标数字，在数组中的位置。如果数组的第一个元素正好是我们要找的数字，那时间复杂度就是 $O(1)$。如果最后一个元素才是，那时间复杂度就是 $O(n)$。
:::

### 平均情况时间复杂度

 最好/最坏时间复杂度都表现的是算法的极端情况表现。为了更好的表示算法日常的时间复杂度，我们采用『 平均情况时间复杂度 』

::: details-open 例子：
还是拿上面 👆 在数组中找数字的函数举例。目标数字出现的位置可能有 n + 1 种情况（在数组的 0 ~ n - 1 的位置中，或者不在数组中）。我们把每种情况查找需要遍历的元素个数累加起来，然后再除以 n+1，就可以得到需要遍历的元素个数的平均值。

$\frac{1 + 2 + 3 + ... + n + n}{n + 1} = \frac{n(n + 3)}{2(n + 1)}$

时间复杂度的大 O 标记法中，可以省略掉系数、低阶、常量。最后一化简， 可以得出平均时间复杂度就是 $O(n)$
:::

实际上，在大多数情况下，我们并不需要区分最好、最坏、平均情况时间复杂度三种情况。**只有同一个算法在不同的情况下，最好/最坏时间复杂度有量级的差距，我们才会使用这三种复杂度表示法来区分**。

### 均摊时间复杂度

## 空间复杂度分析

时间复杂度表示的输入规模，和算法执行时间之间的增长关系。

**空间复杂度表示的是输入规模，和储存空间之间的增长关系**。

 可以看下面这段例子：

```c
void xxx(n) {
  int[] arr = new int[n];
  for(int i = 0; i < n; i++) {
    arr[i] = i * 2;
  }
}
```

上面代码中 ，我们申请了一个长度为 n 的 int 类型数组。所以这段代码的空间复杂度为 $O(n)$。

在分析空间复杂度时，常见的复杂度级别也就是：$O(1)$、$O(n)$、$O(n^2)$。其他的很少见到。
