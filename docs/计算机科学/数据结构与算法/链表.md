# 链表

**链表存储有序的元素集合**，但不同于数组，链表中的元素在内存中并不是连续放置的。**每个元素由一个存储元素本身的节点和一个指向下一个元素的指针组成**。

![2020-1-13-12-59-59.png](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-1-13-12-59-59.png)

## 单链表

上图就是一个单链表。其中有两个结点是比较特殊的，它们分别是第一个结点和最后一个结点。我们习惯性地把第一个结点叫作『 **头结点** 』，把最后一个结点叫作『 **尾结点** 』。

**头结点用来记录链表的基地址**。有了它，我们就可以遍历得到整条链表。

**尾结点上 next 指针指向一个空地址 NULL**，表示这是链表上最后一个结点。

相对于传统的数组，链表的一个好处在于，因为链表的存储空间本身就不是连续的。**链表添加或移除元素的时候不需要移动其他元素**。

从下图中我们可以看出，针对链表的插入和删除操作，我们只需要考虑相邻结点的指针改变，所以对应的时间复杂度是 $O(1)$。

![2020-1-13-13-7-35.png](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-1-13-13-7-35.png)

但是要**想访问链表中间的一个元素，需要从表头开始迭代列表直到找到所需的元素**。

## 循环链表

循环链表是一种特殊的单链表。它跟单链表唯一的区别就在尾结点。单链表的尾结点指针指向空地址，表示这就是最后的结点了。而**循环链表的尾结点指针是指向链表的头结点**。

![2020-1-13-13-10-2.png](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-1-13-13-10-2.png)

循环链表的优点是从链尾到链头比较方便。

## 双向链表

**双向链表它支持两个方向，每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点**。

![2020-1-13-13-11-23.png](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-1-13-13-11-23.png)

从结构上来看，双向链表可以支持 O(1) 时间复杂度的情况下找到前驱结点，正是这样的特点，也使双向链表在某些情况下的插入、删除等操作都要比单链表简单、高效。

举例来讲，在删除操作中，一般有如下两种情况：

- 删除结点中“值等于某个给定值”的结点；
- 删除给定指针指向的结点。

对于第一种情况，不管是单链表还是双向链表，为了查找到值等于给定值的结点，都需要从头结点开始依次遍历对比，直到找到值等于给定值的结点。时间复杂度为 $O(n)$

对于第二种情况，我们已经找到了要删除的结点，但是删除某个结点 q 需要知道其前驱结点，而单链表并不支持直接获取前驱结点，所以，为了找到前驱结点，我们还是要从头结点开始遍历链表。时间复杂度为 $O(n)$。

但对于双向链表来说，结点已经保存了前驱结点的指针，不需要像单链表那样遍历。所以，针对第二种情况，双向链表的时间复杂度为 $O(1)$。

## 双向循环链表

结合一下双向链表和循环链表就是『 双向循环链表 』

双向循环链表有指向 head 元素的 tail.next 和指向 tail 元素的 head.prev。

![2020-1-13-13-30-55.png](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-1-13-13-30-55.png)

## LRU 缓存淘汰算法

缓存是一种提高数据读取性能的技术，存的大小有限，当缓存被用满时，哪些数据应该被清理出去，哪些数据应该被保留？这就需要缓存淘汰策略来决定。常见的策略有三种：

- 先进先出策略 FIFO（First In，First Out）
- 最少使用策略 LFU（Least Frequently Used）
- 最近最少使用策略 LRU（Least Recently Used）

下面用 “链表” 来实现 LRU 缓存淘汰算法：

**思路**：维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。

1. 如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。
2. 如果此数据没有在缓存链表中，又可以分为两种情况：
   - 如果此时缓存未满，则将此结点直接插入到链表的头部；
   - 如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。

因为不管缓存有没有满，我们都需要遍历一遍链表，所以这种基于链表的实现思路，缓存访问的时间复杂度为 $O(n)$。
