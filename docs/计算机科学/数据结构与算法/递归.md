# 递归

递归的基本思想：**把规模大的问题拆解成，规模小的，重复的子问题**。

 下图就展现了递归的思想：

![2020-1-14-10-38-39.png](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-1-14-10-38-39.png)

## 如何写递归代码

我们可以用递归来定义函数。在开始写函数之前我们需要先给出**递归定义**：

- **基本步骤：定义初始输入，和对应的函数值**；
- **递归步骤：从前一个函数值得到当前的值的规则**；

当有了递归定义后， 我们再把它转化成递归代码。

下面举两个例子：

::: details-open 🌰 例子：
**问题**：假如有 n 个台阶，每次你可以选择跨 1 个台阶或者 2 个台阶。请问走这 n 个台阶有多少种走法？

**解**：首先，根据第一步的走法把所有走法分为两类：

- 第一步走了 1 个台阶。之后还剩 n - 1 个台阶；
- 第一步走了 2 个台阶。之后还剩 n - 2 个台阶；

之后我们可以得到 **递归步骤 ( 递归公式 )**：

```java
// 当有 n 个台阶时，走法等于 n - 1 个台阶的走法加上 n - 2 个台阶的走法。
f(n) = f(n - 1) + f(n - 2)
```


很明显可以得出，当只剩一个台阶时，只剩一下一种走法。当只剩两个个台阶时，只剩一下两种走法。所以递归的 **基本步骤 ( 终止条件 )** 就是：

```java
f(1) = 1
f(2) = 2
```

下面我们把递归定义转换成代码：

```java
int f(int n) {

  // 基本步骤（终止条件）
  if (n == 1) return 1;
  if (n == 2) return 2;

  // 递归步骤（递归公式）
  return f(n-1) + f(n-2);
}
```

:::

::: details-open 🌰 例子：

**问题**：计算 $n!$

**解**：首先，我们知道 $1$ 和 $0$ 的阶乘为 $1$。所以递归的 **基本步骤 ( 终止条件 )** 就是：

```java
f(0) = 1;
f(1) = 1;
```

之后，我们可以想出来在阶乘中每一步都是一个数字 $n$ 与 $(n - 1)!$ 进行相乘。可以得到 **递归步骤 ( 递归公式 )**：

```java
f(n) = n * f(n - 1);
```

最后，把递归定义转换成代码：

```java
int factorial(int n) {
  if(n <= 1) return 1;
  return n * factorial(n - 1);
}
```

:::

## 递归代码模板

```java
public void recursion(int param) {

  // terminator
  // 1. 递归终止条件
  if(param ?) {
    // process result
    return result;
  }

  // process current logic
  // 2. 处理当前逻辑
  process(param);

  // drill down
  // 3. 进入到下一层
  result = recursion(params);

  // reverse current status if needed
  // 4. 根据需求不同，可能需要在当前层结束时，有些东西要处理

  // 5. 返回当前层结果
  return result;
}
```

## 将递归代码改写为非递归代码

虽然递归算法的表达力很强，但是递归算法的**空间复杂度高、有堆栈溢出的风险、存在重复计算、过多的函数调用会耗时较多等问题**。所以，在开发过程中，我们要根据实际情况来选择是否需要用递归的方式来实现。

比如 👆 走台阶的的例子中，就会出现重复计算的问题。想要计算 `f(5)`，需要先计算 `f(4)` 和 `f(3)`，而计算 `f(4)` 还需要计算 `f(3)`，因此，`f(3)` 就被计算了很多次，这就是重复计算问题。

![2020-1-14-13-29-51.png](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-1-14-13-29-51.png)

可以用 **迭代循环** 去改写成非递归写法。

例如，上面走台阶的递归算法可以改写成：

```java
int f(int n) {
  if (n == 1) return 1;
  if (n == 2) return 2;

  int result = 0;
  int pre = 2;
  int prepre = 1;
  for (int i = 3; i <= n; ++i) {
    result = pre + prepre;
    prepre = pre;
    pre = result;
  }
  return result;
}
```
