# 数组

## 删除排序数组中的重复项

[LeetCode 练习](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)

给定一个排序数组，你需要在「 原地 」删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。

🌰 示例：

> 给定 nums = [0,0,1,1,1,2,2,3,3,4],
>
> 函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。
>
> 你不需要考虑数组中超出新长度后面的元素。

💡 **思路**：使用「 双指针法 」

因为数组是排好序的，我们可以放置两个指针 $i$ 和 $j$，其中 $i$ 是慢指针，而 $j$ 是快指针。只要 $nums[i]=nums[j]$ 我们就增加 $j$ 以跳过重复项。

当我们遇到 $nums[j]≠nums[i]$ 时，跳过重复项的运行已经结束，因此我们必须把它（ $nums[j]$ ）的值复制到 $nums[i + 1]$。然后递增 $i$，接着我们将再次重复相同的过程，直到 $j$ 到达数组的末尾为止。

```java
public int removeDuplicates(int[] nums) {
    int i = 0, j;

    for(j = 1; j < nums.length; j++) {

        if(nums[i] != nums[j]) { // 如果 i 和 j 指向的数字不一样，
            i++;                 // i 就向前走一步，
            nums[i] = nums[j];   // 然后把 j 指向的值赋给 i 指向的元素。
        }
    }

    return i + 1;
}
```

📝 **算法性能分析**：

- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$

## 买股票的最佳时机

[LeetCode 练习](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/solution/)

给定一个数组，它的第 `i` 个元素是一支给定股票第 `i` 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（ 多次买卖一支股票 ）。

但是，你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

🌰 示例：

> 输入: [7,1,5,3,6,4]
>
> 输出: 7
>
> 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。

💡 **思路**：

连续比较 数组相邻元素之间的差值，如果第二个数字大于第一个数字，就代表有利润。将这些差值累加在一起，就是总利润。

![2020-08-19-09-59-21](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-08-19-09-59-21.png)

从上图中，我们可以观察到 $A+B+C$ 的和等于差值 $D$ 所对应的连续峰和谷的高度之差。

```java
public int maxProfit(int[] prices) {
    int total = 0;

    for(int i = 0; i < prices.length - 1; i++) {
        if(prices[i + 1] > prices[i]) {
            total += prices[i + 1] - prices[i];
        }
    }

    return total;
}
```

## 旋转数组

## 存在重复元素

## 只出现一次的数字

## 两个数组的交集

## 加一

[LeetCode 练习](https://leetcode-cn.com/problems/plus-one/)

给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。

最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。

这个整数不会以零开头。

🌰 示例：

> 输入: [1,2,3]
>
> 输出: [1,2,4]
>
> 解释: 输入数组表示数字 123。

💡 **思路**：

```java
public int[] plusOne(int[] digits) {
    int carry = 0, tempCarry = 0;
    int length = digits.length;

    // 最后一个元素 + 1
    carry = (digits[length - 1] + 1) / 10;
    digits[length - 1] = (digits[length - 1] + 1) % 10;

    // 从后往前计算
    for(int i = digits.length - 2; i >= 0; i--) {
        tempCarry = (digits[i] + carry) / 10;
        digits[i] = (digits[i] + carry) % 10;
        carry = tempCarry;
    }

    // 扩容
    if(carry >= 1) {
        int newArr[] = new int[length + 1];
        newArr[0] = 1;
        for(int i = 0; i < length; i++) {
          newArr[i + 1] = digits[i];
        }
        return newArr;
    }

    return digits;
}
```

## 移动零

## 两数之和
