# 链表

## 如何实现链表的逆序

给定一个带头结点的单链表，请将其逆序。

- 即如果单链表原来为 `head→1→2→3→4→5→6→7`
- 逆序后变为 `head→7→6→5→4→3→2→1`

### 方法一：就地逆序

![2020-08-15-09-32-47](https://garrik-default-imgs.oss-accelerate.aliyuncs.com/imgs/2020-08-15-09-32-47.png)

💡**思路**：

- 在遍历链表时，修改当前结点的 `next` 指针的指向，让其指向它的前驱结点。为此，需要用一个指针变量来保存前驱结点的地址。
- 此外，为了在调整当前结点的 `next` 指针的指向后还能找到后继结点，还需要另外一个指针变量来保存后继结点的地址。
- 然后从前到后一个个地进行遍历修改。
- 还需要特别注意对链表首尾结点的特殊处理。

```java
public ListNode reverseList(ListNode head) {
    // 判断链表是否为空，或者只有一个元素
    if(head == null || head.next == null) {
        return head;
    }

    ListNode pre = null;  // 前驱结点
    ListNode cur = null;  // 当前结点
    ListNode next = null; // 后驱结点

    pre = head;
    cur = pre.next;
    pre.next = null;

    while(cur.next != null) {
        next = cur.next;
        cur.next = pre;            // cur.next 指向前驱结点
        pre = cur;                 // 此次遍历的 cur 变成下次遍历的 pre
        cur = next;                // 此次遍历的 next 变成下次遍历的 cur
    }

    // 最后一个结点指向它的前一个结点
    cur.next = pre;
    // 链表的头结点指向最后一个节点
    head = cur;

    return head;
}
```

📝 **算法性能分析**：

- 以上这种方法只需要对链表进行一次遍历，因此，**时间复杂度** 为 $O(n)$。其中，$n$ 为链表的长度。
- 需要常数个额外的变量来保存当前结点，前驱结点，后继结点。因此，**空间复杂度** 为 $O(1)$。

### 方法二：递归法

```java

public ListNode reverseList(ListNode head) {
    // 判断链表是否为空
    if(head == null) {
        return head;
    }

    ListNode newHead = recursiveReverse(head);
    return newHead;
}

private ListNode recursiveReverse(ListNode head) {
    //
    if(head.next == null) {
        return head;
    }

    // 递归翻转链表，返回新链表的头结点
    ListNode newHead = recursiveReverse(head.next);
    ListNode newTail = head.next;
    newTail.next = head;
    head.next = null;
    return newHead;
}
```

📝 **算法性能分析**：

- 由于递归法也只需要对链表进行一次遍历，因此，算法的时间复杂度也为 $O(n)$。
- 但是由于需要额外的压栈与弹栈操作，因此所需空间会更大，与「 方法 1 - 就地逆序 」相比性能会有所下降。

### 递归逆序打印链表 ( 不改变原始结构 )

```java
void recursiveReversePrint(ListNode head) {
    if(head == null) return;

    recursiveReversePrint(head.next);
    System.out.printf("%d ", head.val);
}
```

## 如何从无序链表中移除重复项

给定一个没有排序的链表，去掉其重复项，并保留原顺序。

- 如原始链表为 `1→3→1→5→5→7`，
- 去掉重复项后变为 `1→3→5→7`。

### 方法一：顺序删除

### 方法二：递归法

## 如何计算两个单链表所代表的数之和
