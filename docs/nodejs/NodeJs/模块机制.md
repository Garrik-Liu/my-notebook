# 模块机制:

在 Node.js 模块系统中，每个文件都被视为独立的模块。这个文件可能是 JavaScript 代码、JSON 或者编译过的 C/C++ 扩展

> 比如 http 是 Node.js 的一个核心模块，其内部是用 C++ 实现的，外部用 JavaScript 封装。

通过使用模块机制, 我们可以把一个复杂程序各个功能拆分, 分别封装到不同的文件. 在需要的时候引入相关的模块. 
这样做可以让代码的可读性, 复用性, 和易维护性够变得更高.

Node.js 的模块机制实现参照了 CommonJS 标准.


## 创建 & 加载模块:

Node.js 使用 exports 对象 和 require 方法来管理模块依赖.

* exports 对象 里定义了模块中想要被外界访问的内容.

* require 方法 引入外界模块到当前文件.

``` js
// myModule.js
var name = '';

exports.setName = function(setName) {
    name = setName;
}

exports.getName = function() {
    return name;
}
```

``` js
// getModule.js
var myModule = require('./myModule');

myModule.setName("Garrik");

console.log(myModule.getName());
```

在以上示例中，myModule.js 通过在 exports 对象指定 setName 和 getName 这两个方法, 两个匿名函数被导出了.

在 getmodule.js 中通过 `require('./myModule') `加载这个模块，然后就可以直接访问 myModule.js 中定义在 exports 对象里的函数了。

## 深入 require 方法:

`require` 源码:
``` js
// Loads a module at the given file path. Returns that module's
// `exports` property.
Module.prototype.require = function(path) {
  assert(path,'missing path');
  assert(typeof path ==='string','path must be a string');
  return Module._load(path, this);
};
```

`require()` 函数是 `Module`对象 原型上的一个方法. 

接收一个路径 (`path`) 作为参数,  `assert` 模块进行简单的 `path` 变量的判断，需要传人的 `path` 是一个 `string` 类型。

模块文件的后缀 ( 例如: `.js`, `.json`, `.node`) 可以省略.

当它执行的时候, 经历下面五个步骤:

* `Resolving`: 找到文件的绝对路径；

* `Loading`: 判断文件内容类型；

* `Wrapping`: 打包，给这个文件赋予一个私有作用范围

* `Evaluating`: VM 对加载的代码进行处理的地方；

* `Caching`: 缓存, 当再次需要用这个文件的时候，不需要重复一遍上面步骤。

### Resolving - 解析路径:

在每个模块中都有一个 `module`对象 (`Module` 的实例) 作为当前模块的引用.

`module` 对象可能看起来像下面这样:

``` js
Module {
  // 模块的标识符。 通常是完全解析后的文件名。
  id: '.',
  // 
  exports: { name: 'Garrik' },
  // 最先引用该模块的模块
  parent: null,
  // 模块的完全解析后的文件名
  filename: '/Users/xiangliu/Desktop/testNode/myModules/myName.js',
  // 模块是否已经加载完成，或正在加载中
  loaded: false,
  // 被该模块引用的模块对象
  children: [],
  // 模块的搜索路径
  paths:
   [ '/Users/xiangliu/Desktop/testNode/myModules/node_modules',
     '/Users/xiangliu/Desktop/testNode/node_modules',
     '/Users/xiangliu/Desktop/node_modules',
     '/Users/xiangliu/node_modules',
     '/Users/node_modules',
     '/node_modules' ] }
```

每一个模块都有一个唯一的 id 属性来标示它。id 通常是文件的完整绝对路径. 

Node 模块和文件系统中的文件通常是一一对应的，引入一个模块需要把文件内容加载到内存中。 

#### 路径参数:

在用`require()`引入模块时, 路径参数可能有下面三种形式:
* 相对路径: `./`开头 或 `../`开头
* 绝对路径: `/`开头
* 模块名 (例如: `http`, `fs`, `url`)

#### 无路径, 直接模块名:

如果我引入了一个 `haha` 模块，并没有指定它的路径的话：

``` js
var haha = require('haha');
```
Node 会按照 `module.paths` 所指定的文件目录顺序依次寻找 `haha` 的所在。若有两个同名文件，则遵循就近原则。优先引入目录顺序靠前的模块.

模块不一定非要是文件，也可以是个文件夹。我们可以在 node_modules 中创建一个 haha 文件夹，并且放一个 index.js 文件在其中。那么执行 `require('haha')` 将会默认使用 index.js 文件.  

也可以手动控制指定到其他文件，修改 `package.json` 的 `main` 属性就可以。

#### 有路径:

如果指定了模块的绝对路径, 或者相对路径. 

例如: 

``` js
var haha = require('./lib/haha');
```

因为用 `require` 来加载文件时可以省略扩展名, 所以在加载的时候, Node 会猜测文件的类型.

加载顺序为: 

* 按 js 文件来执行（先找对应路径当中是否有 haha.js 文件, 有就加载）
* 按 json 文件来解析（若上面的 js 文件找不到时，则找对应路径当中的 haha.json 文件来加载）
* 按照预编译好的 c++模块 来执行（还没有, 寻找对应路径当中的 haha.node 文件来加载）
* 若参数字符串为一个目录（文件夹）的路径, 则自动先查找该文件夹下的 package.json 文件，然后再加载该文件当中 main字段 所指定的入口文件。（若 package.json 文件当中没有 main字段，或者根本没有 package.json 文件，则再默认查找该文件夹下的 index.js 文件, 并作为模块来载入。）
* 要是还没有就玩蛋去吧!

## 参考:

* [Node 官方文档](http://nodejs.cn/api/modules.html#modules_the_module_object)
* [深入源码 - Chapter 2](https://github.com/yjhjstz/deep-into-node/blob/master/chapter2/chapter2-2.md)