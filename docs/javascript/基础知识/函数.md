# 函数

函数可以封装任意多条语句，而且可以在任何地方、任何时候调用执行。函数实际上是对象。每个函数都是 `Function` 类型的实例. 都与其他引用类型一样具有属性和方法。由于函数是对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。

定义函数的方式有三种：一种是函数声明，另一种就是函数表达式。还有一种是使用 `Function` 构造函数

**函数声明**的语法是这样的:

使用 `function` 关键字来声明，函数名后跟一组参数以及函数体

``` js
function functionName(arg0, arg1, arg2) {
    //函数体
}
```

函数声明, 它的一个重要特征就是函数声明提升（function declaration hoisting），意思是在执行代码之前会先读取函数声明。这就意味着可以把函数声明放在调用它的语句后面。

**函数表达式**的语法是这样的:

``` js
var functionName = function(arg0, arg1, arg2){
    //函数体 
};
```

这种形式看起来好像是常规的变量赋值语句，即创建一个函数并将它赋值给变量。这种情况下创建的函数叫做匿名函数（anonymous function），因为 `function` 关键字后面没有标识符。

**Function 构造函数** 可以接收任意数量的参数，但最后一个参数始终都被看成是函数体, 前面的参数则枚举出了新函数的参数

``` js
var sum = new Function("num1", "num2", "return num1 + num2"); // 不推荐
```

## 内部对象

### arguments 对象

函数不介意传递进来多少个参数，也不在乎传进来参数是什么数据类型。ECMAScript 中的参数在内部是用一个数组来表示的。函数接收到的始终都是这个数组，而不关心数组中包含哪些参数, 函数体内可以通过 `arguments` 对象来访问这个参数数组.

`arguments` 是对象, 不是 `Array` 的实例, 但是可以像数组一样用方括号语法访问它的每一个属性, 使用 `length` 属性来确定传递进来多少个参数

有点像下面这样:

``` js
var arguments = {
    "0": arg0,
    "1": arg1,
    "2": arg2,
    ...
    "N-1": argN,
}

console.log(arguments[2]); // arg2
```

`arguments` 的值永远与对应命名参数的值保持同步, `arguments` 对象中的值会自动反映到对应的命名参数, 修改 `arguments` 对象属性的值, 也会修改对应的命名参数

`arguments` 对象还有一个名叫 `callee` 的属性，该属性是一个指针，指向拥有这个 `arguments` 对象的函数

一个经典用法是:

``` js
function factorial(num){
    if (num <=1) {
        return 1;
    } else {
        return num * factorial(num-1)
    }
}
```

定义阶乘函数一般都要用到递归算法；如上面的代码所示，在函数有名字，而且名字以后也不会变的情况下，这样定义没有问题。但问题是这个函数的执行与函数名 `factorial` 紧紧耦合在了一起。为了消除这种紧密耦合的现象，可以像下面这样使用 `arguments.callee`。

``` js
function factorial(num){
    if (num <=1) {
        return 1;
    } else {
        return num * arguments.callee(num-1);
    }
}
```

`callee` 有一个属性是 `caller`, 这个属性中保存着调用当前函数的函数的引用, 如果是在全局作用域中调用当前函数，它的值为 `null`。

### this

`this` 引用的是函数执行的环境对象. 比如, 当在网页的全局作用域中调用函数时，`this` 对象引用的就是 `window`

``` js
window.color = "red";
var o = { color: "blue" };

function sayColor(){
    alert(this.color);
}

sayColor();     //"red"

o.sayColor = sayColor;
o.sayColor();   //"blue"
```

## 没有重载

ECMAScript 函数不能像传统意义上那样实现重载, 即为一个函数编写两个定义.

两个同名函数出现, 后面的覆盖前面的.

``` js
function addSomeNumber(num){
    return num + 100;
}

function addSomeNumber(num) {
    return num + 200;
}

var result = addSomeNumber(100); //300
```

因为函数名保存的是指向函数对象的指针, 以上代码实际上等价于下面的代码:

``` js
var addSomeNumber = function (num){
    return num + 100;
};

addSomeNumber = function (num) {
    return num + 200;
};

var result = addSomeNumber(100); //300
```

因为用了相同的函数名, 则指针指向了后者.

## 递归

## 闭包

## 模仿块级作用域

## 私有变量

