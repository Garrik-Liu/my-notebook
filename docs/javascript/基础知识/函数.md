# 函数

函数可以封装任意多条语句，而且可以在任何地方、任何时候调用执行。函数实际上是对象。每个函数都是 `Function` 类型的实例. 都与其他引用类型一样具有属性和方法。由于函数是对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。

定义函数的方式有三种：一种是函数声明，另一种就是函数表达式。还有一种是使用 `Function` 构造函数

**函数声明**的语法是这样的:

使用 `function` 关键字来声明，函数名后跟一组参数以及函数体

``` js
function functionName(arg0, arg1, arg2) {
    //函数体
}
```

函数声明, 它的一个重要特征就是函数声明提升（function declaration hoisting），意思是在执行代码之前会先读取函数声明。这就意味着可以把函数声明放在调用它的语句后面。

**函数表达式**的语法是这样的:

``` js
var functionName = function(arg0, arg1, arg2){
    //函数体 
};
```

这种形式看起来好像是常规的变量赋值语句，即创建一个函数并将它赋值给变量。这种情况下创建的函数叫做匿名函数（anonymous function），因为 `function` 关键字后面没有标识符。

**Function 构造函数** 可以接收任意数量的参数，但最后一个参数始终都被看成是函数体, 前面的参数则枚举出了新函数的参数

``` js
var sum = new Function("num1", "num2", "return num1 + num2"); // 不推荐
```

## 传递参数

ECMAScript 中所有函数的参数都是 **按值传递** 的, 也就是说，把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样。

**引用传递**是指在调用函数时将实际参数的地址传递到函数中,

值传递的精髓是：**传递的是存储单元中的内容，而非地址或者引用！**

在向参数传递基本类型的值时，被传递的值会被复制给一个局部变量（即命名参数，或者用 ECMAScript 的概念来说，就是 `arguments` 对象中的一个元素）

在向参数传递引用类型的值时，会把这个值所指向在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部。

``` js
function setName(obj) {
    obj.name = "Nicholas";
}

var person = new Object();
setName(person);
alert(person.name);    //"Nicholas"
```

那不对呀, 传递引用类型的时候复制不还是引用吗? 内部修改为什么会反映到外部?

JavaScript 编程语言只有值传递参数。当一个对象实例作为一个参数被传递到方法中时，参数的值就是该标识符对象实例的引用的副本。指向同一个实体对象, 对象的内容可以在被调用的方法中改变，但对象的引用(不是引用的副本)是永远不会改变的。 

## 内部属性

### arguments 对象

函数不介意传递进来多少个参数，也不在乎传进来参数是什么数据类型。ECMAScript 中的参数在内部是用一个数组来表示的。函数接收到的始终都是这个数组，而不关心数组中包含哪些参数, 函数体内可以通过 `arguments` 对象来访问函数调用时传进来的实参组成的数组.

`arguments` 是对象, 不是 `Array` 的实例, 但是可以像数组一样用方括号语法访问它的每一个属性, 使用 `length` 属性来确定传递进来多少个参数( "arguments" ), 函数对象自身也有一个 `length` 属性, 返回希望接收的命名/形式参数( "parameters" )个数. 

> 实参("argument")：全称为 "实际参数" 是在调用时传递给函数的参数
> 形参("parameter")：全称为 "形式参数" 由于它不是实际存在变量，所以又称虚拟变量。是在定义函数名和函数体的时候使用的参数, 目的是用来接收调用该函数时传入的参数. 在调用函数时，实参将赋值给形参。

有点像下面这样:

``` js
var arguments = {
    "0": arg0,
    "1": arg1,
    "2": arg2,
    ...
    "N-1": argN,
}

console.log(arguments[2]); // arg2
```

`arguments` 的值永远与对应命名参数的值保持同步, `arguments` 对象中的值会自动反映到对应的命名参数, 修改 `arguments` 对象属性的值, 也会修改对应的命名参数

### arguments.callee

`arguments` 对象还有一个名叫 `callee` 的属性，该属性是一个指针，指向拥有这个 `arguments` 对象的函数

一个经典用法是:

``` js
function factorial(num){
    if (num <=1) {
        return 1;
    } else {
        return num * factorial(num-1)
    }
}
```

定义阶乘函数一般都要用到递归算法；如上面的代码所示，在函数有名字，而且名字以后也不会变的情况下，这样定义没有问题。但问题是这个函数的执行与函数名 `factorial` 紧紧耦合在了一起。为了消除这种紧密耦合的现象，可以像下面这样使用 `arguments.callee`。

``` js
function factorial(num){
    if (num <=1) {
        return 1;
    } else {
        return num * arguments.callee(num-1);
    }
}
```

### caller

函数内的 `caller` 属性返回调用指定函数的函数.

如果一个函数 `f` 是在全局作用域内被调用的,则 `f.caller` 为 `null` ,相反,如果一个函数是在另外一个函数作用域内被调用的,则 `f.caller` 指向调用它的那个函数.

该属性的常用形式 `arguments.callee.caller` 替代了被废弃的 `arguments.caller`.

``` js
function myFunc() {
   if (myFunc.caller == null) {
      return ("该函数在全局作用域内被调用!");
   } else
      return ("调用我的是函数是" + myFunc.caller);
}
```

为了让函数名和函数体解耦, 可以改成下面这样:

``` js
function myFunc() {
   if (arguments.callee.caller == null) {
      return ("该函数在全局作用域内被调用!");
   } else
      return ("调用我的是函数是" + arguments.callee.caller);
}
```

### this

`this` 引用的是函数执行的环境对象. 比如, 当在网页的全局作用域中调用函数时，`this` 对象引用的就是 `window`

``` js
window.color = "red";
var o = { color: "blue" };

function sayColor(){
    alert(this.color);
}

sayColor();     //"red"

o.sayColor = sayColor;
o.sayColor();   //"blue"
```

## 没有重载

ECMAScript 函数不能像传统意义上那样实现重载, 即为一个函数编写两个定义.

两个同名函数出现, 后面的覆盖前面的.

``` js
function addSomeNumber(num){
    return num + 100;
}

function addSomeNumber(num) {
    return num + 200;
}

var result = addSomeNumber(100); //300
```

因为函数名保存的是指向函数对象的指针, 以上代码实际上等价于下面的代码:

``` js
var addSomeNumber = function (num){
    return num + 100;
};

addSomeNumber = function (num) {
    return num + 200;
};

var result = addSomeNumber(100); //300
```

因为用了相同的函数名, 则指针指向了后者.

## 递归

递归函数是在一个函数内通过名字调用自身的情况下构成的

``` js
function factorial(num){
    if (num <= 1){
        return 1;
    } else {
        return num * factorial(num-1);
    }
}
```

前面提到过, 用 `arguments.callee` 是一个指向正在执行的函数(`arguments`对象所在函数)的指针, 用他可以让函数名和函数体解耦.

``` js
function factorial(num){
    if (num <= 1){
        return 1;
    } else {
        return num * arguments.callee(num-1);
    }
}
```

但在严格模式下，不能通过脚本访问 `arguments.callee`，访问这个属性会导致错误。不过，可以使用**命名函数表达式**来达成相同的结果。

命名函数表达式 = 函数表达式 + 函数声明

``` js
var factorial = (function f(num){
    if (num <= 1){ 
        return 1;
    } else {
        return num * f(num-1);
    }
});
```

## 闭包

闭包是指有权访问另一个函数作用域中的变量的函数。

## 模仿块级作用域

## 私有变量

