# 数据类型

## 引用类型

在ECMAScript中，**引用类型**是一种数据结构, 是一组**数据和功能的无序集合**。它也常被称为**类**. 引用类型有时候也被称为**对象定义**，因为它们描述的是一类对象所具有的属性和方法。

对象是某个特定引用类型的实例。新对象是使用 `new` 操作符后跟一个构造函数来创建的。构造函数本身就是一个函数，只不过该函数是出于创建新对象的目的而定义的。

``` js
var person = new Object(); 
```

上面代码, 用 Object 构造函数创建了一个 Object 引用类型的新实例, 实例保存在变量 person 中.

### Object类型 

[文档](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object)

创建Object实例的方式有两种:

第一种是使用 `new` 操作符后跟 Object构造函数:

``` js
var person = new Object();
person.name = "Nicholas";
person.age = 29;
```

另一种方式是使用 对象字面量表示法:

``` js
var person = {
    name : "Nicholas",
    age : 29
};
```

也可以写成:

``` js
var person = {};
person.name = "Nicholas";
person.age = 29
```

上面这种写法先定义了一个 "空对象", 然后添加属性和方法.  但是注意 "空对象" 只是一个简称.  JS 中没有空对象, 最简单的 `{}` 也包含从 `Object.prototype` 继承来的属性和方法, 这里的 "空" 只是说它没有自有属性.

对象字面量与使用构造函数相比还是很多区别的: 在创建时尽量用 **对象字面量**
* 对象字面量代码更少, 更易读.
* 它可以强调对象就是一个简单的可变的散列表(可变哈希映射)，而不必一定派生自某个类
* 对象字面量不需要做 "作用域解析", 假如说我们自定义了一个同名的构造函数 `Object()`, 调用 `Object()` 创建新对象的时候, 解析器会顺着作用域链开始查找, 先找到自定义的了, 就不往上找了.  对象字面量不需要这个过程, 会更高效.
* `Object()` 可以接收参数, 可以根据参数不同把创建过程委托给别的内置构造函数


下面的示例代码中展示了给 `new Object()` 传入不同的参数（数字、字符串和布尔值），最终得到的对象是由不同的构造函数生成的：

``` js
// 空对象
var o = new Object();
console.log(o.constructor === Object); // true

// 数值对象
var o = new Object(1);
console.log(o.constructor === Number); // true

// 字符串对象
var o = new Object("I am a string");
console.log(o.constructor === String); // true

// 布尔值对象
var o = new Object(true);
console.log(o.constructor === Boolean); // true
```

问题: 下面这个我还没明白!!!
> 在通过对象字面量定义对象时，实际上不会调用Object构造函数

访问对象中的属性可以用 点表示法 和 方括号表示法, 使用方括号语法时，应该将要访问的属性以字符串的形式放在方括号中:

``` js
alert(person["name"]);          //"Nicholas"
alert(person.name);             //"Nicholas"
```

### Array类型 

[文档](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array)

ECMAScript 数组的每一项可以保存任何类型的数据。ECMAScript数组的大小是可以动态调整的，即可以随着数据的添加自动增长以容纳新增数据。

和 Object 一样, 也是有两种创建方法:

第一种: 使用 `Array` 构造函数:

``` js
var colors = new Array();

// 如果预先知道数组要保存的项目数量，也可以给构造函数传递该数量，而该数量会自动变成 "length" 属性的值。
var colors = new Array(20);

// 也可以向 Array 构造函数传递数组中应该包含的项。
var colors = new Array("red", "blue", "green");

// new 操作符可以省略
var colors = Array(3);      
```

第二种: 使用数组字面量表示法: 数组字面量由一对包含数组项的方括号 ("[]") 表示，多个数组项之间以逗号 (",") 隔开，

``` js
var colors = ["red", "blue", "green"];   // 创建一个包含3个字符串的数组
```

> 与对象一样，在使用数组字面量表示法时，也不会调用 Array 构造函数

在读取和设置数组的值时，要使用方括号 ("[]") 并提供相应值的 基于 0 的数字索引

``` js
var colors = ["red", "blue", "green"];    // 定义一个字符串数组
alert(colors[0]);                         // 显示第一项
colors[2] = "black";                      // 修改第三项
colors[3] = "brown";                      // 新增第四项
```

数组的项数保存在其 `length` 属性中，这个属性始终会返回0或更大的值, 通过设置 `length` 来删除, 添加数组项

``` js
var colors = ["red", "blue", "green"];       // 创建一个包含3个字符串的数组
console.log(colors.length); // 3

// 移除最后一项
colors.length = 2;

// 在末尾添加新项, 由于数组最后一项的索引始终是length-1，因此下一个新项的位置就是length。
colors[colors.length] = "black";
```

### 检测数组

`Array.isArray()` 方法可以确定某个值到底是不是数组

### 转换方法

数组的 `toString()` 方法会返回由数组中每个值的字符串形式拼接而成的一个以逗号 (",") 分隔的字符串.

``` js
var colors = ["red", "blue", "green"];      // 创建一个包含3个字符串的数组
alert(colors.toString());     // red,blue,green
```

`join()`方法可以使用不同的分隔符来构建返回包含所有数组项的字符串。只接收一个参数，即用作分隔符的字符串.

``` js
var colors = ["red", "green", "blue"];
alert(colors.join(","));       //red,green,blue
alert(colors.join("||"));      //red||green||blue
```

### 栈方法

栈是一种 LIFO（Last-In-First-Out，后进先出）的数据结构, 也就是最新添加的项最早被移除。

ECMAScript 数组也提供了一种让数组的行为类似于栈数据结构的方法。

* `push()` 方法可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度。
* `pop()`方法则从数组末尾移除最后一项，然后返回移除的项。

``` js
var colors = [];
colors.push("blue", "red");
var deleteColor = colors.pop(); 
```

### 队列方法

队列数据结构的访问规则是 FIFO（First-In-First-Out，先进先出）队列在列表的末端添加项，从列表的前端移除项。

* `push()` 是向数组末端添加项的方法, 返回长度
* `shift()` 是从数组前端取得项的方法, 返回移除的项
* `unshift()` 在数组前端添加任意个项并返回新数组的长度 

``` js
var colors = [];
colors.push("blue", "red");
var deleteColor = colors.shift(); 
```

### 重排序方法

数组中已经存在两个可以直接用来重排序的方法：`reverse()` 和 `sort()`。

`reverse()` 方法会反转数组项的顺序。

``` js
var values = [1, 2, 3, 4, 5];
values.reverse();
alert(values);        //5,4,3,2,1
```

在默认情况下，`sort()` 方法按升序排列数组项——即最小的值位于最前面，最大的值排在最后面。
为了实现排序，`sort()` 方法会调用每个数组项的 `toString()` 转型方法，也就是说最后比较的是字符串.

``` js
var values = [0, 1, 5, 10, 15];
values.sort();
alert(values);     //0,1,10,15,5
```

因为按照字符串进行比较, 就会出现上面的问题.

`sort()` 方法可以接收一个比较函数作为参数，以便我们指定哪个值位于哪个值的前面。比较函数接收两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回0，如果第一个参数应该位于第二个之后则返回一个正数。

``` js
var values = [0, 1, 5, 10, 15];
values.sort(compare);
alert(values);   //0,1,5,10,15

function compare(value1, value2) {
    return value1 - value2;
}
```

### 操作方法

#### concat()

`concat()` 方法可以用于拼接数组. 这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。

``` js
var colors = ["red", "green", "blue"];
var colors2 = colors.concat("yellow", ["black", "brown"]);

alert(colors);     //red,green,blue
alert(colors2);    //red,green,blue,yellow,black,brown
```

不传递任何参数, 可以硬复制一个数组, 数组是引用类型, 直接的复制只是复制了指针

``` js
var colors = ["red", "green", "blue"];
var colors2 = colors;
var colors3 = colors.concat();

colors[0] = "white";
alert(colors2); // white, green, blue
alert(colors3); // red, green, blue
```

#### slice()

`slice()` 用于切割数组, 接受一或两个参数，即要返回项的起始和结束位置. 在只有一个参数的情况下，`slice()` 方法返回从该参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项——但不包括结束位置的项。

``` js
var colors = ["red", "green", "blue", "yellow", "purple"];
var colors2 = colors.slice(1);
var colors3 = colors.slice(1,4);

alert(colors2);   //green,blue,yellow,purple
alert(colors3);   //green,blue,yellow
```

#### splice()

`splice()` 方法主要用途是向数组的中部插入项，但使用这种方法的方式则有如下3种:

删除: 可以删除任意数量的项，只需指定2个参数：要删除的第一项的位置和要删除的项数, 返回删除的项组成的数组

``` js
var colors = ["red", "green", "blue"];
var removed = colors.splice(0,1);                    // 删除第一项
alert(colors);     // green,blue
alert(removed);    // red，返回的数组中只包含一项
```

插入: 向指定位置插入任意数量的项，只需提供3个参数：起始位置、0（要删除的项数）和要插入的项。返回空数组

``` js
removed = colors.splice(1, 0, "yellow", "orange");   // 从位置1开始插入两项
alert(colors);     // green,yellow,orange,blue
alert(removed);    // 返回的是一个空数组
```

替换: 可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定3个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等

``` js
removed = colors.splice(1, 1, "red", "purple");      // 插入两项，删除一项
alert(colors);     // green,red,purple,orange,blue
alert(removed);    // yellow，返回的数组中只包含一项
```

### 位置方法

数组实例添加了两个位置方法: `indexOf()` 和 `lastIndexOf()`。

这两个方法都接收两个参数：要查找的项 和（可选的）表示查找起点位置的索引。其中，`indexOf()` 方法从数组的开头（位置0）开始向后查找，`lastIndexOf()` 方法则从数组的末尾开始向前查找。

返回要查找的项在数组中的位置，或者在没找到的情况下返回 -1。比较的时候用的是全等操作符 `===`

``` js
var numbers = [1,2,3,4,5,4,3,2,1];

alert(numbers.indexOf(4));        //3
alert(numbers.lastIndexOf(4));    //5

alert(numbers.indexOf(4, 4));     //5
alert(numbers.lastIndexOf(4, 4)); //3up

var person = { name: "Nicholas" };
var people = [{ name: "Nicholas" }];

var morePeople = [person];

alert(people.indexOf(person));     //-1
alert(morePeople.indexOf(person)); //0
```

### 迭代方法

ECMAScript 5 为数组定义了 5 个迭代方法。每个方法都接收两个参数：要在每一项上运行的函数和（可选的）运行该函数的作用域对象(影响 `this` 的值)。传入方法中的函数会接收三个参数：数组项的值、该项在数组中的位置 和 数组对象本身。

下面这些方法都不会修改原数组中的包含的值

* `every()`：对数组中的每一项运行给定函数，如果该函数对每一项都返回 `true`，则返回 `true`。

* `filter()`：对数组中的每一项运行给定函数，返回该函数会返回 `true` 的项组成的数组。

* `forEach()`：对数组中的每一项运行给定函数。这个方法没有返回值。

* `map()`：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。

* `some()`：对数组中的每一项运行给定函数，如果该函数对任一项返回 `true`，则返回 `true`。

### 缩小方法

ECMAScript 5还新增了两个缩小数组的方法：`reduce()` 和 `reduceRight()`。这两个方法都会迭代数组的所有项，然后构建一个最终返回的值。

`reduce()` 方法从数组的第一项开始，逐个遍历到最后。而 `reduceRight()` 则从数组的最后一项开始，向前遍历到第一项。

两个方法都接收两个参数：一个在每一项上调用的函数 和（可选的）作为缩小基础的初始值。

传给的函数接收 4 个参数：前一个值、当前值、项的索引 和 数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数就是数组的第二项。

``` js
var values = [1,2,3,4,5];
var sum = values.reduce(function(prev, cur, index, array){
    return prev + cur; 
});
alert(sum); //15
```

## Date类型 

[文档](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date)

## 哈希表 与 JS对象

### 哈希表

哈希表(hash table), 也叫散列表, 是根据键（Key）而直接访问在内存存储位置的二维数据结构。通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置, 通过这个位置来访问数据。这个映射函数称做散列函数，存放记录的数组称做散列表。 

举个例子: 查电话本, 将人名按照首字母排序, 找人时, 根据人的名字找到首字母, 根据首字母, 去对应字母的一栏查找具体的电话号码.
在这里, 人名是 "Key", 取人名首字母的过程是 "散列函数", 算出之后, 对应的首字母组为人名的 "Value", 人名和首字母构成散列表.

### 

JS 对象是基于 Hash 表存储变量的