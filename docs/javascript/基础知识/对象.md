# 对象

ECMA-262 把对象定义为：“无序属性的集合，其属性可以包含基本值、对象或者函数。” 对象的每个属性或方法都有一个名字，而每个名字都映射到一个值。每个对象都是基于一个引用类型创建的

对象创建方法可以有:

使用 `new` 操作符后跟一个构造函数来创建:

``` js
var person = new Object(); 
person.name = "Nicholas";
person.age = 29; 
person.job = "Software Engineer";

person.sayName = function(){
    alert(this.name); 
};
```

使用对象字面量创建:

``` js
var person = {
    name: "Nicholas", 
    age: 29,
    job: "Software Engineer",

    sayName: function(){
        alert(this.name);
    }
};
```

## 属性类型

JS 定义只有内部才用的特性（attribute），描述了属性（property）的各种特征。(特性用来描述属性) 这些特性是为了实现 JavaScript 引擎用的，因此在 JavaScript 中不能直接访问它们。为了表示特性是内部值，特性放在两对儿方括号中 `[[]]`，例如[[Enumerable]]

ECMAScript中有两种属性：数据属性 和 访问器属性。

### 数据属性

数据属性包含一个数据值的位置。在这个位置可以读取和写入值。数据属性有 4 个描述其行为的特性。

* `[[Configurable]]`：表示能否通过 `delete` 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为 `true`。

* `[[Enumerable]]`：表示能否通过 `for-in` 循环返回 (遍历) 属性。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为 `true`。

* `[[Writable]]`：表示能否修改属性的值。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为 `true`。

* `[[Value]]`：包含这个属性的数据值。读取属性值的时候，从这个位置读；写入属性值的时候，把新值保存在这个位置。这个特性的默认值为 `undefined`。

要修改属性默认的特性，必须使用 `Object.defineProperty()` 方法. 这个方法接收三个参数：属性所在的对象、属性的名字和一个描述符对象。其中，描述符（descriptor）对象的属性必须是：`configurable`、`enumerable`、`writable` 和 `value`。设置其中的一或多个值，可以修改对应的特性值。

``` js
var person = {};
person.name = "Greg";
alert(person.name);    //"Greg"

// name 属性值改成 "Nicholas", 并且设置为不可修改属性值
Object.defineProperty(person, "name", {
    writable: false,
    value: "Nicholas" 
});

alert(person.name);    //"Nicholas"
person.name = "Greg";
alert(person.name);    //"Nicholas"
```

``` js
var person = {};
Object.defineProperty(person, "name", {
    configurable: false,
    value: "Nicholas"
});

//抛出错误
Object.defineProperty(person, "name", {
    configurable: true,
    value: "Nicholas"
});
```

一旦把属性定义为不可配置 `configurable: false` 的，就不能再把它变回可配置了。此时，再调用 `Object.defineProperty()` 方法修改除 `writable` 之外的特性，都会导致错误.

在调用`Object.defineProperty()`方法时，如果不指定，`configurable`、`enumerable` 和 `writable` 特性的默认值都是 `false`。


### 访问器属性

访问器属性不包含数据值；它们包含一对 `getter` 和 `setter` 函数（不是必需的）

* 在读取访问器属性时，会调用 `getter` 函数，这个函数负责返回有效的值；
* 在写入访问器属性时，会调用 `setter` 函数并传入新值，这个函数负责决定如何处理数据。

访问器属性有如下4个特性。

* `[[Configurable]]`：表示能否通过 `delete` 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性。对于直接在对象上定义的属性，这个特性的默认值为 `true`。

* `[[Enumerable]]`：表示能否通过 `for-in` 循环返回属性。对于直接在对象上定义的属性，这个特性的默认值为 `true`。

* `[[Get]]`：在读取属性时调用的函数。默认值为 `undefined`。

* `[[Set]]`：在写入属性时调用的函数。默认值为 `undefined`。

访问器属性不能直接定义，必须使用 `Object.defineProperty()` 来定义。

``` js
var book = {
    // 加 下划线 ("_") 表示只能通过对象方法访问的属性
    _year: 2004, 
    edition: 1
};

Object.defineProperty(book, "year", {
    get: function(){
        return this._year;
    },
    set: function(newValue){
        if (newValue > 2004) {
            this._year = newValue;
            this.edition += newValue - 2004;
        }
    }
});

book.year = 2005;
alert(book.edition);  //2
```


使用访问器属性，设置一个属性的值会导致其他属性发生变化。

只指定 `getter` 意味着属性是不能写，尝试写入属性会被忽略。在严格模式下，尝试写入只指定了 `getter` 函数的属性会抛出错误。类似地，只指定 `setter` 函数的属性也不能读，否则在非严格模式下会返回 `undefined`，而在严格模式下会抛出错误。

### 修改多个属性的特性

使用 `Object.defineProperties()` 方法, 可以通过一个描述符定义多个属性的特性
方法接收两个对象参数：
* 第一个对象是要添加和修改其属性的对象
* 第二个对象的属性与第一个对象中要添加或修改的属性一一对应

``` js
var book = {};

// 代码在 book 对象上定义了两个数据属性（_year和edition）和一个访问器属性（year）
Object.defineProperties(book, {
    _year: {
        writable:true,
        value: 2004
    },

    edition: {
        writable:true,
        value: 1
    },

    year: {
        get: function(){
            return this._year;
        },

        set: function(newValue){
            if (newValue > 2004) {
                this._year = newValue;
                this.edition += newValue - 2004;
            }
        }
    }
});
```

### 读取属性的特性

`Object.getOwnPropertyDescriptor()` 方法，可以取得给定属性的描述符, 方法接收两个参数：属性所在的对象 和 要读取其描述符的属性名称。

``` js
var book = {};

Object.defineProperties(book, {
    _year: { 
        value: 2004
    },

    edition: {
        value: 1
    },

    year: {
        get: function(){
            return this._year;
        },

        set: function(newValue){
            if (newValue > 2004) {
                this._year = newValue;
                this.edition += newValue - 2004;
            }
        }
    }
});

var descriptor = Object.getOwnPropertyDescriptor(book, "_year");
alert(descriptor.value);         //2004
alert(descriptor.configurable); //false
alert(typeof descriptor.get);    //"undefined"

var descriptor = Object.getOwnPropertyDescriptor(book, "year");
alert(descriptor.value);        //undefined
alert(descriptor.enumerable);   //false
alert(typeof descriptor.get);   //"function"
```

## 创建对象

## 继承