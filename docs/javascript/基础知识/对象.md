# 对象

ECMA-262 把对象定义为：“无序属性的集合，其属性可以包含基本值、对象或者函数。” 对象的每个属性或方法都有一个名字，而每个名字都映射到一个值。每个对象都是基于一个引用类型创建的

对象创建方法可以有:

使用 `new` 操作符后跟一个构造函数来创建:

``` js
var person = new Object(); 
person.name = "Nicholas";
person.age = 29; 
person.job = "Software Engineer";

person.sayName = function(){
    alert(this.name); 
};
```

使用对象字面量创建:

``` js
var person = {
    name: "Nicholas", 
    age: 29,
    job: "Software Engineer",

    sayName: function(){
        alert(this.name);
    }
};
```

## 属性类型

JS 定义只有内部才用的特性（attribute），描述了属性（property）的各种特征。(特性用来描述属性) 这些特性是为了实现 JavaScript 引擎用的，因此在 JavaScript 中不能直接访问它们。为了表示特性是内部值，特性放在两对儿方括号中 `[[]]`，例如[[Enumerable]]

ECMAScript中有两种属性：数据属性 和 访问器属性。

### 数据属性

数据属性包含一个数据值的位置。在这个位置可以读取和写入值。数据属性有 4 个描述其行为的特性。

* `[[Configurable]]`：表示能否通过 `delete` 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为 `true`。
* `[[Enumerable]]`：表示能否通过 `for-in` 循环返回 (遍历) 属性。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为 `true`。
* `[[Writable]]`：表示能否修改属性的值。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为 `true`。
* `[[Value]]`：包含这个属性的数据值。读取属性值的时候，从这个位置读；写入属性值的时候，把新值保存在这个位置。这个特性的默认值为 `undefined`。

要修改属性默认的特性，必须使用 `Object.defineProperty()` 方法. 这个方法接收三个参数：属性所在的对象、属性的名字和一个描述符对象。其中，描述符（descriptor）对象的属性必须是：`configurable`、`enumerable`、`writable` 和 `value`。设置其中的一或多个值，可以修改对应的特性值。

``` js
var person = {};
person.name = "Greg";
alert(person.name);    //"Greg"

// name 属性值改成 "Nicholas", 并且设置为不可修改属性值
Object.defineProperty(person, "name", {
    writable: false,
    value: "Nicholas" 
});

alert(person.name);    //"Nicholas"
person.name = "Greg";
alert(person.name);    //"Nicholas"
```

``` js
var person = {};
Object.defineProperty(person, "name", {
    configurable: false,
    value: "Nicholas"
});

//抛出错误
Object.defineProperty(person, "name", {
    configurable: true,
    value: "Nicholas"
});
```

一旦把属性定义为不可配置 `configurable: false` 的，就不能再把它变回可配置了。此时，再调用 `Object.defineProperty()` 方法修改除 `writable` 之外的特性，都会导致错误.

在调用`Object.defineProperty()`方法时，如果不指定，`configurable`、`enumerable` 和 `writable` 特性的默认值都是 `false`。


### 访问器属性

访问器属性不包含数据值；它们包含一对 `getter` 和 `setter` 函数（不是必需的）

* 在读取访问器属性时，会调用 `getter` 函数，这个函数负责返回有效的值；
* 在写入访问器属性时，会调用 `setter` 函数并传入新值，这个函数负责决定如何处理数据。

访问器属性有如下4个特性。

* `[[Configurable]]`：表示能否通过 `delete` 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性。对于直接在对象上定义的属性，这个特性的默认值为 `true`。
* `[[Enumerable]]`：表示能否通过 `for-in` 循环返回属性。对于直接在对象上定义的属性，这个特性的默认值为 `true`。
* `[[Get]]`：在读取属性时调用的函数。默认值为 `undefined`。
* `[[Set]]`：在写入属性时调用的函数。默认值为 `undefined`。

访问器属性不能直接定义，必须使用 `Object.defineProperty()` 来定义。

``` js
var book = {
    // 加 下划线 ("_") 表示只能通过对象方法访问的属性
    _year: 2004, 
    edition: 1
};

Object.defineProperty(book, "year", {
    get: function(){
        return this._year;
    },
    set: function(newValue){
        if (newValue > 2004) {
            this._year = newValue;
            this.edition += newValue - 2004;
        }
    }
});

book.year = 2005;
alert(book.edition);  //2
```


使用访问器属性，设置一个属性的值会导致其他属性发生变化。

只指定 `getter` 意味着属性是不能写，尝试写入属性会被忽略。在严格模式下，尝试写入只指定了 `getter` 函数的属性会抛出错误。类似地，只指定 `setter` 函数的属性也不能读，否则在非严格模式下会返回 `undefined`，而在严格模式下会抛出错误。

### 修改多个属性的特性

使用 `Object.defineProperties()` 方法, 可以通过一个描述符定义多个属性的特性
方法接收两个对象参数：
* 第一个对象是要添加和修改其属性的对象
* 第二个对象的属性与第一个对象中要添加或修改的属性一一对应

``` js
var book = {};

// 代码在 book 对象上定义了两个数据属性（_year和edition）和一个访问器属性（year）
Object.defineProperties(book, {
    _year: {
        writable:true,
        value: 2004
    },

    edition: {
        writable:true,
        value: 1
    },

    year: {
        get: function(){
            return this._year;
        },

        set: function(newValue){
            if (newValue > 2004) {
                this._year = newValue;
                this.edition += newValue - 2004;
            }
        }
    }
});
```

### 读取属性的特性

`Object.getOwnPropertyDescriptor()` 方法，可以取得给定属性的描述符, 方法接收两个参数：属性所在的对象 和 要读取其描述符的属性名称。

``` js
var book = {};

Object.defineProperties(book, {
    _year: { 
        value: 2004
    },

    edition: {
        value: 1
    },

    year: {
        get: function(){
            return this._year;
        },

        set: function(newValue){
            if (newValue > 2004) {
                this._year = newValue;
                this.edition += newValue - 2004;
            }
        }
    }
});

var descriptor = Object.getOwnPropertyDescriptor(book, "_year");
alert(descriptor.value);         //2004
alert(descriptor.configurable); //false
alert(typeof descriptor.get);    //"undefined"

var descriptor = Object.getOwnPropertyDescriptor(book, "year");
alert(descriptor.value);        //undefined
alert(descriptor.enumerable);   //false
alert(typeof descriptor.get);   //"function"
```

## 创建对象

### 工厂模式

为了抽象了创建具体对象的过程, 开发人员发明了一种函数用来封装以特定接口创建对象的细节

``` js
function createPerson(name, age, job){
    var o = new Object();
    o.name = name;
    o.age = age;
    o.job = job;
    o.sayName = function(){
        alert(this.name);
    };    
    return o;
}

var person1 = createPerson("Nicholas", 29, "Software Engineer");
var person2 = createPerson("Greg", 27, "Doctor");
```

工厂模式虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题（即怎样知道一个对象的类型）

### 构造函数模式

构造函数可用来创建特定类型的对象, 例如，可以使用构造函数模式将前面的例子重写如下。

``` js
function Person(name, age, job){
    this.name = name;
    this.age = age;
    this.job = job;
    this.sayName = function(){
        alert(this.name);
    };    
}

var person1 = new Person("Nicholas", 29, "Software Engineer");
var person2 = new Person("Greg", 27, "Doctor");
```

构造函数 和 工厂模式 相比:
* 没有显式地创建对象；
* 直接将属性和方法赋给了 `this` 对象；
* 没有 `return` 语句。

用构造函数创建新实例，必须使用 `new` 操作符。以这种方式调用构造函数实际上会经历以下4个步骤：
* 创建一个新对象；
* 将构造函数的作用域赋给新对象（因此 `this` 就指向了这个新对象）；
* 执行构造函数中的代码（为这个新对象添加属性）；
* 返回新对象。

用构造函数创建的对象实例, 有一个 `constructor` 属性, 指向构造函数:

前面的例子里:

``` js
alert(person1.constructor == Person);  //true
alert(person2.constructor == Person);  //true
```

`instanceof` 操作符, 可以用来检测对象类型:

例子中创建的所有对象既是 `Object` 的实例，同时也是 `Person` 的实例. 所有对象均继承自 `Object`

``` js
alert(person1 instanceof Object);  //true
alert(person1 instanceof Person);  //true
alert(person2 instanceof Object);  //true
alert(person2 instanceof Person);  //true
```

#### 将构造函数当作函数

构造函数与其他函数的唯一区别，就在于调用它们的方式不同. 任何函数，只要通过 `new` 操作符来调用，那它就可以作为构造函数；而任何函数，如果不通过 `new` 操作符来调用，那它跟普通函数也不会有什么两样。

``` js
// 当作构造函数使用
var person = new Person("Nicholas", 29, "Software Engineer");
person.sayName(); //"Nicholas"

// 作为普通函数调用
Person("Greg", 27, "Doctor"); // 添加到window
window.sayName(); //"Greg"

// 在另一个对象的作用域中调用
var o = new Object();
Person.call(o, "Kristen", 25, "Nurse");
o.sayName(); //"Kristen"
```

#### 构造函数的问题

使用构造函数的主要问题，就是每个方法都要在每个实例上重新创建一遍。

例子中，`person1` 和 `person2` 都有一个名为 `sayName()` 的方法，但那两个方法不是同一个 Function 的实例。 这样不同实例上的同名函数是不相等的.

``` js
alert(person1.sayName == person2.sayName);  //false
```

通过把函数定义转移到构造函数外部来解决这个问题:

``` js
function Person(name, age, job){
    this.name = name;
    this.age = age;
    this.job = job;
    this.sayName = sayName;
}

function sayName(){
    alert(this.name);
}

var person1 = new Person("Nicholas", 29, "Software Engineer");
var person2 = new Person("Greg", 27, "Doctor");
```

但是这样的话, 在外部定义的方法就成了全局函数, 自定义的引用类型丝毫没有封装性. 这些问题可以通过使用原型模式来解决。

### 原型模式

创建的每个函数都有一个 `prototype`（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。

按照字面意思来理解，那么 `prototype` 就是通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。

但是一般来说开发中我们希望每个实例都有自己的实例属性副本, 但是有共享的方法. 所以开发中一般把属性放在构造函数, 把共享的属性和方法放在原型对象中.

``` js
function Person(name, age, job){
    this.name = name;
    this.age = age;
    this.job = job;
    this.friends = ["Shelby", "Court"];
}

Person.prototype.sayName = function() {
    alert(this.name);
}


var person1 = new Person("Nicholas", 29, "Software Engineer");
var person2 = new Person("Greg", 27, "Doctor");

person1.friends.push("Van");
alert(person1.friends);    //"Shelby,Count,Van"
alert(person2.friends);    //"Shelby,Count"
alert(person1.friends === person2.friends);    //false
alert(person1.sayName === person2.sayName);    //true
```

#### 理解原型对象

原型对象默认有一个 `constructor`（构造函数）属性，这个属性是一个指向 `prototype` 属性所在函数的指针. 

当调用构造函数创建一个新实例后，该实例的内部将包含一个指针 `[[Prototype]]`（内部属性），指向构造函数的原型对象。在很多浏览器上, 对象中的 `__proto__` 属性指向原型对象,  注意这个连接存在于实例与构造函数的原型对象之间，而不是存在于实例与构造函数之间。

![09.d06z.01](https://i.imgur.com/vXPA5Ds.png)

可以通过 `isPrototypeOf()` 方法来确定对象之间是否存在原型与实例的关系. 从本质上讲，如果实例对象的 `[[Prototype]]` 指向调用 `isPrototypeOf()` 方法的对象，那么这个方法就返回 `true`

`Object.getPrototypeOf()` 可以返回 `[[Prototype]]` 指向的原型对象.

#### 对象字面量重写原型对象

可以用一个包含所有属性和方法的对象字面量来重写整个原型对象

``` js
function Person(){
}

Person.prototype = {
    name : "Nicholas",
    age : 29,
    job: "Software Engineer",
    sayName : function () {
        alert(this.name);
    }
};
```

前面说 原型对象的 `constructor` 属性指向原型对象所在构造函数. 使用对象字面量重写原型对象, `constructor` 属性也就被改写了.

可以手动设置 `constructor` 属性的值.

``` js
function Person(){
}

Person.prototype = {
    constructor : Person,
    name : "Nicholas",
    age : 29,
    job: "Software Engineer",
    sayName : function () {
        alert(this.name);
    }
};
```

注意，以这种方式重设 `constructor` 属性会导致它的 `[[Enumerable]]` 特性被设置为 `true`。默认情况下，原生的 `constructor` 属性是不可枚举的

这时可以用 `Object.defineProperty()` 方法来设置 `constructor`

``` js
Object.defineProperty(Person.prototype, "constructor", {
    enumerable: false,
    value: Person
});
```

#### 检测属性存在位置

使用 `hasOwnProperty()` 方法可以检测一个属性是存在于实例中，还是存在于原型中。只在给定属性存在于对象实例中时，才会返回 `true`。

``` js
function Person(){
}

Person.prototype.name = "Nicholas";
Person.prototype.age = 29;
Person.prototype.job = "Software Engineer";
Person.prototype.sayName = function(){
    alert(this.name);
};

var person1 = new Person();
var person2 = new Person();

alert(person1.hasOwnProperty("name"));  //false

person1.name = "Greg";
alert(person1.name);     //"Greg"——来自实例
alert(person1.hasOwnProperty("name"));  //true

alert(person2.name);     //"Nicholas"——来自原型
alert(person2.hasOwnProperty("name"));  //false

delete person1.name;
alert(person1.name);     //"Nicholas"——来自原型
alert(person1.hasOwnProperty("name"));  //false
```

可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值。如果我们在实例中添加了一个属性，而该属性与实例原型中的一个属性同名，那我们就在实例中创建该属性，该属性将会屏蔽原型中的那个属性。

#### 把原型对象封装在构造函数中

在构造函数外定义原型对象, 可能还是缺乏封装性. 可以改成通过在构造函数中初始化原型. 在初次调用构造函数的时候初始化原型.

``` js
function Person(name, age, job){

    //属性
    this.name = name;
    this.age = age;
    this.job = job;

    //方法
    if (typeof this.sayName != "function"){
        Person.prototype.sayName = function(){
            alert(this.name);
        };
    }
}

var friend = new Person("Nicholas", 29, "Software Engineer");
friend.sayName();
```

上面例子中, 只在 `sayName()` 方法不存在的情况下，才会将它添加到原型中。这段代码只会在初次调用构造函数时才会执行。此后，原型已经完成初始化

## 继承