# 基本概念

## 基础知识

### 区分大小写

ECMAScript中的一切（变量、函数名和操作符）都区分大小写。

### 标识符

标识符，就是指变量、函数、属性的名字，或者函数的参数。

命名规则: 
* 第一个字符必须是一个字母、下划线（_）或一个美元符号（$）；
* 其他字符可以是字母、下划线、美元符号或数字。

### 注释

单行注释以两个斜杠开头
``` js
// 单行注释
```

多行注释以一个斜杠和一个星号（/*）开头，以一个星号和一个斜杠（*/）结尾, 中间的星号不是必须的
```js
/*
 *  这是一个多行
 *  （块级）注释
 */
```

### 严格模式

严格模式是为JavaScript定义了一种不同的解析与执行模型。在严格模式下，一些不确定的行为将得到处理，而且对某些不安全的操作也会抛出错误。

要在作用域中启用严格模式，可以在顶部添加如下代码：

``` js
// 在全局
"use strict";

// 函数作用域
function doSomething(){
    "use strict"; 
}
```

这条不是字符串, 它是一个编译指示（pragma），用于告诉支持它的 JavaScript 引擎切换到严格模式。

### 语句

语句以一个分号 ";" 结尾；如果省略分号，则由解析器确定语句的结尾.

虽然可以省略分号, 但是有分号可以避免错误, 压缩语句之间多余的空格. 解析器也不用去判断哪里是语句的结尾了, 可以增加性能

多条语句可以组合到一个代码块中, 代码块以左花括号（{）开头，以右花括号（}）结尾：

## 关键字和保留字 

[关键字和保留字列表](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Lexical_grammar#%E5%85%B3%E9%94%AE%E5%AD%97)

关键字 是可用于表示控制语句的开始或结束，或者用于执行特定操作等,
保留字 是将来可能成为关键字的,

它们都不可以用作标识符.

## 变量 

ECMAScript的变量是松散类型的，松散类型可以用来保存任何类型的数据。

换句话说，每个变量仅仅是一个用于保存值的占位符而已。

变量在离开作用域后就会被销毁

定义变量时要使用 `var` 操作符, 后跟变量名（即一个标识符）:

``` js
var x = 123;
```

不用 `var` 操作符, 即使在函数内定义变量, 也会变成全局变量 

## 数据类型 

ECMAScript中有 5 种简单数据类型（也称为基本数据类型）：`Undefined`、`Null`、`Boolean`、`Number` 和 `String`。还有 1 种引用数据类型 `Object`

### typeof 操作符

[typeof 文档](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof)

`typeof` 用于检测数据类型

对一个值使用 typeof 可以返回一个字符串表示其数据类型, 具体信息请查阅文档

调用 `typeof null` 会返回 "object"，因为特殊值 `null` 被认为是一个空的对象引用。

### Undefined 类型

Undefined 类型只有一个值，即特殊的 `undefined`。在使用 `var` 声明变量但未对其加以初始化时，这个变量的值就是 `undefined`

这个值最初引入的原因是为了正式区分空对象指针与未经初始化的变量。

### Null 类型

`null` 值表示一个空对象指针, 如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为 `null` 而不是其他值

### Boolean 类型

该类型只有两个字面值：`true` 和 `false`。

虽然 Boolean 类型的字面值只有两个，但 ECMAScript 中所有类型的值都有与这两个 Boolean 值等价的值。要将一个值转换为其对应的 Boolean 值，可以调用转型函数 `Boolean()`

如果省略该参数，或者其值为 `0`、`-0`、`null`、`false`、`NaN`、`undefined`、或者空字符串（`""`），则生成的 Boolean 对象的值为 false。如果传入的参数是 DOM 对象 `document.all`，也会生成值为 `false` 的 Boolean 对象。任何其他的值，包括值为 "false" 的字符串和任何对象，都会创建一个值为 `true` 的 Boolean 对象。

### Number 类型

使用 IEEE754 格式来表示整数和浮点数值, 支持 十进制, 八进制, 十六进制数值字面量格式

八进制字面值 的第一位必须是零（0），然后是八进制数字序列（0～7）。如果字面值中的数值超出了范围，那么前导零将被忽略，后面的数值将被当作十进制数值解析。(严格模式下无效)
十六进制字面值 的前两位必须是 `0x`，后跟任何十六进制数字（0～9及A～F）。其中，字母A～F可以大写，也可以小写。

在进行算术计算时，所有值都会被转换成十进制数值。

#### 浮点数值

浮点数值，就是该数值中必须包含一个小数点，并且小数点后面必须至少有一位数字。

保存浮点数值需要的内存空间是保存整数值的两倍.

浮点数值的最高精度是17位小数, 进行算术计算时其精确度远远不如整数.

0.1 加 0.2 的结果不是 0.3，而是 0.30000000000000004。这个小小的舍入误差会导致无法测试特定的浮点数值。

#### 数值范围

JS 能够表示的最小数值保存在 `Number.MIN_VALUE` 中, 一般为 `5e-324`,
最大数值保存在 `Number.MAX_VALUE`, 一般为 `1.7976931348623157e+308`.

如果超过这个值了, 这个数值将被自动转换成特殊的 `Infinity` 值, 
如果这个数值是负数，则会被转换成 `-Infinity`（负无穷），如果这个数值是正数，则会被转换成 `Infinity`（正无穷),

要想确定一个数值是不是有穷的, 可以使用 `isFinite()` 函数。是的话返回 `true`

#### NaN

`NaN`，即非数值（Not a Number）是一个特殊的数值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况

任何数值除以非数值会返回 `NaN`, `NaN` 与任何值都不相等，包括 `NaN` 本身

`isNaN()` 函数可以检测是否值可以被转换成数值, 任何不能被转换为数值的值都会导致这个函数返回 `true`

#### 数值转换

`Number()`、`parseInt()` 和 `parseFloat()`可以把非数值转换为数值, 转型函数 `Number()` 可以用于任何数据类型，而另两个函数则专门用于把字符串转换成数值。

`Number()` 函数的转换规则如下。

* 如果是`Boolean`值，`true`和`false`将分别被转换为 1 和 0。
* 如果是数字值，只是简单的传入和返回。
* 如果是`null`值，返回 0。
* 如果是`undefined`，返回`NaN`。
* 如果是 字符串，遵循下列规则：
  * 如果字符串中只包含 **数字**（包括前面带加号或负号的情况），则将其转换为**十进制数值**。
  * 如果字符串中包含有效的 **浮点格式**，如 "1.1"，则将其转换为**对应的浮点数值**。
  * 如果字符串中包含有效的 **十六进制** 格式，例如"0xf"，则将其转换为相同大小的 **十进制整数值**
  * 如果是`0`开头的数字，是按照**十进制转换**
  * 如果字符串是 **空的**（不包含任何字符），则将其转换为 **0**
  * 如果字符串中包含除上述**格式之外**的字符，则将其转换为 `NaN`。
* 如果是对象，则调用对象的`valueOf()`方法，然后依照前面的规则转换返回的值。如果转换的结果是`NaN`，则调用对象的`toString()`方法，然后再次依照前面的规则转换返回的字符串值。

在处理 **整数** 的时候更常用的是`parseInt()`函数。

`parseInt()` 函数在转换字符串时，会忽略字符串前面的空格，直至找到第一个非空格字符。如果是数字字符`parseInt()`会继续解析第二个字符，直到解析完所有后续字符或者遇到了一个非数字字符。

如果第一个字符不是 数字字符 或者 正负号，`parseInt()`就会返回`NaN`；

如果字符串以 "0x" 开头且后跟数字字符，就会将其当作一个 十六进制整数；如果字符串以 "0" 开头且后跟数字字符，则还是十进制。

函数提供 第二个参数：转换时使用的 **基数**（即多少进制）

```js
var num = parseInt("0xAF", 16);         //175
var num1 = parseInt("AF", 16);          //175
var num2 = parseInt("AF");              //NaN
```

`parseFloat()` 也从第一个字符（位置0）开始解析每个字符。而且也是一直解析到字符串末尾，或者解析到遇见一个无效的浮点数字字符为止。

也就是说，字符串中的 第一个小数点 是有效的，而 第二个小数点 就是无效的了。

`parseFloat()`**只解析十进制值**，因此它没有用第二个参数指定基数的用法。十六进制格式的字符串则始终会被转换成0。

### String 类型

### Object 类型
