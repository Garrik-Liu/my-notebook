# 基本概念

## 基础知识

### 区分大小写

ECMAScript中的一切（变量、函数名和操作符）都区分大小写。

### 标识符

标识符，就是指变量、函数、属性的名字，或者函数的参数。

命名规则: 
* 第一个字符必须是一个字母、下划线（_）或一个美元符号（$）；
* 其他字符可以是字母、下划线、美元符号或数字。

### 注释

单行注释以两个斜杠开头
``` js
// 单行注释
```

多行注释以一个斜杠和一个星号（/*）开头，以一个星号和一个斜杠（*/）结尾, 中间的星号不是必须的
```js
/*
 *  这是一个多行
 *  （块级）注释
 */
```

### 严格模式

严格模式是为JavaScript定义了一种不同的解析与执行模型。在严格模式下，一些不确定的行为将得到处理，而且对某些不安全的操作也会抛出错误。

要在作用域中启用严格模式，可以在顶部添加如下代码：

``` js
// 在全局
"use strict";

// 函数作用域
function doSomething(){
    "use strict"; 
}
```

这条不是字符串, 它是一个编译指示（pragma），用于告诉支持它的 JavaScript 引擎切换到严格模式。

### 语句

语句以一个分号 ";" 结尾；如果省略分号，则由解析器确定语句的结尾.

虽然可以省略分号, 但是有分号可以避免错误, 压缩语句之间多余的空格. 解析器也不用去判断哪里是语句的结尾了, 可以增加性能

多条语句可以组合到一个代码块中, 代码块以左花括号（{）开头，以右花括号（}）结尾：

## 关键字和保留字 

[关键字和保留字列表](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Lexical_grammar#%E5%85%B3%E9%94%AE%E5%AD%97)

关键字 是可用于表示控制语句的开始或结束，或者用于执行特定操作等,
保留字 是将来可能成为关键字的,

它们都不可以用作标识符.

## 变量 

ECMAScript的变量是松散类型的，松散类型可以用来保存任何类型的数据。

换句话说，每个变量仅仅是一个用于保存值的占位符而已。

变量在离开作用域后就会被销毁

定义变量时要使用 `var` 操作符, 后跟变量名（即一个标识符）:

``` js
var x = 123;
```

不用 `var` 操作符, 即使在函数内定义变量, 也会变成全局变量 

## 数据类型 

ECMAScript中有 5 种简单数据类型（也称为基本数据类型）：`Undefined`、`Null`、`Boolean`、`Number` 和 `String`。还有 1 种引用数据类型 `Object`

### typeof 操作符

[typeof 文档](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof)

`typeof` 用于检测数据类型

对一个值使用 typeof 可以返回一个字符串表示其数据类型, 具体信息请查阅文档

调用 `typeof null` 会返回 "object"，因为特殊值 `null` 被认为是一个空的对象引用。

### Undefined 类型

Undefined 类型只有一个值，即特殊的 `undefined`。在使用 `var` 声明变量但未对其加以初始化时，这个变量的值就是 `undefined`

这个值最初引入的原因是为了正式区分空对象指针与未经初始化的变量。

### Null 类型

`null` 值表示一个空对象指针, 如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为 `null` 而不是其他值

### Boolean 类型

该类型只有两个字面值：`true` 和 `false`。

虽然 Boolean 类型的字面值只有两个，但 ECMAScript 中所有类型的值都有与这两个 Boolean 值等价的值。要将一个值转换为其对应的 Boolean 值，可以调用转型函数 `Boolean()`

如果省略该参数，或者其值为 `0`、`-0`、`null`、`false`、`NaN`、`undefined`、或者空字符串（`""`），则生成的 Boolean 对象的值为 false。如果传入的参数是 DOM 对象 `document.all`，也会生成值为 `false` 的 Boolean 对象。任何其他的值，包括值为 "false" 的字符串和任何对象，都会创建一个值为 `true` 的 Boolean 对象。

### Number 类型

使用 IEEE754 格式来表示整数和浮点数值, 支持 十进制, 八进制, 十六进制数值字面量格式

八进制字面值 的第一位必须是零（0），然后是八进制数字序列（0～7）。如果字面值中的数值超出了范围，那么前导零将被忽略，后面的数值将被当作十进制数值解析。(严格模式下无效)
十六进制字面值 的前两位必须是 `0x`，后跟任何十六进制数字（0～9及A～F）。其中，字母A～F可以大写，也可以小写。

在进行算术计算时，所有值都会被转换成十进制数值。

#### 浮点数值

浮点数值，就是该数值中必须包含一个小数点，并且小数点后面必须至少有一位数字。

保存浮点数值需要的内存空间是保存整数值的两倍.

浮点数值的最高精度是17位小数, 进行算术计算时其精确度远远不如整数.

0.1 加 0.2 的结果不是 0.3，而是 0.30000000000000004。这个小小的舍入误差会导致无法测试特定的浮点数值。

#### 数值范围

JS 能够表示的最小数值保存在 `Number.MIN_VALUE` 中, 一般为 `5e-324`,
最大数值保存在 `Number.MAX_VALUE`, 一般为 `1.7976931348623157e+308`.

如果超过这个值了, 这个数值将被自动转换成特殊的 `Infinity` 值, 
如果这个数值是负数，则会被转换成 `-Infinity`（负无穷），如果这个数值是正数，则会被转换成 `Infinity`（正无穷),

要想确定一个数值是不是有穷的, 可以使用 `isFinite()` 函数。是的话返回 `true`

#### NaN

`NaN`，即非数值（Not a Number）是一个特殊的数值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况

任何数值除以非数值会返回 `NaN`, `NaN` 与任何值都不相等，包括 `NaN` 本身

`isNaN()` 函数可以检测是否值可以被转换成数值, 任何不能被转换为数值的值都会导致这个函数返回 `true`

#### 数值转换

`Number()`、`parseInt()` 和 `parseFloat()`可以把非数值转换为数值, 转型函数 `Number()` 可以用于任何数据类型，而另两个函数则专门用于把字符串转换成数值。

`Number()` 函数的转换规则如下。

* 如果是`Boolean`值，`true`和`false`将分别被转换为 1 和 0。
* 如果是数字值，只是简单的传入和返回。
* 如果是`null`值，返回 0。
* 如果是`undefined`，返回`NaN`。
* 如果是 字符串，遵循下列规则：
  * 如果字符串中只包含 **数字**（包括前面带加号或负号的情况），则将其转换为**十进制数值**。
  * 如果字符串中包含有效的 **浮点格式**，如 "1.1"，则将其转换为**对应的浮点数值**。
  * 如果字符串中包含有效的 **十六进制** 格式，例如"0xf"，则将其转换为相同大小的 **十进制整数值**
  * 如果是`0`开头的数字，是按照**十进制转换**
  * 如果字符串是 **空的**（不包含任何字符），则将其转换为 **0**
  * 如果字符串中包含除上述**格式之外**的字符，则将其转换为 `NaN`。
* 如果是对象，则调用对象的`valueOf()`方法，然后依照前面的规则转换返回的值。如果转换的结果是`NaN`，则调用对象的`toString()`方法，然后再次依照前面的规则转换返回的字符串值。

在处理 **整数** 的时候更常用的是`parseInt()`函数。

`parseInt()` 函数在转换字符串时，会忽略字符串前面的空格，直至找到第一个非空格字符。如果是数字字符`parseInt()`会继续解析第二个字符，直到解析完所有后续字符或者遇到了一个非数字字符。

如果第一个字符不是 数字字符 或者 正负号，`parseInt()`就会返回`NaN`；

如果字符串以 "0x" 开头且后跟数字字符，就会将其当作一个 十六进制整数；如果字符串以 "0" 开头且后跟数字字符，则还是十进制。

函数提供 第二个参数：转换时使用的 **基数**（即多少进制）

```js
var num = parseInt("0xAF", 16);         //175
var num1 = parseInt("AF", 16);          //175
var num2 = parseInt("AF");              //NaN
```

`parseFloat()` 也从第一个字符（位置0）开始解析每个字符。而且也是一直解析到字符串末尾，或者解析到遇见一个无效的浮点数字字符为止。

也就是说，字符串中的 第一个小数点 是有效的，而 第二个小数点 就是无效的了。

`parseFloat()`**只解析十进制值**，因此它没有用第二个参数指定基数的用法。十六进制格式的字符串则始终会被转换成0。

### String 类型

`String` 类型用于表示由零或多个 16位Unicode字符 组成的字符序列，即字符串, 由双引号（"）或单引号（'）起始或者结束. 以双引号开头的字符串也必须以双引号结尾，而以单引号开头的字符串必须以单引号结尾。

``` js
var firstName = "Nicholas";
var lastName = 'Zakas';
```

#### 字符字面量

String 数据类型包含一些特殊的字符字面量，也叫转义序列，用于表示非打印字符，或者具有其他特殊字符。使用反斜杠 ("\") 来向文本字符串添加

``` js
// 下面的会报错, 因为 双引号用于字符串起始和结束
console.log("We are the so-called "Vikings" from the north.")

// 用反斜杠可以把 双引号 转义字面上的字符串

console.log("We are the so-called \"Vikings\" from the north.")
```

#### 字符串的特点

ECMAScript 中的字符串是不可变的，也就是说，字符串一旦创建，它们的值就不能改变。要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量

``` js
var lang = "Java";
lang = lang + "Script";
```

上例中, 首先创建一个能容纳10个字符的新字符串，然后在这个字符串中填充"Java"和"Script"，最后一步是销毁原来的字符串"Java"和字符串"Script"

#### 转换为字符串

把一个值转换为一个字符串有两种方式。

第一种是使用几乎每个值都有的 `toString()` 方法. 这个方法返回相应值的字符串表现

``` js
var age = 11;
var ageAsString = age.toString();         // 字符串"11"
```

数值、布尔值、对象 和 字符串值都有 `toString()` 方法。但 `null` 和 `undefined` 值没有这个方法。
(思考: 为什么简单数据类型会有方法?)

通过传递基数，`toString()` 可以输出以二进制、八进制、十六进制，乃至其他任意有效进制格式表示的字符串值

第二种是使用转型函数 `String()`, 在不知道要转换的值是不是null或undefined的情况下, 这个函数能够将任何类型的值转换为字符串.

`String()` 函数遵循下列转换规则：
* 如果值有 `toString()` 方法，则调用该方法（没有参数）并返回相应的结果；
* 如果值是 `null`，则返回 "null"；
* 如果值是 `undefined`，则返回 "undefined"。


### Object 类型

[文档](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object)

ECMAScript 中的对象其实就是**一组数据和功能的无序集合**。对象可以通过执行 `new` 操作符后跟要创建的对象类型的名称来创建。而创建 Object 类型的实例并为其添加属性和（或）方法，就可以创建自定义对象

在ECMAScript中，如果不给构造函数传递参数，则可以省略后面的那一对圆括号, 但不推荐

``` js
var x = new Object();
var y = new Object;
```

`Object` 类型所具有的任何属性和方法也同样存在于继承自它的对象中。`Object` 类型是所有其他对象的基础。

## 操作符 

### 一元操作符

只能操作一个值的操作符叫做一元操作符

**递增和递减操作符**：`++`，`--`

* 前置型：位于要操作的变量之前，变量的值都是在语句被求值以前改变的。

``` js
var age = 29;
var anotherAge = --age + 2;

alert(age);             // 输出28
alert(anotherAge);      // 输出30
```

* 后置型：放在变量的后面，包含它们的语句，变量的值被求值之后才执行的

``` js
var num1 = 2;
var num2 = 20;
var num3 = num1-- + num2;       // 等于22
var num4 = num1 + num2;         // 等于21
```

递增和递减操作符操作符对**任何值都适用**：整数，字符串、布尔值、浮点数值和对象。

递增和递减操作符遵循下列规则：
* 在应用于一个包含**有效数字字符的字符串**时，先将其转换为数字值，再执行加减1的操作。字符串变量变成数值变量。

* 在应用于一个**无效数字字符的字符串**时，将变量的值设置为NaN。字符串变量变成数值变量。

* 在应用于**布尔值`false`** 时，先将其转换为0再执行加减1的操作。布尔值变量变成数值变量。

* 在应用于**布尔值`true`** 时，先将其转换为1再执行加减1的操作。布尔值变量变成数值变量。

* 在应用于**浮点数值**时，执行加减1的操作。

* 在应用于**对象**时，先调用对象的`valueOf()`方法以取得一个可供操作的值。然后对该值应用前述规则。如果结果是NaN，则在调用`toString()`方法后再应用前述规则。对象变量变成数值变量。

* `undefined` 和 `NaN` 都是 `NaN`

**一元加和减操作符**：`+`，`-`

**一元加操作符** 以一个加号（+）表示，放在数值前面，对数值不会产生任何影响。在对非数值应用一元加操作符时，该操作符会像`Number()`转型函数一样对这个值执行转换。

**一元减操作符** 主要用于表示负数，例如将1转换成-1。当应用于非数值时，一元减操作符遵循与一元加操作符相同的规则，最后再将得到的数值转换为负数。

### 位操作符

位操作符用于在最基本的层次上，即按内存中表示数值的位来操作数值。

中的所有数值都以**IEEE-754 64位格式**存储，

但位操作符并不直接操作64位的值。而是**先将64位的值转换成32位的整数**，然后执行操作，最后再将**结果转换回64位**。

对于有符号的整数，32位中的前31位用于表示整数的值。第32位用于表示数值的符号：0表示正数，1表示负数。（从后往前数，第一位叫**位0**）。

数值18的二进制表示`00000000000000000000000000010010`，或者更简洁的`10010`。这是5个**有效位**，这5位本身就决定了实际的值。

**负数**同样以二进制码存储，但使用的格式是**二进制补码**。

计算一个数值的二进制补码，需要经过下列3个步骤：
1. 求这个数值**绝对值**的二进制码（例如，要求-18的二进制补码，先求18的二进制码）；

2. 求二进制反码，即将0替换为1，将1替换为0；

3. 得到的二进制反码加1。

在对特殊的`NaN`和`Infinity`值应用位操作时，这两个值都会被当成0来处理。

如果对**非数值**应用位操作符，会先使用`Number()`函数将该值转换为一个数值（自动完成），然后再应用位操作。

**按位非（NOT）**：`~`
执行按位非的结果就是返回数值的反码。

**按位与（AND）**：`&`
它有两个操作符数。从本质上讲，按位与操作就是将两个数值的每一位对齐，对相同位置上的两个数执行 AND 操作。

**按位或（OR）**：`|`
同样也有两个操作数。按位与操作就是将两个数值的每一位对齐，对相同位置上的两个数执行 OR 操作。

**按位异或（XOR）**：`^`
两个操作数执行 XOR 操作。

**左移**：`<<`
将数值的所有位向左移动指定的位数。

**有符号的右移**：`>>`
个操作符会将数值向右移动，但保留符号位（即正负号标记）。

**无符号右移**：`>>>` (不懂)
这个操作符会将数值的所有32位都向右移动。

### 布尔操作符
用于测试两个值的关系

**逻辑非**：`!`
无论这个值是什么数据类型，这个操作符都会返回一个布尔值。逻辑非操作符首先会将它的操作数转换为一个布尔值，然后再对其求反。

**逻辑与**：`&&`
逻辑与操作可以应用于任何类型的操作数，而不仅仅是布尔值。

在有一个操作数不是布尔值的情况下，逻辑与操作就不一定返回布尔值；此时，它遵循下列规则：
* 如果第一个操作数是对象，则返回第二个操作数；

* 如果第二个操作数是对象，则只有在第一个操作数的求值结果为`true`的情况下才会返回该对象；
* 如果两个操作数都是对象，则返回第二个操作数；

* 如果第一个操作数是`null`，则返回`null`；

* 如果第一个操作数是`NaN`，则返回`NaN`；

* 如果第一个操作数是`undefined`，则返回`undefined`。

逻辑与操作属于**短路操作**，即**如果第一个操作数能够决定结果，那么就不会再对第二个操作数求值**。

**逻辑或**：`||`
与逻辑与操作相似，如果有一个操作数不是布尔值，逻辑或也不一定返回布尔值；此时，它遵循下列规则：

* 如果第一个操作数是对象，则返回第一个操作数；

* 如果第一个操作数的求值结果为`false`，则返回第二个操作数；

* 如果两个操作数都是对象，则返回第一个操作数；

* 如果两个操作数都是`null`，则返回`null`；

* 如果两个操作数都是`NaN`，则返回`NaN`；

* 如果两个操作数都是`undefined`，则返回`undefined`。

辑或操作符也是短路操作符。也就是说，如果第一个操作数的求值结果为true，就不会对第二个操作数求值了。

### 乘性操作符:

3个乘性操作符：乘法、除法 和 求模。

如果参与乘性计算的某个操作数不是数值，后台会先使用`Number()`转型函数将其转换为数值。

**乘法**: `*`
用于计算两个数值的乘积。

在处理特殊值的情况下，乘法操作符遵循下列特殊的规则：

- 如果操作数都是数值，执行常规的乘法计算。如果乘积超过了ECMAScript数值的表示范围，则返回Infinity或-Infinity；

- 如果有一个操作数是`NaN`，则结果是`NaN`；

- 如果是`Infinity`与`0`相乘，则结果是`NaN`；

- 如果是`Infinity`与 非`0`数值相乘，则结果是`Infinity`或`-Infinity`，取决于有符号操作数的符号；

- 如果是`Infinity`与`Infinity`相乘，则结果是`Infinity`；

- 如果有一个操作数不是数值，则在后台调用`Number()`将其转换为数值，然后再应用上面的

**除法**：`/`
* 如果操作数都是数值，执行常规的除法计算。如果商超过了ECMAScript数值的表示范围，则返回Infinity或-Infinity；

* 如果有一个操作数是NaN，则结果是NaN；

* 如果是`Infinity`被`Infinity`除，则结果是`NaN`；

* 如果是`0`被`0`除，则结果是`NaN`；

* 如果是非`0`的有限数被`0`除，则结果是`Infinity`或`-Infinity`，取决于有符号操作数的符号；

* 如果是`Infinity`被任何非零数值除，则结果是`Infinity`或`-Infinity`，取决于有符号操作数的符号；

* 如果有一个操作数不是数值，则在后台调用`Number()`将其转换为数值，然后再应用上面的规则。

**求模**: `%`
* 如果操作数都是数值，执行常规的除法计算，返回除得的余数；

* 如果被除数是`Infinity`值而除数是有限大的数值，则结果是`NaN`；

* 如果被除数是有限大的数值而除数是`0`，则结果是`NaN`；

* 如果是`Infinity`被`Infinity`除，则结果是`NaN`；

* 如果被除数是有限大的数值而除数是Infinity，则结果是被除数；

* 如果被除数是`0`，则结果是`0`；

* 如果有一个操作数不是数值，则在后台调用`Number()`将其转换为数值，然后再应用上面的规则。

### 加性操作符：`+`

**加法**:
如果两个操作符都是数值，执行常规的加法计算，然后根据下列规则返回结果：
* 如果有一个操作数是NaN，则结果是NaN；

* 如果是Infinity加Infinity，则结果是Infinity；

* 如果是-Infinity加-Infinity，则结果是-Infinity；

* 如果是Infinity加-Infinity，则结果是NaN；

* 如果是+0加+0，则结果是+0；

* 如果是-0加-0，则结果是-0；

* 如果是+0加-0，则结果是+0。

如果有一个操作数是字符串，那么就要应用如下规则：
* 如果两个操作数都是字符串，则将第二个操作数与第一个操作数拼接起来；

* 如果只有一个操作数是字符串，则将另一个操作数转换为字符串，然后再将两个字符串拼接 起来。

如果有一个操作数是对象、数值或布尔值，则调用它们的`toString()`方法取得相应的字符串值，然后再应用前面关于字符串的规则。对于`undefined`和`null`，则分别调用`String()`函数并取得字符串"undefined"和"null"

### 减性操作符：`-`
如果两个操作符都是数值，则执行常规的算术减法操作并返回结果；

* 如果有一个操作数是NaN，则结果是NaN；

* 如果是Infinity减Infinity，则结果是NaN；

* 如果是-Infinity减-Infinity，则结果是NaN；

* 如果是Infinity减-Infinity，则结果是Infinity；

* 如果是-Infinity减Infinity，则结果是-Infinity；

* 如果是+0减+0，则结果是+0；

* 如果是+0减-0，则结果是-0；

* 如果是-0减+0，则结果是+0；

如果有一个操作数是字符串、布尔值、`null`或`undefined`，则先在后台调用`Number()`函数将其转换为数值，然后再根据前面的规则执行减法计算。如果转换的结果是`NaN`，则减法的结果就是`NaN`；

如果有一个操作数是对象，则调用对象的`valueOf()`方法以取得表示该对象的数值。如果得到的值是`NaN`，则减法的结果就是`NaN`。如果对象没有`valueOf()`方法，则调用其`toString()`方法并将得到的字符串转换为数值。

### 关系操作符:`<`,`>`,`<=`,`>=`

当关系操作符的操作数使用了非数值时，也要进行数据转换或完成某些奇怪的操作:
* 如果两个操作数都是数值，则执行数值比较。

* 如果两个操作数都是字符串，则比较两个字符串对应的**字符编码值**。

* 如果一个操作数是数值，则将另一个操作数转换为一个数值，然后执行数值比较。

* 如果一个操作数是对象，则调用这个对象的`valueOf()`方法，用得到的结果按照前面的规则执行比较。如果对象没有`valueOf()`方法，则调用`toString()`方法，并用得到的结果根据前面的规则执行比较。

* 如果一个操作数是布尔值，则先将其转换为数值，然后再执行比较。

在比较字符串值时，并不按照字母表中的位置。
在比较字符串时，实际比较的是两个字符串中对应位置的每个字符的字符编码值。

另一种奇怪的现象发生在比较两个数字字符串的情况下：

``` js
var result = "23" < "3";    //true
```

"2"的字符编码是50，而"3"的字符编码是51

``` js
var result = "a" < 3;    // false，因为"a"被转换成了NaN
```

由于字母"a"不能转换成合理的数值，因此就被转换成了NaN。

### 相等操作符：

**相等和不相等**：`==`
如果两个操作数相等，则返回true。而不相等操作符由叹号后跟等于号（`!=`）表示，如果两个操作数不相等，则返回true。

这两个操作符都会先转换操作数（通常称为**强制转型**），然后再比较它们的相等性。

相等和不相等操作符遵循下列基本规则：
* 如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值；

* 如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值；

* 如果一个操作数是对象，另一个操作数不是，则调用对象的valueOf()方法，用得到的基本类型值按照前面的规则进行比较；

这两个操作符在进行比较时则要遵循下列规则:
* null和undefined是相等的。

* 要比较相等性之前，不能将null和undefined转换成其他任何值。

* 如果有一个操作数是NaN，则相等操作符返回false，而不相等操作符返回true。重要提示：即使两个操作数都是NaN，相等操作符也返回false；因为按照规则，NaN不等于NaN。

* 如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回true；否则，返回false。

**全等和不全等**：`===`
它只在两个操作数未经转换就相等的情况下返回true


### 赋值操作符：`=`
其作用就是把右侧的值赋给左侧的变量

如果在等于号（=）前面再添加乘性操作符、加性操作符或位操作符，就可以完成复合赋值操作。（`*=`，`/=`，等）

设计这些操作符的主要目的就是简化赋值操作。使用它们不会带来任何性能的提升。

### 逗号操作符：`,`
使用逗号操作符可以在一条语句中执行多个操作

``` js
var num1 = 1, num2 = 2, num3 = 3;
```
在用于赋值时，逗号操作符总会返回表达式中的最后一项，如下面的例子所示：

``` js
var num = (5, 1, 4, 8, 0); // num的值为0
// 没括号报错
```

## 流控制语句

### if

``` js
if (condition) {
    statement1
} else {
    statement2
}
```

无论`condition`写什么，JS会自动调用`Boolean()`转换函数将这个表达式的结果转换为一个布尔值。

如果`condition`求值的结果是`true`，则执行`statement1`（语句1），否则执行`statement2`（语句2）。

### do-while

``` js
do {
    statement
} while (expression);
```

一种后测试循环语句。

在对条件表达式求值之前，循环体内的代码至少会被执行一次。

### while 语句

前测试循环语句

``` js
while(expression) statement
```

满足条件表达式，才会执行循环体。

### for 语句

``` js
for (initialization; expression; post-loop-expression) {
    statement
}
```

前测试循环语句

具有在 **执行循环之前初始化变量** 和定义 **循环后要执行的代码** 的能力。

只给出控制表达式实际上就把for循环转换成了while循环

``` js
var count = 10;
var i = 0;
for (; i < count; ){
    alert(i);
    i++;
}
```

### for-in语句

`for-in` 语句是一种精准的**迭代语句**，可以用来**枚举对象的属性**。

``` js
for (property in expression) statement
```

JS对象的属性没有顺序。因此，通过for-in循环输出的属性名的顺序是不可预测的。

如果表示要迭代的对象的值为`null`或`undefined`，`for-in`语句会不执行循环体。

### label语句

使用 `label` 语句可以在代码中添加标签，以便将来使用。

``` js
label: statement
```

实例：

``` js
start: for (var i=0; i < count; i++) {
    alert(i); 
}
```

`start`标签可以在将来由`break`或`continue`语句引用，加标签的语句一般都要与 `for` 语句等循环语句配合使用。

### break 和 continue语句

`break`语句会立即退出循环，强制继续执行循环后面的语句。
`continue`语句虽然也是立即退出循环，但退出循环后会从循环的顶部继续执行。

``` js
var num = 0;

outermost:
for (var i=0; i < 10; i++) {
     for (var j=0; j < 10; j++) {
        if (i == 5 && j == 5) {
            break outermost;
        }
        num++;
    }
}

alert(num);    //55
```

### with语句

`with`语句的作用是将代码的**作用域**设置到一个特定的对象中。

定义`with`语句的目的主要是为了简化多次编写同一个对象的工作

``` js
var qs = location.search.substring(1);
var hostName = location.hostname;
var url = location.href;
```

如果使用`with`语句，可以把上面的代码改写成如下所示：

``` js
with(location){
    var qs = search.substring(1);
    var hostName = hostname;
    var url = href;
}
```

**严格模式**下**不允许**使用`with`语句

大量使用`with`语句会**导致性能下降**，同时也会给调试代码造成困难，因此在开发大型应用程序时，**不建议使用`with`语句**。

### switch语句

``` js
 switch (expression) {
  case value: 
    statement
    break;
  case value: 
    statement
    break;
  default: statement
}
```

如果省略`break`关键字，就会导致执行完当前`case`后，继续执行下一个`case`。

当所有的`case`都不匹配的时候，执行`default`后代码。

使用表达式作为case值还可以实现下列操作：

``` js
var num = 25;
switch (true) {
    case num < 0: 
        alert("Less than 0.");
        break;
    case num >= 0 && num <= 10: 
        alert("Between 0 and 10.");
        break;
    case num > 10 && num <= 20: 
        alert("Between 10 and 20.");
        break;
    default: 
        alert("More than 20.");
}
```

这个例子首先在`switch`语句外面声明了变量`num`。而之所以给`switch`语句传递表达式`true`，是因为每个case值都可以返回一个**布尔值**。这样，每个case按照顺序被求值，直到找到匹配的值或者遇到default语句为止。

`switch`语句在比较值时使用的是**全等操作符**，因此不会发生类型转换