## 数组

### 数组去重

- 利用对象存储不重复的数字
- 循环数组，只要对象里面不存在该数字，则存储进去
- 如果已经存在，则在数组中利用索引删除该数字

```js
function removeDuplicates(arr) {
  const obj = {};
  for (let i = 0; i < arr.length; i++) {
    const item = arr[i];
    if (obj.hasOwnProperty(item)) {
      arr.splice(i, 1);
      i--;
    }
    obj[item] = item;
  }

  return arr.length;
}
```

### 旋转一维数组

给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。

``` bash
输入: [1,2,3,4,5,6,7] k = 3
输出: [5,6,7,1,2,3,4]
```

```js
function arrRotate(arr, num) {
  if (num <= 0) return arr;
  for (let i = 0; i < num; i++) {
    arr.unshift(arr[arr.length - 1]);
    arr.pop();
  }
}
```

### 两个数组的交集

给定两个数组，编写一个函数来计算它们的交集。

```bash
输入: nums1 = [1,2,2,1], nums2 = [2,2]
输出: [2,2]
```

### 买卖股票的最佳时机

给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

```bash
输入: [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
```

#### 循环前后两者比较

**思路:**

- 循环数组（不遍历最后一项），让当前项与后一项比较
- 如果当前项小于后一项，则购入当前项，然后在后一项的时候卖出
- 如果大于或等于，则什么也不做

**缺点:**
会产生连续购入和卖出

```js
function maxProfit(arr) {
  let totalProfit = 0;

  for (let i = 0; i < arr.length - 1; i++) {
    const curValue = arr[i];
    const nextValue = arr[i + 1];
    if (nextValue > curValue) {
      totalProfit += nextValue - curValue;
    }
  }

  return totalProfit;
}
```

#### 优化循环比较

- 增加记录买入、卖出时的索引
- 增加比较，如果前一个不存在或者大于当前值，并且当前值小于后一个值，则记录当前索引为买入（此时实际买入），后一个索引为卖出索引（只是记录可能卖出，不是实际卖出）

```js
function maxProfit2(arr) {
  const record = [];
  let totalProfit = 0;
  let buyIndex = 0;
  let sellIndex = 0;

  for (let i = 0; i < arr.length - 1; i++) {
    const curValue = arr[i];
    const nextValue = arr[i + 1];
    if (nextValue >= curValue) {
      sellIndex = i + 1;
    } else {
      if (sellIndex !== buyIndex) {
        totalProfit += arr[sellIndex] - arr[buyIndex];
        record.push({
          buy: buyIndex,
          sell: sellIndex
        });
      }
      buyIndex = i + 1;
      sellIndex = i + 1;
    }
  }

  if (sellIndex !== buyIndex) {
    totalProfit += arr[sellIndex] - arr[buyIndex];
    record.push({
      buy: buyIndex,
      sell: sellIndex
    });
  }

  return totalProfit;
}
```

## 链表

链表存储有序的元素集合, 每个元素由一个存储元素本身的节点和一个指向下一个元素的指针组成.

![Screen Shot 2019-08-29 at 4.54.01 PM](https://i.imgur.com/Su1GeQF.png)

相对于传统的数组，链表的一个好处在于，添加或移除元素的时候不需要移动其他元素。然而，数组可以直接访问任何位置的任何元素，而要想访问链表中间的一个元素，需要从起点开始迭代, 直到找到所需的元素。

### 创建链表

```js
function LinkedList() {
  this.head = null;
}
```

### 添加节点

```js
function LinkedNode(value) {
  this.value = value;
  this.next = null;
}

LinkedList.prototype.insertNode = function(value, index) {
  const node = new LinkedNode(value);
  if (this.head === null) this.head = node;
  else {
    let current = this.head;
    let curIndex = 0;
    while (current.next && index !== curIndex) {
      current = current.next;
      curIndex++;
    }
    node.next = current.next;
    current.next = node;
  }
  return this.head;
};
```

### 删除节点

```js
LinkedList.prototype.deleteNode = function(index) {
  let current = this.head;
  let previous = null;
  let curIndex = 0;
  if (index === 0) this.head = current.next;
  else {
    while (current.next && curIndex !== index) {
      previous = current;
      current = current.next;
      curIndex++;
    }
    previous.next = current.next;
  }
};
```

### 反转链表

#### 迭代实现

```js
LinkedList.prototype.reverse = function() {
  if (this.head === null || this.head.next === null) return this.head;
  let current = this.head;
  let previous = null;
  let next = current.next;
  current.next = null;

  while (next) {
    previous = current;
    current = next;
    next = current.next;
    current.next = previous;
  }
  this.head = current;
};
```

#### 递归实现

```js
LinkedList.prototype.reverse = function() {
  if (this.head === null || this.head.next === null) return this.head;
  const current = this.head;
  const reverse = function(previous, current) {
    let head = null;
    const next = current.next;

    if (next) head = reverse(current, next);
    else head = current;
    current.next = previous;

    return head;
  };
  this.head = reverse(current, current.next);
  current.next = null;
};
```

### 链表排序

```js
```

### 拼接链表, 并排序

### 双向链表

在双向链表中，链接是双向的：一个链向下一个元素， 另一个链向前一个元素.

![Screen Shot 2019-08-31 at 2.15.15 PM](https://i.imgur.com/CcbYNGF.png)

#### 创建双向链表

```js
function DoubleLinkedList() {
  this.head = null;
  this.tail = null;
}

function DoubleLinkedNode(value) {
  this.value = value;
  this.prev = null;
  this.next = null;
}
```

#### 插入节点

```js
DoubleLinkedList.prototype.insertNode = function(value, index) {
  const node = new DoubleLinkedNode(value);
  let current = this.head;
  let curIndex = 0;

  // 插入到头部
  if (index <= 0 || current === null) {
    node.next = current;
    this.head = node;
    return this.head;
  }

  //找到目标节点
  while (current.next && index !== curIndex) {
    current = current.next;
    curIndex++;
  }

  //插入到尾部
  if (current.next === null) {
    node.prev = current;
    node.next = current.next;
    current.next = node;
    this.tail = node;
    // 插入到目标节点处
  } else {
    current.prev.next = node;
    node.prev = current.prev;
    node.next = current;
    current.prev = node;
  }

  return this.head;
};
```

#### 删除节点

```js
DoubleLinkedList.prototype.deleteNode = function(index) {
  if (this.head === null || this.head.next === null) {
    this.head = null;
    return this.head;
  }

  if (index <= 0) {
    this.head = this.head.next;
    this.head.prev = null;
    return this.head;
  }

  let current = this.head;
  let curIndex = 0;

  while (current.next && index !== curIndex) {
    current = current.next;
    curIndex++;
  }

  if (current.next === null) {
    current.prev.next = null;
    this.tail = current.prev;
  } else {
    current.prev.next = current.next;
    current.next.prev = current.prev;
  }

  return this.head;
};
```

## 排序

### 冒泡排序

**思路:** 比较任何两个相邻的项，如果第一个比第二个大，则交换它们。元素项向上移动至正确的顺序.

```js
function bubble_sort(unsorted) {
  // 外循环: 每次循环确定一个项的正确顺序.
  for (let i = 0; i < unsorted.length; i++) {
    // 内循环: 每次循环对比相邻两个项的大小, 小的放在前, 大的放在后.
    for (let j = 0; j < unsorted.length - i - i; j++) {
      if (unsorted[j] > unsorted[j + 1]) {
        const temp = unsorted[j];
        unsorted[j] = unsorted[j + 1];
        unsorted[j + 1] = temp;
      }
    }
  }
}
```

![Screen Shot 2019-08-28 at 10.41.16 AM](https://i.imgur.com/XColZtB.png)

### 选择排序

**思路:** 是找到数据结构中的最小值并将其放置在第一位，接着找到第二小的值并将其放在第二位, 以此类推.

```js
function select_sort(unsorted) {
  for (let i = 0; i < unsorted.length; i++) {
    let minIndex = i;
    for (let j = i + 1; j < unsorted.length; j++) {
      minIndex = unsorted[j] < unsorted[minIndex] ? j : minIndex;
    }
    let temp = unsorted[i];
    unsorted[i] = unsorted[minIndex];
    unsorted[minIndex] = temp;
  }
}
```

![Screen Shot 2019-08-29 at 10.14.36 AM](https://i.imgur.com/hrqLdEH.png)

### 插入排序

**思路:** 每次排一个数组项，以此方式构建最后的排序数组. 假定第一个项是  已经排序的, 依次将后面的项与已经排序好的项做对比, 并将其插入到正确位置.

```js
function insert_sort(unsorted) {
  for (let i = 1; i < unsorted.length; i++) {
    let temp = unsorted[i];
    let j = i;
    while (j > 0 && unsorted[j - 1] > temp) {
      unsorted[j] = unsorted[j - 1];
      j--;
    }
    unsorted[j] = temp;
  }
}
```

![Screen Shot 2019-08-29 at 10.12.28 AM](https://i.imgur.com/ppjfdaq.png)

### 归并排序

**思路:** 采用分治策略, 将原始数组切分成较小的数组，直到每个小数组只有一个项，接着将小数组归并成较大的数组，直到最后只有一个排序完毕的大数组。

```js
function merge_sort(unsorted) {
  const merge = function(left, right) {
    const result = [];
    let i = 0,
      j = 0;

    while (i < left.length && j < right.length) {
      if (left[i] <= right[j]) {
        result.push(left[i]);
        i++;
      } else {
        result.push(right[j]);
        j++;
      }
    }
    while (i < left.length) {
      result.push(left[i]);
      i++;
    }
    while (j < right.length) {
      result.push(right[j]);
      j++;
    }

    return result;
  };

  const divide = function(arr) {
    if (arr.length <= 1) return arr;
    const mid = Math.floor(arr.length / 2);
    const left = arr.slice(0, mid);
    const right = arr.slice(mid, arr.length);
    return merge(divide(left), divide(right));
  };

  return divide(unsorted);
}
```

![Screen Shot 2019-08-29 at 3.09.42 PM](https://i.imgur.com/NkaH3Sq.png)

### 快速排序

**思路:**

- 采用分治策略. 首先，从数组中选择中间一项作为主元.
- 创建两个指针，左边一个指向数组第一个项，右边一个指向数组最后一个项。移动左指 针直到我们找到一个比主元大的元素，接着，移动右指针直到找到一个比主元小的元素，然后交换它们，重复这个过程，直到左指针超过了右指针. 这个过程将使得比主元小的值都排在主元之前，而比主元大的值都排在主元之后。这一步叫作划分操作.
- 接着，算法对划分后的小数组（较主元小的值组成的子数组，以及较主元大的值组成的子数组）重复之前的两个步骤，直至数组已完全排序

```js
function quick_sort(unsorted) {
  const partition = function(arr, left, right) {
    const index = Math.floor((left + right) / 2);
    const pivot = arr[index];
    let i = left;
    let j = right;
    while (i <= j) {
      while (arr[i] < pivot) {
        i++;
      }
      while (arr[j] > pivot) {
        j--;
      }
      if (i <= j) {
        const temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
        i++;
        j--;
      }
    }
    return i;
  };
  const quick = function(arr, left, right) {
    if (right - left < 1) return;
    let index = partition(arr, left, right);
    if (left < index - 1) {
      quick(arr, left, index - 1);
    }
    if (right > index) {
      quick(arr, index, right);
    }
  };
  quick(unsorted, 0, unsorted.length - 1);
}
```

![Screen Shot 2019-08-29 at 3.37.46 PM](https://i.imgur.com/wLQ1IEG.png)

下图中, 对有较小值的子数组执行划分操作

![Screen Shot 2019-08-29 at 3.54.56 PM](https://i.imgur.com/Ext1lDf.png)

继续创建子数组，下图针对上图中有较大值的子数组

![Screen Shot 2019-08-29 at 3.56.31 PM](https://i.imgur.com/6ERbKc8.png)
