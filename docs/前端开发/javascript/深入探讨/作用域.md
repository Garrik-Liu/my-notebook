# 作用域

## 什么是作用域

简单来说, 『 作用域 』就是一套用来储存变量, 操纵变量的**规则**.

### 传统编译原理

尽管我们通常将 JavaScript 归类为“动态”或“解释执行”语言，但事实上它是一门编译语言。但与传统的编译语言不同，它不是提前编译的，JavaScript 的编译过程不是发生在构建之前的。简单地说，任何 JavaScript 代码片段在执行前都要进行编译（通常 就在 执行前）。

在**传统编译语言**的流程中，程序中的一段源代码在执行之前会经历三个步骤，统称为“编译”。

* **分词/词法分析**（Tokenizing/Lexing）
将由字符组成的 字符串 分解成（对编程语言来说）有意义的 代码块，这些 代码块 被称为 『 词法单元（token） 』。例如，`var a = 2;` 这段程序通常会被分解成为下面这些词法单元： `var`, `a`, `=`, `2`, `;`. 

* **解析/语法分析**（Parsing）
将 『 词法单元流（数组） 』转换成一个由元素逐级嵌套所组成的代表了程序语法
结构的树, 被称为 『 抽象语法树 』（Abstract Syntax Tree，AST）。`var a = 2;` 的抽象语法树中可能会有一个叫作 `VariableDeclaration` 的顶级节点，接下来是一个叫作 `Identifier` （它的值是 `a` ）的子节点，以及一个叫作 `AssignmentExpression` 的子节点。 `AssignmentExpression` 节点有一个叫作 `NumericLiteral` （它的值是 `2` ）的子节点。

* **代码生成**
将 抽象语法树 (AST) 转换为 可执行代码的过程 称被称为代码生成。这个过程与语言、目标平台等相关。简单来说就是有某种方法可以将 `var a = 2;` 的 抽象语法树 (AST) 转化为一组『 机器指令 』，用来创建一个叫作 `a` 的变量（包括分配内存等），并将一个值储存在 `a` 中。

### 初步理解作用域

下面用拟人对话的形式, 模拟 `var a = 2;` 这段代码的处理过程.

参与到的角色有:

* 引擎
从头到尾负责整个 JavaScript 程序的编译及执行过程。

* 编译器
引擎的好朋友之一，负责语法分析及代码生成等

* 作用域
引擎的另一位好朋友， 负责收集并维护所有声明的标识符（变量），并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。

编译器首先会将这段程序分解成词法单元，然后将词法单元解析成一个树结构。当编译器开始进行代码生成时，它会进行如下处理:

* 遇到 `var a` ，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为 `a`

* 接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理 `a = 2` 这个赋值操作。 引擎运行时会首先询问作用域， 在当前的作用域集合中是否存在一个叫作 `a` 的变量。 如果是，引擎就会使用这个变量；如果否，引擎会继续查找该变量.如果引擎最终找到了 `a` 变量， 就会将 `2` 赋值给它。 否则引擎就会抛出异常.

### 作用域嵌套

实际情况中，通常需要同时顾及几个作用域。当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域（也就是全局作用域）为止。

## 词法作用域

在第1章中，我们将“作用域”定义为一套规则，这套规则用来管理引擎如何在当前作用域以及嵌套的子作用域中根据标识符名称进行变量查找。

作用域共有两种主要的工作模型。第一种是最为普遍的，被大多数编程语言所采用的 **词法作用域**，另外一种叫作 **动态作用域**

### 词法阶段

大部分标准语言编译器的第一个工作阶段叫作**词法化**（单词化）

简单地说，**词法作用域就是定义在词法阶段的作用域**。

``` js
function foo(a) {
    var b = a * 2;
    function bar(c) {
        console.log( a, b, c );
    }
    bar( b * 3 );
}
foo( 2 ); // 2, 4, 12
```

在这个例子中有三个逐级嵌套的作用域。

作用域的结构和互相之间的位置关系给引擎提供了足够的位置信息，引擎用这些信息来查找标识符的位置。

作用域查找始终从运行时所处的最内部作用域开始，逐级向外或者说向上进行，直到遇见第一个匹配的标识符为止。**作用域查找会在找到第一个匹配的标识符时停止。**

引擎执行`console.log(..)`声明，并查找`a`、`b` 和 `c` 三个变量的引用。它首先从最内部的作用域，也就是`bar(..)`函数的作用域气泡开始查找。引擎无法在这里找到`a`，因此会去上一级到所嵌套的`foo(..)`的作用域中继续查找。在这里找到了`a`，因此引擎使用了这个引用。对`b`来讲也是一样的。而对`c`来说，引擎在`bar(..)`中就找到了它。

### 欺骗词法

无论函数在哪里被调用，也无论它如何被调用，**函数的词法作用域都只由函数被声明时所处的位置决定**。

如果词法作用域完全由写代码期间函数所声明的位置来定义，怎样才能在运行时来“修改”（也可以说欺骗）词法作用域呢？

::: warning
欺骗词法作用域会导致性能下降。
:::

JavaScript 中有两种机制来实现这个目的:
* `eval`
* `with`

#### `eval`

`eval(..)` 函数可以接受一个字符串为参数，并将其中的内容视为好像在书写时就存在于程序中这个位置的代码, 换句话说，可以在你写的代码中用程序生成代码并运行，就好像（词法期）代码就在那。

在执行· 之后的代码时，引擎并不“在意”前面的代码是以动态形式插入进来，并对词法作用域的环境进行修改的。引擎只会如往常地进行词法作用域查找。

``` js
function foo(str, a) {
    eval( str ); // 欺骗！
    console.log( a, b );
}
var b = 2;
foo( "var b = 3;", 1 ); // 1, 3
```

`var b = 3;` 声明了一个新的变量 `b`。 因此它对已经存在的`foo(..)` 的词法作用域进行了修改。也就是这段代码实际上在`foo(..) `内部创建了一个变量`b`，并遮蔽了外部（全局）作用域中的同名变量。

::: warning
在严格模式的程序中，`eval(..)` 在运行时有其自己的词法作用域，意味着其中的声明无法修改所在的作用域。
:::

#### `with`

`with` 通常被当作重复引用同一个对象中的多个属性的快捷方式

``` js
var obj = {
    a: 1,
    b: 2,
    c: 3
};

// 单调乏味的重复"obj"
obj.a = 2;
obj.b = 3;
obj.c = 4;

// 简单的快捷方式
with (obj) {
    a = 3;
    b = 4;
    c = 5;
}
```

再看另外一个例子：

``` js
function foo(obj) {
    with (obj) {
        a = 2;
    }
}

var o1 = {
    a: 3;
}

var o2 = {
    b: 3;
}

foo( o1 );
console.log( o1.a ); // 2

foo( o2 );
console.log( o2.a ); // undefined

console.log( a ); // 2, a 被泄漏到全局作用域上了！
```

这个例子中创建了 `o1` 和 `o2` 两个对象。其中一个具有`a`属性，另外一个没有。`foo(..)` 函数接受一个 `obj` 参数，该参数是一个对象引用，并对这个对象引用执行了`with(obj) {..}`。

在 `with` 块内部，我们写的代码看起来只是对变量 `a` 进行简单的词法引用，实际上就是一个
LHS 引用，并将2 赋值给它。

当我们将 `o1` 传递进去，`a ＝ 2` 赋值操作找到了`o1.a` 并将`2` 赋值给它.  而当 `o2` 传递进去，`o2` 并没有`a` 属性，因此不会创建这个属性，`o2.a` 保持 `undefined`。但是可以注意到一个奇怪的副作用，实际上`a = 2` 赋值操作创建了一个全局的变量`a`。

`with` 可以**将一个没有或有多个属性的对象处理为一个 完全隔离 的词法作用域**，因此这个对象的属性也会被处理为定义在这个作用域中的词法标识符。

也就是， `o2` 的作用域、`foo(..)` 的作用域和全局作用域中都没有找到标识符`a`，因此当`a＝2` 执行
时，自动创建了一个全局变量（因为是非严格模式）。

#### 性能问题

`eval(..)` 和 `with` 会在运行时修改或创建新的作用域，以此来欺骗其他在书写时定义的词
法作用域。

但那又怎样呢？如果它们能实现更复杂的功能，并且代码更具有扩展性，难道不是非常好的功能吗？**答案是否定的**。

JavaScript 引擎会在编译阶段进行数项的性能优化。其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。

但如果引擎在代码中发现了`eval(..)` 或`with`，它只能简单地假设关于标识符位置的判断都是无效的，因为无法在词法分析阶段明确知道`eval(..)` 会接收到什么代码，这些代码会如何对作用域进行修改，也无法知道传递给`with` 用来创建新词法作用域的对象的内容到底是什么。可能所有的优化可能都是无意义的，因此最简
单的做法就是完全不做任何优化。**如果没有这些优化，代码会运行得更慢**

另外一个不推荐使用 `eval(..)` 和 `with` 的原因是会被 **严格模式** 所限制。

## 函数作用域 & 块作用域

很多人认为 JavaScript 具有基于函数的作用域，意味着每声明一个函数都会为其自身创建一个作用域，而其他结构都不会创建作用域。但事实上这并不完全正确.

函数作用域的含义是指，**属于这个函数的全部变量都可以在整个函数的范围内使用及复用**

对函数的传统认知就是先声明一个函数，然后再向里面添加代码。但反过来想也可以带来 一些启示：从所写的代码中挑选出一个任意的片段，然后用函数声明对它进行包装，实际 上就是把这些代码“隐藏”起来了。实际的结果就是**在这个代码片段的周围创建了一个作用域**, 也就是说这段代码中的任 何声明（变量或函数）都将绑定在这个新创建的包装函数的作用域中.

### 为什么要 "隐藏"?

#### 最小暴露原则

有很多原因促成了这种基于作用域的隐藏方法。 它们大都是从 "最小特权原则" 中引申出来 的，也叫 "最小授权" 或 "最小暴露原则"。

这个原则是指在软件设计中，应该**最小限度地暴露必要内容**，而将其他内容都“隐藏”起来.

如果所有的变量和函数都在全局作用域中可以访问, 这可能会暴漏过多的变量或函数，而这些变量或函数本应该是私有的.  正确的代码应该是可以阻止对这些变量或函数进行访问的。

#### 避免冲突

“隐藏”作用域中的变量和函数所带来的另一个好处，是可以避免同名标识符之间的冲突.

变量冲突的一个典型例子存在于全局作用域中。当程序中加载了多个第三方库时，如果它 们没有妥善地将内部私有的函数或变量隐藏起来，就会很容易引发冲突。

### 函数作用域

我们已经知道， 在任意代码片段外部添加包装函数， 可以将内部的变量和函数定义“隐 藏”起来，外部作用域无法访问包装函数内部的任何内容。

``` js
var a = 2; 

function foo() { 
    var a = 3; 
    console.log( a ); // 3
} 

console.log( a ); // 2
```

上面这段代码中, 声明一个具名函数 `foo()` ，意味着 `foo` 这个名称本身“**污染**”了所在作用域（在这个 例子中是全局作用域）。其次，必须显式地通过函数名调用这个函数才能运行其中的代码。

如果函数不需要函数名（或者至少函数名可以不污染所在作用域），并且能够自动运行， 这将会更加理想。

JavaScript 提供了能够同时解决这两个问题的方案:

``` js
var a = 2; 

(function foo() { 
    var a = 3; 
    console.log( a ); // 3
})(); 

console.log( a ); // 2
```

上面代码中, 函数会被**当作函数表达式**而不是一个标准的函数声明来处理。

::: warning
区分函数声明和表达式最简单的方法是看 `function` 关键字出现在声明中的位置.  如果 `function` 是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。
:::