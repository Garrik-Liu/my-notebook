# 数据类型

JavaScript 有七种内置类型：

* 基本类型
  * 空值（ null ） 
  * 未定义（ undefined ） 
  * 布尔值（ boolean ） 
  * 数字（ number ） 
  * 字符串（ string ） 
  * 符号（ symbol ）
* 引用类型
  * 对象（ object ） 

## 基本类型 & 引用类型

### 栈内存 & 堆内存

在 JavaScript 中，每一个数据都需要一个内存空间。内存空间又被分为两种，"栈内存" (stock) 与 "堆内存" (heap)。

#### 栈内存

栈是一个 "后进先出" 的结构。当把数据放入栈时，我们把数据 Push 进入；当从栈取出数据时，我们把数据 Pop 出来。

#### 堆内存

堆（英语：Heap）是计算机科学中的一种特别的树状数据结构。

堆内存允许程序在运行时动态地申请某个大小的内存空间。

### 基本类型

除 Object 以外的所有类型都是不可变的（值本身无法被改变）, 这些类型被称为 『 基本类型/原始数据类型 』 ( primitive values )

基本类型在内存中 "占据空间小、大小固定" ，他们的值保存在栈内存中，按 "值" 来进行访问.

原始值是不可更改的, 你只能给代表它的变量重新赋值，将原来的值覆盖.

拿字符串举例, 要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量.

### 引用类型

引用类型 "占据空间大、大小不固定", 储存在堆内存中。按 "引用" 来进行访问.

当创建一个引用类型时, 堆内存为这个值分配空间.  因为其大小不固定, 所有不能储存在栈内存中.  但其内存地址大小固定, 因此将引用类型的内存地址储存在栈内存中.

当查询引用类型的变量时, 先从栈内存读取内存地址, 然后在去堆内存找实际的值.

![7c13147ecfecd8a6ce7f0b5a9782dd30](https://i.loli.net/2019/02/23/5c710090063a3.png)

::: tip 指针?
在计算机科学中，指针（英语：Pointer），是编程语言中的一类数据类型及其对象或变量.  **用来表示或存储一个存储器地址，这个地址的值直接指向存在该地址的对象的值。**
:::

::: tip 储存器?
存储器（Memory）是现代信息技术中用于保存信息的记忆设备。在数字系统中，**只要能保存二进制数据的都可以是存储器**. 在系统中，具有实物形式的存储设备也叫存储器，如内存条、TF卡等。
:::

## 类型简介

#### Undefined

Undefined 类型只有一个值，即 `undefined`.  当一个变量被声明, 但没被初始化时, 其值为 `undefined`.

#### Null

Null 类型只有一个值：`null`, 表示一个空对象指针.

如果定义的变量准备用于保存对象，那么最好将该变量初始化为 `null` 而不是其他值.

#### Boolean

Boolean 类型只有两个字面值：`true` 和 `false`

#### Number

JavaScript 使用 IEEE 754 标准的双精度 64 位 (8字节) 二进制格式的值 `( -(2^63 - 1) 到 2^63 - 1)` 作为 Number 类型.

#### String

String 类型用于表示文本数据.  由 16位 Unicode 字符组成. 在创建时, 由双引号（"）或单引号（'）起始或者结束.

在字符串中每个字符占据一个位置, 第一个元素的索引为 0，下一个是索引 1，依此类推。

#### Symbol

Symbol 类型的值由 `Symbol()` 创建.  Symbol 值是唯一且不可改变的.

该类型通常被用作一个对象属性的键值.

#### Object

在计算机科学中, 对象是指内存中的可以被 标识符引用的一块区域.  

在 Javascript 里，对象可以被看作是一组属性和方法的集合。

## 单体内置对象

ECMA-262 对内置对象的定义是："**由 ECMAScript 实现提供的、不依赖于宿主环境的对象，这些对象在 ECMAScript 程序执行之前就已经存在了**"。
意思就是说，开发人员不必显式地实例化内置对象，因为它们已经实例化了。可以在全局作用域里访问到它们

具体的内容可以直接参考下面 👇 链接:

[MDN 单体内置对象](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects)

### Global 对象

**所有在全局作用域中定义的属性和函数，都是 Global 对象的属性**。

ECMAScript 没有指出如何直接访问 Global对象，但浏览器将这个全局对象作为 `window` 对象的一部分加以实现.  因此，在全局作用域中声明的所有变量和函数，在浏览器上就都成为了 `window` 对象的属性。

``` js
var color = "red";

function sayColor(){
    alert(window.color);
}

window.sayColor();  //"red"
```

## 类型转换

JavaScript 中有两种类型转换：**显式** 与 **隐式**。

显式的类型转换就是 你可以在代码中看到的类型由一种转换到另一种，而隐式的类型转换多是某些运算可能存在的隐式副作用而引发的类型转换。

### 基本包装类型

为了便于操作基本类型值，ECMAScript 还提供了3个特殊的对象：`Boolean()`、`Number()` 和 `String()`. 每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型实例，从而让我们能够调用一些方法来操作这些数据。

``` js
var s1 = "some text";
var s2 = s1.substring(2);
```

上面这段代码执行时, 后台自动做了如下处理:
1. 创建 String 类型的一个实例；
2. 在 String 实例上调用指定的方法；
3. 销毁这个实例;

#### 生命周期

使用 `new` 操作符创建的对象实例，在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的实例，则只存在于一行代码的执行瞬间。这意味着我们不能在运行时为基本类型值添加属性和方法。

要注意的是，使用 `new` 调用基本包装类型的构造函数，与直接调用同名的转型函数是不一样的。

``` js
var value = "25";
var number = Number(value);  //转型函数
alert(typeof number);        //"number"

var obj = new Number(value); //构造函数
alert(typeof obj);           //"object"
```

### 显式转换



### 隐式转换


### == & ===